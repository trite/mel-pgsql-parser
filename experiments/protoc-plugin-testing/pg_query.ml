(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: pg_query.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

(* open Ocaml_protoc_plugin.Runtime [@@warning "-33"] *)
module Pg_query = struct
  module rec OverridingKind : sig
    type t = OVERRIDING_KIND_UNDEFINED | OVERRIDING_NOT_SET | OVERRIDING_USER_VALUE | OVERRIDING_SYSTEM_VALUE 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = OVERRIDING_KIND_UNDEFINED | OVERRIDING_NOT_SET | OVERRIDING_USER_VALUE | OVERRIDING_SYSTEM_VALUE 
    let to_int = function
      | OVERRIDING_KIND_UNDEFINED -> 0
      | OVERRIDING_NOT_SET -> 1
      | OVERRIDING_USER_VALUE -> 2
      | OVERRIDING_SYSTEM_VALUE -> 3
    
    let from_int = function
      | 0 -> Ok OVERRIDING_KIND_UNDEFINED
      | 1 -> Ok OVERRIDING_NOT_SET
      | 2 -> Ok OVERRIDING_USER_VALUE
      | 3 -> Ok OVERRIDING_SYSTEM_VALUE
      | n -> Error (`Unknown_enum_value n)
    
  end
  and QuerySource : sig
    type t = QUERY_SOURCE_UNDEFINED | QSRC_ORIGINAL | QSRC_PARSER | QSRC_INSTEAD_RULE | QSRC_QUAL_INSTEAD_RULE | QSRC_NON_INSTEAD_RULE 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = QUERY_SOURCE_UNDEFINED | QSRC_ORIGINAL | QSRC_PARSER | QSRC_INSTEAD_RULE | QSRC_QUAL_INSTEAD_RULE | QSRC_NON_INSTEAD_RULE 
    let to_int = function
      | QUERY_SOURCE_UNDEFINED -> 0
      | QSRC_ORIGINAL -> 1
      | QSRC_PARSER -> 2
      | QSRC_INSTEAD_RULE -> 3
      | QSRC_QUAL_INSTEAD_RULE -> 4
      | QSRC_NON_INSTEAD_RULE -> 5
    
    let from_int = function
      | 0 -> Ok QUERY_SOURCE_UNDEFINED
      | 1 -> Ok QSRC_ORIGINAL
      | 2 -> Ok QSRC_PARSER
      | 3 -> Ok QSRC_INSTEAD_RULE
      | 4 -> Ok QSRC_QUAL_INSTEAD_RULE
      | 5 -> Ok QSRC_NON_INSTEAD_RULE
      | n -> Error (`Unknown_enum_value n)
    
  end
  and SortByDir : sig
    type t = SORT_BY_DIR_UNDEFINED | SORTBY_DEFAULT | SORTBY_ASC | SORTBY_DESC | SORTBY_USING 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime.Result.error]) result
  end = struct 
    type t = SORT_BY_DIR_UNDEFINED | SORTBY_DEFAULT | SORTBY_ASC | SORTBY_DESC | SORTBY_USING 
    let to_int = function
      | SORT_BY_DIR_UNDEFINED -> 0
      | SORTBY_DEFAULT -> 1
      | SORTBY_ASC -> 2
      | SORTBY_DESC -> 3
      | SORTBY_USING -> 4
    
    let from_int = function
      | 0 -> Ok SORT_BY_DIR_UNDEFINED
      | 1 -> Ok SORTBY_DEFAULT
      | 2 -> Ok SORTBY_ASC
      | 3 -> Ok SORTBY_DESC
      | 4 -> Ok SORTBY_USING
      | n -> Error (`Unknown_enum_value n)
    
  end
  and SortByNulls : sig
    type t = SORT_BY_NULLS_UNDEFINED | SORTBY_NULLS_DEFAULT | SORTBY_NULLS_FIRST | SORTBY_NULLS_LAST 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = SORT_BY_NULLS_UNDEFINED | SORTBY_NULLS_DEFAULT | SORTBY_NULLS_FIRST | SORTBY_NULLS_LAST 
    let to_int = function
      | SORT_BY_NULLS_UNDEFINED -> 0
      | SORTBY_NULLS_DEFAULT -> 1
      | SORTBY_NULLS_FIRST -> 2
      | SORTBY_NULLS_LAST -> 3
    
    let from_int = function
      | 0 -> Ok SORT_BY_NULLS_UNDEFINED
      | 1 -> Ok SORTBY_NULLS_DEFAULT
      | 2 -> Ok SORTBY_NULLS_FIRST
      | 3 -> Ok SORTBY_NULLS_LAST
      | n -> Error (`Unknown_enum_value n)
    
  end
  and SetQuantifier : sig
    type t = SET_QUANTIFIER_UNDEFINED | SET_QUANTIFIER_DEFAULT | SET_QUANTIFIER_ALL | SET_QUANTIFIER_DISTINCT 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = SET_QUANTIFIER_UNDEFINED | SET_QUANTIFIER_DEFAULT | SET_QUANTIFIER_ALL | SET_QUANTIFIER_DISTINCT 
    let to_int = function
      | SET_QUANTIFIER_UNDEFINED -> 0
      | SET_QUANTIFIER_DEFAULT -> 1
      | SET_QUANTIFIER_ALL -> 2
      | SET_QUANTIFIER_DISTINCT -> 3
    
    let from_int = function
      | 0 -> Ok SET_QUANTIFIER_UNDEFINED
      | 1 -> Ok SET_QUANTIFIER_DEFAULT
      | 2 -> Ok SET_QUANTIFIER_ALL
      | 3 -> Ok SET_QUANTIFIER_DISTINCT
      | n -> Error (`Unknown_enum_value n)
    
  end
  and A_Expr_Kind : sig
    type t = A_EXPR_KIND_UNDEFINED | AEXPR_OP | AEXPR_OP_ANY | AEXPR_OP_ALL | AEXPR_DISTINCT | AEXPR_NOT_DISTINCT | AEXPR_NULLIF | AEXPR_IN | AEXPR_LIKE | AEXPR_ILIKE | AEXPR_SIMILAR | AEXPR_BETWEEN | AEXPR_NOT_BETWEEN | AEXPR_BETWEEN_SYM | AEXPR_NOT_BETWEEN_SYM 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = A_EXPR_KIND_UNDEFINED | AEXPR_OP | AEXPR_OP_ANY | AEXPR_OP_ALL | AEXPR_DISTINCT | AEXPR_NOT_DISTINCT | AEXPR_NULLIF | AEXPR_IN | AEXPR_LIKE | AEXPR_ILIKE | AEXPR_SIMILAR | AEXPR_BETWEEN | AEXPR_NOT_BETWEEN | AEXPR_BETWEEN_SYM | AEXPR_NOT_BETWEEN_SYM 
    let to_int = function
      | A_EXPR_KIND_UNDEFINED -> 0
      | AEXPR_OP -> 1
      | AEXPR_OP_ANY -> 2
      | AEXPR_OP_ALL -> 3
      | AEXPR_DISTINCT -> 4
      | AEXPR_NOT_DISTINCT -> 5
      | AEXPR_NULLIF -> 6
      | AEXPR_IN -> 7
      | AEXPR_LIKE -> 8
      | AEXPR_ILIKE -> 9
      | AEXPR_SIMILAR -> 10
      | AEXPR_BETWEEN -> 11
      | AEXPR_NOT_BETWEEN -> 12
      | AEXPR_BETWEEN_SYM -> 13
      | AEXPR_NOT_BETWEEN_SYM -> 14
    
    let from_int = function
      | 0 -> Ok A_EXPR_KIND_UNDEFINED
      | 1 -> Ok AEXPR_OP
      | 2 -> Ok AEXPR_OP_ANY
      | 3 -> Ok AEXPR_OP_ALL
      | 4 -> Ok AEXPR_DISTINCT
      | 5 -> Ok AEXPR_NOT_DISTINCT
      | 6 -> Ok AEXPR_NULLIF
      | 7 -> Ok AEXPR_IN
      | 8 -> Ok AEXPR_LIKE
      | 9 -> Ok AEXPR_ILIKE
      | 10 -> Ok AEXPR_SIMILAR
      | 11 -> Ok AEXPR_BETWEEN
      | 12 -> Ok AEXPR_NOT_BETWEEN
      | 13 -> Ok AEXPR_BETWEEN_SYM
      | 14 -> Ok AEXPR_NOT_BETWEEN_SYM
      | n -> Error (`Unknown_enum_value n)
    
  end
  and RoleSpecType : sig
    type t = ROLE_SPEC_TYPE_UNDEFINED | ROLESPEC_CSTRING | ROLESPEC_CURRENT_ROLE | ROLESPEC_CURRENT_USER | ROLESPEC_SESSION_USER | ROLESPEC_PUBLIC 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = ROLE_SPEC_TYPE_UNDEFINED | ROLESPEC_CSTRING | ROLESPEC_CURRENT_ROLE | ROLESPEC_CURRENT_USER | ROLESPEC_SESSION_USER | ROLESPEC_PUBLIC 
    let to_int = function
      | ROLE_SPEC_TYPE_UNDEFINED -> 0
      | ROLESPEC_CSTRING -> 1
      | ROLESPEC_CURRENT_ROLE -> 2
      | ROLESPEC_CURRENT_USER -> 3
      | ROLESPEC_SESSION_USER -> 4
      | ROLESPEC_PUBLIC -> 5
    
    let from_int = function
      | 0 -> Ok ROLE_SPEC_TYPE_UNDEFINED
      | 1 -> Ok ROLESPEC_CSTRING
      | 2 -> Ok ROLESPEC_CURRENT_ROLE
      | 3 -> Ok ROLESPEC_CURRENT_USER
      | 4 -> Ok ROLESPEC_SESSION_USER
      | 5 -> Ok ROLESPEC_PUBLIC
      | n -> Error (`Unknown_enum_value n)
    
  end
  and TableLikeOption : sig
    type t = TABLE_LIKE_OPTION_UNDEFINED | CREATE_TABLE_LIKE_COMMENTS | CREATE_TABLE_LIKE_COMPRESSION | CREATE_TABLE_LIKE_CONSTRAINTS | CREATE_TABLE_LIKE_DEFAULTS | CREATE_TABLE_LIKE_GENERATED | CREATE_TABLE_LIKE_IDENTITY | CREATE_TABLE_LIKE_INDEXES | CREATE_TABLE_LIKE_STATISTICS | CREATE_TABLE_LIKE_STORAGE | CREATE_TABLE_LIKE_ALL 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = TABLE_LIKE_OPTION_UNDEFINED | CREATE_TABLE_LIKE_COMMENTS | CREATE_TABLE_LIKE_COMPRESSION | CREATE_TABLE_LIKE_CONSTRAINTS | CREATE_TABLE_LIKE_DEFAULTS | CREATE_TABLE_LIKE_GENERATED | CREATE_TABLE_LIKE_IDENTITY | CREATE_TABLE_LIKE_INDEXES | CREATE_TABLE_LIKE_STATISTICS | CREATE_TABLE_LIKE_STORAGE | CREATE_TABLE_LIKE_ALL 
    let to_int = function
      | TABLE_LIKE_OPTION_UNDEFINED -> 0
      | CREATE_TABLE_LIKE_COMMENTS -> 1
      | CREATE_TABLE_LIKE_COMPRESSION -> 2
      | CREATE_TABLE_LIKE_CONSTRAINTS -> 3
      | CREATE_TABLE_LIKE_DEFAULTS -> 4
      | CREATE_TABLE_LIKE_GENERATED -> 5
      | CREATE_TABLE_LIKE_IDENTITY -> 6
      | CREATE_TABLE_LIKE_INDEXES -> 7
      | CREATE_TABLE_LIKE_STATISTICS -> 8
      | CREATE_TABLE_LIKE_STORAGE -> 9
      | CREATE_TABLE_LIKE_ALL -> 10
    
    let from_int = function
      | 0 -> Ok TABLE_LIKE_OPTION_UNDEFINED
      | 1 -> Ok CREATE_TABLE_LIKE_COMMENTS
      | 2 -> Ok CREATE_TABLE_LIKE_COMPRESSION
      | 3 -> Ok CREATE_TABLE_LIKE_CONSTRAINTS
      | 4 -> Ok CREATE_TABLE_LIKE_DEFAULTS
      | 5 -> Ok CREATE_TABLE_LIKE_GENERATED
      | 6 -> Ok CREATE_TABLE_LIKE_IDENTITY
      | 7 -> Ok CREATE_TABLE_LIKE_INDEXES
      | 8 -> Ok CREATE_TABLE_LIKE_STATISTICS
      | 9 -> Ok CREATE_TABLE_LIKE_STORAGE
      | 10 -> Ok CREATE_TABLE_LIKE_ALL
      | n -> Error (`Unknown_enum_value n)
    
  end
  and DefElemAction : sig
    type t = DEF_ELEM_ACTION_UNDEFINED | DEFELEM_UNSPEC | DEFELEM_SET | DEFELEM_ADD | DEFELEM_DROP 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = DEF_ELEM_ACTION_UNDEFINED | DEFELEM_UNSPEC | DEFELEM_SET | DEFELEM_ADD | DEFELEM_DROP 
    let to_int = function
      | DEF_ELEM_ACTION_UNDEFINED -> 0
      | DEFELEM_UNSPEC -> 1
      | DEFELEM_SET -> 2
      | DEFELEM_ADD -> 3
      | DEFELEM_DROP -> 4
    
    let from_int = function
      | 0 -> Ok DEF_ELEM_ACTION_UNDEFINED
      | 1 -> Ok DEFELEM_UNSPEC
      | 2 -> Ok DEFELEM_SET
      | 3 -> Ok DEFELEM_ADD
      | 4 -> Ok DEFELEM_DROP
      | n -> Error (`Unknown_enum_value n)
    
  end
  and PartitionRangeDatumKind : sig
    type t = PARTITION_RANGE_DATUM_KIND_UNDEFINED | PARTITION_RANGE_DATUM_MINVALUE | PARTITION_RANGE_DATUM_VALUE | PARTITION_RANGE_DATUM_MAXVALUE 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = PARTITION_RANGE_DATUM_KIND_UNDEFINED | PARTITION_RANGE_DATUM_MINVALUE | PARTITION_RANGE_DATUM_VALUE | PARTITION_RANGE_DATUM_MAXVALUE 
    let to_int = function
      | PARTITION_RANGE_DATUM_KIND_UNDEFINED -> 0
      | PARTITION_RANGE_DATUM_MINVALUE -> 1
      | PARTITION_RANGE_DATUM_VALUE -> 2
      | PARTITION_RANGE_DATUM_MAXVALUE -> 3
    
    let from_int = function
      | 0 -> Ok PARTITION_RANGE_DATUM_KIND_UNDEFINED
      | 1 -> Ok PARTITION_RANGE_DATUM_MINVALUE
      | 2 -> Ok PARTITION_RANGE_DATUM_VALUE
      | 3 -> Ok PARTITION_RANGE_DATUM_MAXVALUE
      | n -> Error (`Unknown_enum_value n)
    
  end
  and RTEKind : sig
    type t = RTEKIND_UNDEFINED | RTE_RELATION | RTE_SUBQUERY | RTE_JOIN | RTE_FUNCTION | RTE_TABLEFUNC | RTE_VALUES | RTE_CTE | RTE_NAMEDTUPLESTORE | RTE_RESULT 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = RTEKIND_UNDEFINED | RTE_RELATION | RTE_SUBQUERY | RTE_JOIN | RTE_FUNCTION | RTE_TABLEFUNC | RTE_VALUES | RTE_CTE | RTE_NAMEDTUPLESTORE | RTE_RESULT 
    let to_int = function
      | RTEKIND_UNDEFINED -> 0
      | RTE_RELATION -> 1
      | RTE_SUBQUERY -> 2
      | RTE_JOIN -> 3
      | RTE_FUNCTION -> 4
      | RTE_TABLEFUNC -> 5
      | RTE_VALUES -> 6
      | RTE_CTE -> 7
      | RTE_NAMEDTUPLESTORE -> 8
      | RTE_RESULT -> 9
    
    let from_int = function
      | 0 -> Ok RTEKIND_UNDEFINED
      | 1 -> Ok RTE_RELATION
      | 2 -> Ok RTE_SUBQUERY
      | 3 -> Ok RTE_JOIN
      | 4 -> Ok RTE_FUNCTION
      | 5 -> Ok RTE_TABLEFUNC
      | 6 -> Ok RTE_VALUES
      | 7 -> Ok RTE_CTE
      | 8 -> Ok RTE_NAMEDTUPLESTORE
      | 9 -> Ok RTE_RESULT
      | n -> Error (`Unknown_enum_value n)
    
  end
  and WCOKind : sig
    type t = WCOKIND_UNDEFINED | WCO_VIEW_CHECK | WCO_RLS_INSERT_CHECK | WCO_RLS_UPDATE_CHECK | WCO_RLS_CONFLICT_CHECK | WCO_RLS_MERGE_UPDATE_CHECK | WCO_RLS_MERGE_DELETE_CHECK 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = WCOKIND_UNDEFINED | WCO_VIEW_CHECK | WCO_RLS_INSERT_CHECK | WCO_RLS_UPDATE_CHECK | WCO_RLS_CONFLICT_CHECK | WCO_RLS_MERGE_UPDATE_CHECK | WCO_RLS_MERGE_DELETE_CHECK 
    let to_int = function
      | WCOKIND_UNDEFINED -> 0
      | WCO_VIEW_CHECK -> 1
      | WCO_RLS_INSERT_CHECK -> 2
      | WCO_RLS_UPDATE_CHECK -> 3
      | WCO_RLS_CONFLICT_CHECK -> 4
      | WCO_RLS_MERGE_UPDATE_CHECK -> 5
      | WCO_RLS_MERGE_DELETE_CHECK -> 6
    
    let from_int = function
      | 0 -> Ok WCOKIND_UNDEFINED
      | 1 -> Ok WCO_VIEW_CHECK
      | 2 -> Ok WCO_RLS_INSERT_CHECK
      | 3 -> Ok WCO_RLS_UPDATE_CHECK
      | 4 -> Ok WCO_RLS_CONFLICT_CHECK
      | 5 -> Ok WCO_RLS_MERGE_UPDATE_CHECK
      | 6 -> Ok WCO_RLS_MERGE_DELETE_CHECK
      | n -> Error (`Unknown_enum_value n)
    
  end
  and GroupingSetKind : sig
    type t = GROUPING_SET_KIND_UNDEFINED | GROUPING_SET_EMPTY | GROUPING_SET_SIMPLE | GROUPING_SET_ROLLUP | GROUPING_SET_CUBE | GROUPING_SET_SETS 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = GROUPING_SET_KIND_UNDEFINED | GROUPING_SET_EMPTY | GROUPING_SET_SIMPLE | GROUPING_SET_ROLLUP | GROUPING_SET_CUBE | GROUPING_SET_SETS 
    let to_int = function
      | GROUPING_SET_KIND_UNDEFINED -> 0
      | GROUPING_SET_EMPTY -> 1
      | GROUPING_SET_SIMPLE -> 2
      | GROUPING_SET_ROLLUP -> 3
      | GROUPING_SET_CUBE -> 4
      | GROUPING_SET_SETS -> 5
    
    let from_int = function
      | 0 -> Ok GROUPING_SET_KIND_UNDEFINED
      | 1 -> Ok GROUPING_SET_EMPTY
      | 2 -> Ok GROUPING_SET_SIMPLE
      | 3 -> Ok GROUPING_SET_ROLLUP
      | 4 -> Ok GROUPING_SET_CUBE
      | 5 -> Ok GROUPING_SET_SETS
      | n -> Error (`Unknown_enum_value n)
    
  end
  and CTEMaterialize : sig
    type t = CTEMATERIALIZE_UNDEFINED | CTEMaterializeDefault | CTEMaterializeAlways | CTEMaterializeNever 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = CTEMATERIALIZE_UNDEFINED | CTEMaterializeDefault | CTEMaterializeAlways | CTEMaterializeNever 
    let to_int = function
      | CTEMATERIALIZE_UNDEFINED -> 0
      | CTEMaterializeDefault -> 1
      | CTEMaterializeAlways -> 2
      | CTEMaterializeNever -> 3
    
    let from_int = function
      | 0 -> Ok CTEMATERIALIZE_UNDEFINED
      | 1 -> Ok CTEMaterializeDefault
      | 2 -> Ok CTEMaterializeAlways
      | 3 -> Ok CTEMaterializeNever
      | n -> Error (`Unknown_enum_value n)
    
  end
  and SetOperation : sig
    type t = SET_OPERATION_UNDEFINED | SETOP_NONE | SETOP_UNION | SETOP_INTERSECT | SETOP_EXCEPT 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = SET_OPERATION_UNDEFINED | SETOP_NONE | SETOP_UNION | SETOP_INTERSECT | SETOP_EXCEPT 
    let to_int = function
      | SET_OPERATION_UNDEFINED -> 0
      | SETOP_NONE -> 1
      | SETOP_UNION -> 2
      | SETOP_INTERSECT -> 3
      | SETOP_EXCEPT -> 4
    
    let from_int = function
      | 0 -> Ok SET_OPERATION_UNDEFINED
      | 1 -> Ok SETOP_NONE
      | 2 -> Ok SETOP_UNION
      | 3 -> Ok SETOP_INTERSECT
      | 4 -> Ok SETOP_EXCEPT
      | n -> Error (`Unknown_enum_value n)
    
  end
  and ObjectType : sig
    type t = OBJECT_TYPE_UNDEFINED | OBJECT_ACCESS_METHOD | OBJECT_AGGREGATE | OBJECT_AMOP | OBJECT_AMPROC | OBJECT_ATTRIBUTE | OBJECT_CAST | OBJECT_COLUMN | OBJECT_COLLATION | OBJECT_CONVERSION | OBJECT_DATABASE | OBJECT_DEFAULT | OBJECT_DEFACL | OBJECT_DOMAIN | OBJECT_DOMCONSTRAINT | OBJECT_EVENT_TRIGGER | OBJECT_EXTENSION | OBJECT_FDW | OBJECT_FOREIGN_SERVER | OBJECT_FOREIGN_TABLE | OBJECT_FUNCTION | OBJECT_INDEX | OBJECT_LANGUAGE | OBJECT_LARGEOBJECT | OBJECT_MATVIEW | OBJECT_OPCLASS | OBJECT_OPERATOR | OBJECT_OPFAMILY | OBJECT_PARAMETER_ACL | OBJECT_POLICY | OBJECT_PROCEDURE | OBJECT_PUBLICATION | OBJECT_PUBLICATION_NAMESPACE | OBJECT_PUBLICATION_REL | OBJECT_ROLE | OBJECT_ROUTINE | OBJECT_RULE | OBJECT_SCHEMA | OBJECT_SEQUENCE | OBJECT_SUBSCRIPTION | OBJECT_STATISTIC_EXT | OBJECT_TABCONSTRAINT | OBJECT_TABLE | OBJECT_TABLESPACE | OBJECT_TRANSFORM | OBJECT_TRIGGER | OBJECT_TSCONFIGURATION | OBJECT_TSDICTIONARY | OBJECT_TSPARSER | OBJECT_TSTEMPLATE | OBJECT_TYPE | OBJECT_USER_MAPPING | OBJECT_VIEW 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = OBJECT_TYPE_UNDEFINED | OBJECT_ACCESS_METHOD | OBJECT_AGGREGATE | OBJECT_AMOP | OBJECT_AMPROC | OBJECT_ATTRIBUTE | OBJECT_CAST | OBJECT_COLUMN | OBJECT_COLLATION | OBJECT_CONVERSION | OBJECT_DATABASE | OBJECT_DEFAULT | OBJECT_DEFACL | OBJECT_DOMAIN | OBJECT_DOMCONSTRAINT | OBJECT_EVENT_TRIGGER | OBJECT_EXTENSION | OBJECT_FDW | OBJECT_FOREIGN_SERVER | OBJECT_FOREIGN_TABLE | OBJECT_FUNCTION | OBJECT_INDEX | OBJECT_LANGUAGE | OBJECT_LARGEOBJECT | OBJECT_MATVIEW | OBJECT_OPCLASS | OBJECT_OPERATOR | OBJECT_OPFAMILY | OBJECT_PARAMETER_ACL | OBJECT_POLICY | OBJECT_PROCEDURE | OBJECT_PUBLICATION | OBJECT_PUBLICATION_NAMESPACE | OBJECT_PUBLICATION_REL | OBJECT_ROLE | OBJECT_ROUTINE | OBJECT_RULE | OBJECT_SCHEMA | OBJECT_SEQUENCE | OBJECT_SUBSCRIPTION | OBJECT_STATISTIC_EXT | OBJECT_TABCONSTRAINT | OBJECT_TABLE | OBJECT_TABLESPACE | OBJECT_TRANSFORM | OBJECT_TRIGGER | OBJECT_TSCONFIGURATION | OBJECT_TSDICTIONARY | OBJECT_TSPARSER | OBJECT_TSTEMPLATE | OBJECT_TYPE | OBJECT_USER_MAPPING | OBJECT_VIEW 
    let to_int = function
      | OBJECT_TYPE_UNDEFINED -> 0
      | OBJECT_ACCESS_METHOD -> 1
      | OBJECT_AGGREGATE -> 2
      | OBJECT_AMOP -> 3
      | OBJECT_AMPROC -> 4
      | OBJECT_ATTRIBUTE -> 5
      | OBJECT_CAST -> 6
      | OBJECT_COLUMN -> 7
      | OBJECT_COLLATION -> 8
      | OBJECT_CONVERSION -> 9
      | OBJECT_DATABASE -> 10
      | OBJECT_DEFAULT -> 11
      | OBJECT_DEFACL -> 12
      | OBJECT_DOMAIN -> 13
      | OBJECT_DOMCONSTRAINT -> 14
      | OBJECT_EVENT_TRIGGER -> 15
      | OBJECT_EXTENSION -> 16
      | OBJECT_FDW -> 17
      | OBJECT_FOREIGN_SERVER -> 18
      | OBJECT_FOREIGN_TABLE -> 19
      | OBJECT_FUNCTION -> 20
      | OBJECT_INDEX -> 21
      | OBJECT_LANGUAGE -> 22
      | OBJECT_LARGEOBJECT -> 23
      | OBJECT_MATVIEW -> 24
      | OBJECT_OPCLASS -> 25
      | OBJECT_OPERATOR -> 26
      | OBJECT_OPFAMILY -> 27
      | OBJECT_PARAMETER_ACL -> 28
      | OBJECT_POLICY -> 29
      | OBJECT_PROCEDURE -> 30
      | OBJECT_PUBLICATION -> 31
      | OBJECT_PUBLICATION_NAMESPACE -> 32
      | OBJECT_PUBLICATION_REL -> 33
      | OBJECT_ROLE -> 34
      | OBJECT_ROUTINE -> 35
      | OBJECT_RULE -> 36
      | OBJECT_SCHEMA -> 37
      | OBJECT_SEQUENCE -> 38
      | OBJECT_SUBSCRIPTION -> 39
      | OBJECT_STATISTIC_EXT -> 40
      | OBJECT_TABCONSTRAINT -> 41
      | OBJECT_TABLE -> 42
      | OBJECT_TABLESPACE -> 43
      | OBJECT_TRANSFORM -> 44
      | OBJECT_TRIGGER -> 45
      | OBJECT_TSCONFIGURATION -> 46
      | OBJECT_TSDICTIONARY -> 47
      | OBJECT_TSPARSER -> 48
      | OBJECT_TSTEMPLATE -> 49
      | OBJECT_TYPE -> 50
      | OBJECT_USER_MAPPING -> 51
      | OBJECT_VIEW -> 52
    
    let from_int = function
      | 0 -> Ok OBJECT_TYPE_UNDEFINED
      | 1 -> Ok OBJECT_ACCESS_METHOD
      | 2 -> Ok OBJECT_AGGREGATE
      | 3 -> Ok OBJECT_AMOP
      | 4 -> Ok OBJECT_AMPROC
      | 5 -> Ok OBJECT_ATTRIBUTE
      | 6 -> Ok OBJECT_CAST
      | 7 -> Ok OBJECT_COLUMN
      | 8 -> Ok OBJECT_COLLATION
      | 9 -> Ok OBJECT_CONVERSION
      | 10 -> Ok OBJECT_DATABASE
      | 11 -> Ok OBJECT_DEFAULT
      | 12 -> Ok OBJECT_DEFACL
      | 13 -> Ok OBJECT_DOMAIN
      | 14 -> Ok OBJECT_DOMCONSTRAINT
      | 15 -> Ok OBJECT_EVENT_TRIGGER
      | 16 -> Ok OBJECT_EXTENSION
      | 17 -> Ok OBJECT_FDW
      | 18 -> Ok OBJECT_FOREIGN_SERVER
      | 19 -> Ok OBJECT_FOREIGN_TABLE
      | 20 -> Ok OBJECT_FUNCTION
      | 21 -> Ok OBJECT_INDEX
      | 22 -> Ok OBJECT_LANGUAGE
      | 23 -> Ok OBJECT_LARGEOBJECT
      | 24 -> Ok OBJECT_MATVIEW
      | 25 -> Ok OBJECT_OPCLASS
      | 26 -> Ok OBJECT_OPERATOR
      | 27 -> Ok OBJECT_OPFAMILY
      | 28 -> Ok OBJECT_PARAMETER_ACL
      | 29 -> Ok OBJECT_POLICY
      | 30 -> Ok OBJECT_PROCEDURE
      | 31 -> Ok OBJECT_PUBLICATION
      | 32 -> Ok OBJECT_PUBLICATION_NAMESPACE
      | 33 -> Ok OBJECT_PUBLICATION_REL
      | 34 -> Ok OBJECT_ROLE
      | 35 -> Ok OBJECT_ROUTINE
      | 36 -> Ok OBJECT_RULE
      | 37 -> Ok OBJECT_SCHEMA
      | 38 -> Ok OBJECT_SEQUENCE
      | 39 -> Ok OBJECT_SUBSCRIPTION
      | 40 -> Ok OBJECT_STATISTIC_EXT
      | 41 -> Ok OBJECT_TABCONSTRAINT
      | 42 -> Ok OBJECT_TABLE
      | 43 -> Ok OBJECT_TABLESPACE
      | 44 -> Ok OBJECT_TRANSFORM
      | 45 -> Ok OBJECT_TRIGGER
      | 46 -> Ok OBJECT_TSCONFIGURATION
      | 47 -> Ok OBJECT_TSDICTIONARY
      | 48 -> Ok OBJECT_TSPARSER
      | 49 -> Ok OBJECT_TSTEMPLATE
      | 50 -> Ok OBJECT_TYPE
      | 51 -> Ok OBJECT_USER_MAPPING
      | 52 -> Ok OBJECT_VIEW
      | n -> Error (`Unknown_enum_value n)
    
  end
  and DropBehavior : sig
    type t = DROP_BEHAVIOR_UNDEFINED | DROP_RESTRICT | DROP_CASCADE 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = DROP_BEHAVIOR_UNDEFINED | DROP_RESTRICT | DROP_CASCADE 
    let to_int = function
      | DROP_BEHAVIOR_UNDEFINED -> 0
      | DROP_RESTRICT -> 1
      | DROP_CASCADE -> 2
    
    let from_int = function
      | 0 -> Ok DROP_BEHAVIOR_UNDEFINED
      | 1 -> Ok DROP_RESTRICT
      | 2 -> Ok DROP_CASCADE
      | n -> Error (`Unknown_enum_value n)
    
  end
  and AlterTableType : sig
    type t = ALTER_TABLE_TYPE_UNDEFINED | AT_AddColumn | AT_AddColumnRecurse | AT_AddColumnToView | AT_ColumnDefault | AT_CookedColumnDefault | AT_DropNotNull | AT_SetNotNull | AT_DropExpression | AT_CheckNotNull | AT_SetStatistics | AT_SetOptions | AT_ResetOptions | AT_SetStorage | AT_SetCompression | AT_DropColumn | AT_DropColumnRecurse | AT_AddIndex | AT_ReAddIndex | AT_AddConstraint | AT_AddConstraintRecurse | AT_ReAddConstraint | AT_ReAddDomainConstraint | AT_AlterConstraint | AT_ValidateConstraint | AT_ValidateConstraintRecurse | AT_AddIndexConstraint | AT_DropConstraint | AT_DropConstraintRecurse | AT_ReAddComment | AT_AlterColumnType | AT_AlterColumnGenericOptions | AT_ChangeOwner | AT_ClusterOn | AT_DropCluster | AT_SetLogged | AT_SetUnLogged | AT_DropOids | AT_SetAccessMethod | AT_SetTableSpace | AT_SetRelOptions | AT_ResetRelOptions | AT_ReplaceRelOptions | AT_EnableTrig | AT_EnableAlwaysTrig | AT_EnableReplicaTrig | AT_DisableTrig | AT_EnableTrigAll | AT_DisableTrigAll | AT_EnableTrigUser | AT_DisableTrigUser | AT_EnableRule | AT_EnableAlwaysRule | AT_EnableReplicaRule | AT_DisableRule | AT_AddInherit | AT_DropInherit | AT_AddOf | AT_DropOf | AT_ReplicaIdentity | AT_EnableRowSecurity | AT_DisableRowSecurity | AT_ForceRowSecurity | AT_NoForceRowSecurity | AT_GenericOptions | AT_AttachPartition | AT_DetachPartition | AT_DetachPartitionFinalize | AT_AddIdentity | AT_SetIdentity | AT_DropIdentity | AT_ReAddStatistics 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = ALTER_TABLE_TYPE_UNDEFINED | AT_AddColumn | AT_AddColumnRecurse | AT_AddColumnToView | AT_ColumnDefault | AT_CookedColumnDefault | AT_DropNotNull | AT_SetNotNull | AT_DropExpression | AT_CheckNotNull | AT_SetStatistics | AT_SetOptions | AT_ResetOptions | AT_SetStorage | AT_SetCompression | AT_DropColumn | AT_DropColumnRecurse | AT_AddIndex | AT_ReAddIndex | AT_AddConstraint | AT_AddConstraintRecurse | AT_ReAddConstraint | AT_ReAddDomainConstraint | AT_AlterConstraint | AT_ValidateConstraint | AT_ValidateConstraintRecurse | AT_AddIndexConstraint | AT_DropConstraint | AT_DropConstraintRecurse | AT_ReAddComment | AT_AlterColumnType | AT_AlterColumnGenericOptions | AT_ChangeOwner | AT_ClusterOn | AT_DropCluster | AT_SetLogged | AT_SetUnLogged | AT_DropOids | AT_SetAccessMethod | AT_SetTableSpace | AT_SetRelOptions | AT_ResetRelOptions | AT_ReplaceRelOptions | AT_EnableTrig | AT_EnableAlwaysTrig | AT_EnableReplicaTrig | AT_DisableTrig | AT_EnableTrigAll | AT_DisableTrigAll | AT_EnableTrigUser | AT_DisableTrigUser | AT_EnableRule | AT_EnableAlwaysRule | AT_EnableReplicaRule | AT_DisableRule | AT_AddInherit | AT_DropInherit | AT_AddOf | AT_DropOf | AT_ReplicaIdentity | AT_EnableRowSecurity | AT_DisableRowSecurity | AT_ForceRowSecurity | AT_NoForceRowSecurity | AT_GenericOptions | AT_AttachPartition | AT_DetachPartition | AT_DetachPartitionFinalize | AT_AddIdentity | AT_SetIdentity | AT_DropIdentity | AT_ReAddStatistics 
    let to_int = function
      | ALTER_TABLE_TYPE_UNDEFINED -> 0
      | AT_AddColumn -> 1
      | AT_AddColumnRecurse -> 2
      | AT_AddColumnToView -> 3
      | AT_ColumnDefault -> 4
      | AT_CookedColumnDefault -> 5
      | AT_DropNotNull -> 6
      | AT_SetNotNull -> 7
      | AT_DropExpression -> 8
      | AT_CheckNotNull -> 9
      | AT_SetStatistics -> 10
      | AT_SetOptions -> 11
      | AT_ResetOptions -> 12
      | AT_SetStorage -> 13
      | AT_SetCompression -> 14
      | AT_DropColumn -> 15
      | AT_DropColumnRecurse -> 16
      | AT_AddIndex -> 17
      | AT_ReAddIndex -> 18
      | AT_AddConstraint -> 19
      | AT_AddConstraintRecurse -> 20
      | AT_ReAddConstraint -> 21
      | AT_ReAddDomainConstraint -> 22
      | AT_AlterConstraint -> 23
      | AT_ValidateConstraint -> 24
      | AT_ValidateConstraintRecurse -> 25
      | AT_AddIndexConstraint -> 26
      | AT_DropConstraint -> 27
      | AT_DropConstraintRecurse -> 28
      | AT_ReAddComment -> 29
      | AT_AlterColumnType -> 30
      | AT_AlterColumnGenericOptions -> 31
      | AT_ChangeOwner -> 32
      | AT_ClusterOn -> 33
      | AT_DropCluster -> 34
      | AT_SetLogged -> 35
      | AT_SetUnLogged -> 36
      | AT_DropOids -> 37
      | AT_SetAccessMethod -> 38
      | AT_SetTableSpace -> 39
      | AT_SetRelOptions -> 40
      | AT_ResetRelOptions -> 41
      | AT_ReplaceRelOptions -> 42
      | AT_EnableTrig -> 43
      | AT_EnableAlwaysTrig -> 44
      | AT_EnableReplicaTrig -> 45
      | AT_DisableTrig -> 46
      | AT_EnableTrigAll -> 47
      | AT_DisableTrigAll -> 48
      | AT_EnableTrigUser -> 49
      | AT_DisableTrigUser -> 50
      | AT_EnableRule -> 51
      | AT_EnableAlwaysRule -> 52
      | AT_EnableReplicaRule -> 53
      | AT_DisableRule -> 54
      | AT_AddInherit -> 55
      | AT_DropInherit -> 56
      | AT_AddOf -> 57
      | AT_DropOf -> 58
      | AT_ReplicaIdentity -> 59
      | AT_EnableRowSecurity -> 60
      | AT_DisableRowSecurity -> 61
      | AT_ForceRowSecurity -> 62
      | AT_NoForceRowSecurity -> 63
      | AT_GenericOptions -> 64
      | AT_AttachPartition -> 65
      | AT_DetachPartition -> 66
      | AT_DetachPartitionFinalize -> 67
      | AT_AddIdentity -> 68
      | AT_SetIdentity -> 69
      | AT_DropIdentity -> 70
      | AT_ReAddStatistics -> 71
    
    let from_int = function
      | 0 -> Ok ALTER_TABLE_TYPE_UNDEFINED
      | 1 -> Ok AT_AddColumn
      | 2 -> Ok AT_AddColumnRecurse
      | 3 -> Ok AT_AddColumnToView
      | 4 -> Ok AT_ColumnDefault
      | 5 -> Ok AT_CookedColumnDefault
      | 6 -> Ok AT_DropNotNull
      | 7 -> Ok AT_SetNotNull
      | 8 -> Ok AT_DropExpression
      | 9 -> Ok AT_CheckNotNull
      | 10 -> Ok AT_SetStatistics
      | 11 -> Ok AT_SetOptions
      | 12 -> Ok AT_ResetOptions
      | 13 -> Ok AT_SetStorage
      | 14 -> Ok AT_SetCompression
      | 15 -> Ok AT_DropColumn
      | 16 -> Ok AT_DropColumnRecurse
      | 17 -> Ok AT_AddIndex
      | 18 -> Ok AT_ReAddIndex
      | 19 -> Ok AT_AddConstraint
      | 20 -> Ok AT_AddConstraintRecurse
      | 21 -> Ok AT_ReAddConstraint
      | 22 -> Ok AT_ReAddDomainConstraint
      | 23 -> Ok AT_AlterConstraint
      | 24 -> Ok AT_ValidateConstraint
      | 25 -> Ok AT_ValidateConstraintRecurse
      | 26 -> Ok AT_AddIndexConstraint
      | 27 -> Ok AT_DropConstraint
      | 28 -> Ok AT_DropConstraintRecurse
      | 29 -> Ok AT_ReAddComment
      | 30 -> Ok AT_AlterColumnType
      | 31 -> Ok AT_AlterColumnGenericOptions
      | 32 -> Ok AT_ChangeOwner
      | 33 -> Ok AT_ClusterOn
      | 34 -> Ok AT_DropCluster
      | 35 -> Ok AT_SetLogged
      | 36 -> Ok AT_SetUnLogged
      | 37 -> Ok AT_DropOids
      | 38 -> Ok AT_SetAccessMethod
      | 39 -> Ok AT_SetTableSpace
      | 40 -> Ok AT_SetRelOptions
      | 41 -> Ok AT_ResetRelOptions
      | 42 -> Ok AT_ReplaceRelOptions
      | 43 -> Ok AT_EnableTrig
      | 44 -> Ok AT_EnableAlwaysTrig
      | 45 -> Ok AT_EnableReplicaTrig
      | 46 -> Ok AT_DisableTrig
      | 47 -> Ok AT_EnableTrigAll
      | 48 -> Ok AT_DisableTrigAll
      | 49 -> Ok AT_EnableTrigUser
      | 50 -> Ok AT_DisableTrigUser
      | 51 -> Ok AT_EnableRule
      | 52 -> Ok AT_EnableAlwaysRule
      | 53 -> Ok AT_EnableReplicaRule
      | 54 -> Ok AT_DisableRule
      | 55 -> Ok AT_AddInherit
      | 56 -> Ok AT_DropInherit
      | 57 -> Ok AT_AddOf
      | 58 -> Ok AT_DropOf
      | 59 -> Ok AT_ReplicaIdentity
      | 60 -> Ok AT_EnableRowSecurity
      | 61 -> Ok AT_DisableRowSecurity
      | 62 -> Ok AT_ForceRowSecurity
      | 63 -> Ok AT_NoForceRowSecurity
      | 64 -> Ok AT_GenericOptions
      | 65 -> Ok AT_AttachPartition
      | 66 -> Ok AT_DetachPartition
      | 67 -> Ok AT_DetachPartitionFinalize
      | 68 -> Ok AT_AddIdentity
      | 69 -> Ok AT_SetIdentity
      | 70 -> Ok AT_DropIdentity
      | 71 -> Ok AT_ReAddStatistics
      | n -> Error (`Unknown_enum_value n)
    
  end
  and GrantTargetType : sig
    type t = GRANT_TARGET_TYPE_UNDEFINED | ACL_TARGET_OBJECT | ACL_TARGET_ALL_IN_SCHEMA | ACL_TARGET_DEFAULTS 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = GRANT_TARGET_TYPE_UNDEFINED | ACL_TARGET_OBJECT | ACL_TARGET_ALL_IN_SCHEMA | ACL_TARGET_DEFAULTS 
    let to_int = function
      | GRANT_TARGET_TYPE_UNDEFINED -> 0
      | ACL_TARGET_OBJECT -> 1
      | ACL_TARGET_ALL_IN_SCHEMA -> 2
      | ACL_TARGET_DEFAULTS -> 3
    
    let from_int = function
      | 0 -> Ok GRANT_TARGET_TYPE_UNDEFINED
      | 1 -> Ok ACL_TARGET_OBJECT
      | 2 -> Ok ACL_TARGET_ALL_IN_SCHEMA
      | 3 -> Ok ACL_TARGET_DEFAULTS
      | n -> Error (`Unknown_enum_value n)
    
  end
  and VariableSetKind : sig
    type t = VARIABLE_SET_KIND_UNDEFINED | VAR_SET_VALUE | VAR_SET_DEFAULT | VAR_SET_CURRENT | VAR_SET_MULTI | VAR_RESET | VAR_RESET_ALL 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = VARIABLE_SET_KIND_UNDEFINED | VAR_SET_VALUE | VAR_SET_DEFAULT | VAR_SET_CURRENT | VAR_SET_MULTI | VAR_RESET | VAR_RESET_ALL 
    let to_int = function
      | VARIABLE_SET_KIND_UNDEFINED -> 0
      | VAR_SET_VALUE -> 1
      | VAR_SET_DEFAULT -> 2
      | VAR_SET_CURRENT -> 3
      | VAR_SET_MULTI -> 4
      | VAR_RESET -> 5
      | VAR_RESET_ALL -> 6
    
    let from_int = function
      | 0 -> Ok VARIABLE_SET_KIND_UNDEFINED
      | 1 -> Ok VAR_SET_VALUE
      | 2 -> Ok VAR_SET_DEFAULT
      | 3 -> Ok VAR_SET_CURRENT
      | 4 -> Ok VAR_SET_MULTI
      | 5 -> Ok VAR_RESET
      | 6 -> Ok VAR_RESET_ALL
      | n -> Error (`Unknown_enum_value n)
    
  end
  and ConstrType : sig
    type t = CONSTR_TYPE_UNDEFINED | CONSTR_NULL | CONSTR_NOTNULL | CONSTR_DEFAULT | CONSTR_IDENTITY | CONSTR_GENERATED | CONSTR_CHECK | CONSTR_PRIMARY | CONSTR_UNIQUE | CONSTR_EXCLUSION | CONSTR_FOREIGN | CONSTR_ATTR_DEFERRABLE | CONSTR_ATTR_NOT_DEFERRABLE | CONSTR_ATTR_DEFERRED | CONSTR_ATTR_IMMEDIATE 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = CONSTR_TYPE_UNDEFINED | CONSTR_NULL | CONSTR_NOTNULL | CONSTR_DEFAULT | CONSTR_IDENTITY | CONSTR_GENERATED | CONSTR_CHECK | CONSTR_PRIMARY | CONSTR_UNIQUE | CONSTR_EXCLUSION | CONSTR_FOREIGN | CONSTR_ATTR_DEFERRABLE | CONSTR_ATTR_NOT_DEFERRABLE | CONSTR_ATTR_DEFERRED | CONSTR_ATTR_IMMEDIATE 
    let to_int = function
      | CONSTR_TYPE_UNDEFINED -> 0
      | CONSTR_NULL -> 1
      | CONSTR_NOTNULL -> 2
      | CONSTR_DEFAULT -> 3
      | CONSTR_IDENTITY -> 4
      | CONSTR_GENERATED -> 5
      | CONSTR_CHECK -> 6
      | CONSTR_PRIMARY -> 7
      | CONSTR_UNIQUE -> 8
      | CONSTR_EXCLUSION -> 9
      | CONSTR_FOREIGN -> 10
      | CONSTR_ATTR_DEFERRABLE -> 11
      | CONSTR_ATTR_NOT_DEFERRABLE -> 12
      | CONSTR_ATTR_DEFERRED -> 13
      | CONSTR_ATTR_IMMEDIATE -> 14
    
    let from_int = function
      | 0 -> Ok CONSTR_TYPE_UNDEFINED
      | 1 -> Ok CONSTR_NULL
      | 2 -> Ok CONSTR_NOTNULL
      | 3 -> Ok CONSTR_DEFAULT
      | 4 -> Ok CONSTR_IDENTITY
      | 5 -> Ok CONSTR_GENERATED
      | 6 -> Ok CONSTR_CHECK
      | 7 -> Ok CONSTR_PRIMARY
      | 8 -> Ok CONSTR_UNIQUE
      | 9 -> Ok CONSTR_EXCLUSION
      | 10 -> Ok CONSTR_FOREIGN
      | 11 -> Ok CONSTR_ATTR_DEFERRABLE
      | 12 -> Ok CONSTR_ATTR_NOT_DEFERRABLE
      | 13 -> Ok CONSTR_ATTR_DEFERRED
      | 14 -> Ok CONSTR_ATTR_IMMEDIATE
      | n -> Error (`Unknown_enum_value n)
    
  end
  and ImportForeignSchemaType : sig
    type t = IMPORT_FOREIGN_SCHEMA_TYPE_UNDEFINED | FDW_IMPORT_SCHEMA_ALL | FDW_IMPORT_SCHEMA_LIMIT_TO | FDW_IMPORT_SCHEMA_EXCEPT 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = IMPORT_FOREIGN_SCHEMA_TYPE_UNDEFINED | FDW_IMPORT_SCHEMA_ALL | FDW_IMPORT_SCHEMA_LIMIT_TO | FDW_IMPORT_SCHEMA_EXCEPT 
    let to_int = function
      | IMPORT_FOREIGN_SCHEMA_TYPE_UNDEFINED -> 0
      | FDW_IMPORT_SCHEMA_ALL -> 1
      | FDW_IMPORT_SCHEMA_LIMIT_TO -> 2
      | FDW_IMPORT_SCHEMA_EXCEPT -> 3
    
    let from_int = function
      | 0 -> Ok IMPORT_FOREIGN_SCHEMA_TYPE_UNDEFINED
      | 1 -> Ok FDW_IMPORT_SCHEMA_ALL
      | 2 -> Ok FDW_IMPORT_SCHEMA_LIMIT_TO
      | 3 -> Ok FDW_IMPORT_SCHEMA_EXCEPT
      | n -> Error (`Unknown_enum_value n)
    
  end
  and RoleStmtType : sig
    type t = ROLE_STMT_TYPE_UNDEFINED | ROLESTMT_ROLE | ROLESTMT_USER | ROLESTMT_GROUP 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = ROLE_STMT_TYPE_UNDEFINED | ROLESTMT_ROLE | ROLESTMT_USER | ROLESTMT_GROUP 
    let to_int = function
      | ROLE_STMT_TYPE_UNDEFINED -> 0
      | ROLESTMT_ROLE -> 1
      | ROLESTMT_USER -> 2
      | ROLESTMT_GROUP -> 3
    
    let from_int = function
      | 0 -> Ok ROLE_STMT_TYPE_UNDEFINED
      | 1 -> Ok ROLESTMT_ROLE
      | 2 -> Ok ROLESTMT_USER
      | 3 -> Ok ROLESTMT_GROUP
      | n -> Error (`Unknown_enum_value n)
    
  end
  and FetchDirection : sig
    type t = FETCH_DIRECTION_UNDEFINED | FETCH_FORWARD | FETCH_BACKWARD | FETCH_ABSOLUTE | FETCH_RELATIVE 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = FETCH_DIRECTION_UNDEFINED | FETCH_FORWARD | FETCH_BACKWARD | FETCH_ABSOLUTE | FETCH_RELATIVE 
    let to_int = function
      | FETCH_DIRECTION_UNDEFINED -> 0
      | FETCH_FORWARD -> 1
      | FETCH_BACKWARD -> 2
      | FETCH_ABSOLUTE -> 3
      | FETCH_RELATIVE -> 4
    
    let from_int = function
      | 0 -> Ok FETCH_DIRECTION_UNDEFINED
      | 1 -> Ok FETCH_FORWARD
      | 2 -> Ok FETCH_BACKWARD
      | 3 -> Ok FETCH_ABSOLUTE
      | 4 -> Ok FETCH_RELATIVE
      | n -> Error (`Unknown_enum_value n)
    
  end
  and FunctionParameterMode : sig
    type t = FUNCTION_PARAMETER_MODE_UNDEFINED | FUNC_PARAM_IN | FUNC_PARAM_OUT | FUNC_PARAM_INOUT | FUNC_PARAM_VARIADIC | FUNC_PARAM_TABLE | FUNC_PARAM_DEFAULT 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = FUNCTION_PARAMETER_MODE_UNDEFINED | FUNC_PARAM_IN | FUNC_PARAM_OUT | FUNC_PARAM_INOUT | FUNC_PARAM_VARIADIC | FUNC_PARAM_TABLE | FUNC_PARAM_DEFAULT 
    let to_int = function
      | FUNCTION_PARAMETER_MODE_UNDEFINED -> 0
      | FUNC_PARAM_IN -> 1
      | FUNC_PARAM_OUT -> 2
      | FUNC_PARAM_INOUT -> 3
      | FUNC_PARAM_VARIADIC -> 4
      | FUNC_PARAM_TABLE -> 5
      | FUNC_PARAM_DEFAULT -> 6
    
    let from_int = function
      | 0 -> Ok FUNCTION_PARAMETER_MODE_UNDEFINED
      | 1 -> Ok FUNC_PARAM_IN
      | 2 -> Ok FUNC_PARAM_OUT
      | 3 -> Ok FUNC_PARAM_INOUT
      | 4 -> Ok FUNC_PARAM_VARIADIC
      | 5 -> Ok FUNC_PARAM_TABLE
      | 6 -> Ok FUNC_PARAM_DEFAULT
      | n -> Error (`Unknown_enum_value n)
    
  end
  and TransactionStmtKind : sig
    type t = TRANSACTION_STMT_KIND_UNDEFINED | TRANS_STMT_BEGIN | TRANS_STMT_START | TRANS_STMT_COMMIT | TRANS_STMT_ROLLBACK | TRANS_STMT_SAVEPOINT | TRANS_STMT_RELEASE | TRANS_STMT_ROLLBACK_TO | TRANS_STMT_PREPARE | TRANS_STMT_COMMIT_PREPARED | TRANS_STMT_ROLLBACK_PREPARED 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = TRANSACTION_STMT_KIND_UNDEFINED | TRANS_STMT_BEGIN | TRANS_STMT_START | TRANS_STMT_COMMIT | TRANS_STMT_ROLLBACK | TRANS_STMT_SAVEPOINT | TRANS_STMT_RELEASE | TRANS_STMT_ROLLBACK_TO | TRANS_STMT_PREPARE | TRANS_STMT_COMMIT_PREPARED | TRANS_STMT_ROLLBACK_PREPARED 
    let to_int = function
      | TRANSACTION_STMT_KIND_UNDEFINED -> 0
      | TRANS_STMT_BEGIN -> 1
      | TRANS_STMT_START -> 2
      | TRANS_STMT_COMMIT -> 3
      | TRANS_STMT_ROLLBACK -> 4
      | TRANS_STMT_SAVEPOINT -> 5
      | TRANS_STMT_RELEASE -> 6
      | TRANS_STMT_ROLLBACK_TO -> 7
      | TRANS_STMT_PREPARE -> 8
      | TRANS_STMT_COMMIT_PREPARED -> 9
      | TRANS_STMT_ROLLBACK_PREPARED -> 10
    
    let from_int = function
      | 0 -> Ok TRANSACTION_STMT_KIND_UNDEFINED
      | 1 -> Ok TRANS_STMT_BEGIN
      | 2 -> Ok TRANS_STMT_START
      | 3 -> Ok TRANS_STMT_COMMIT
      | 4 -> Ok TRANS_STMT_ROLLBACK
      | 5 -> Ok TRANS_STMT_SAVEPOINT
      | 6 -> Ok TRANS_STMT_RELEASE
      | 7 -> Ok TRANS_STMT_ROLLBACK_TO
      | 8 -> Ok TRANS_STMT_PREPARE
      | 9 -> Ok TRANS_STMT_COMMIT_PREPARED
      | 10 -> Ok TRANS_STMT_ROLLBACK_PREPARED
      | n -> Error (`Unknown_enum_value n)
    
  end
  and ViewCheckOption : sig
    type t = VIEW_CHECK_OPTION_UNDEFINED | NO_CHECK_OPTION | LOCAL_CHECK_OPTION | CASCADED_CHECK_OPTION 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = VIEW_CHECK_OPTION_UNDEFINED | NO_CHECK_OPTION | LOCAL_CHECK_OPTION | CASCADED_CHECK_OPTION 
    let to_int = function
      | VIEW_CHECK_OPTION_UNDEFINED -> 0
      | NO_CHECK_OPTION -> 1
      | LOCAL_CHECK_OPTION -> 2
      | CASCADED_CHECK_OPTION -> 3
    
    let from_int = function
      | 0 -> Ok VIEW_CHECK_OPTION_UNDEFINED
      | 1 -> Ok NO_CHECK_OPTION
      | 2 -> Ok LOCAL_CHECK_OPTION
      | 3 -> Ok CASCADED_CHECK_OPTION
      | n -> Error (`Unknown_enum_value n)
    
  end
  and DiscardMode : sig
    type t = DISCARD_MODE_UNDEFINED | DISCARD_ALL | DISCARD_PLANS | DISCARD_SEQUENCES | DISCARD_TEMP 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = DISCARD_MODE_UNDEFINED | DISCARD_ALL | DISCARD_PLANS | DISCARD_SEQUENCES | DISCARD_TEMP 
    let to_int = function
      | DISCARD_MODE_UNDEFINED -> 0
      | DISCARD_ALL -> 1
      | DISCARD_PLANS -> 2
      | DISCARD_SEQUENCES -> 3
      | DISCARD_TEMP -> 4
    
    let from_int = function
      | 0 -> Ok DISCARD_MODE_UNDEFINED
      | 1 -> Ok DISCARD_ALL
      | 2 -> Ok DISCARD_PLANS
      | 3 -> Ok DISCARD_SEQUENCES
      | 4 -> Ok DISCARD_TEMP
      | n -> Error (`Unknown_enum_value n)
    
  end
  and ReindexObjectType : sig
    type t = REINDEX_OBJECT_TYPE_UNDEFINED | REINDEX_OBJECT_INDEX | REINDEX_OBJECT_TABLE | REINDEX_OBJECT_SCHEMA | REINDEX_OBJECT_SYSTEM | REINDEX_OBJECT_DATABASE 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = REINDEX_OBJECT_TYPE_UNDEFINED | REINDEX_OBJECT_INDEX | REINDEX_OBJECT_TABLE | REINDEX_OBJECT_SCHEMA | REINDEX_OBJECT_SYSTEM | REINDEX_OBJECT_DATABASE 
    let to_int = function
      | REINDEX_OBJECT_TYPE_UNDEFINED -> 0
      | REINDEX_OBJECT_INDEX -> 1
      | REINDEX_OBJECT_TABLE -> 2
      | REINDEX_OBJECT_SCHEMA -> 3
      | REINDEX_OBJECT_SYSTEM -> 4
      | REINDEX_OBJECT_DATABASE -> 5
    
    let from_int = function
      | 0 -> Ok REINDEX_OBJECT_TYPE_UNDEFINED
      | 1 -> Ok REINDEX_OBJECT_INDEX
      | 2 -> Ok REINDEX_OBJECT_TABLE
      | 3 -> Ok REINDEX_OBJECT_SCHEMA
      | 4 -> Ok REINDEX_OBJECT_SYSTEM
      | 5 -> Ok REINDEX_OBJECT_DATABASE
      | n -> Error (`Unknown_enum_value n)
    
  end
  and AlterTSConfigType : sig
    type t = ALTER_TSCONFIG_TYPE_UNDEFINED | ALTER_TSCONFIG_ADD_MAPPING | ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN | ALTER_TSCONFIG_REPLACE_DICT | ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN | ALTER_TSCONFIG_DROP_MAPPING 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = ALTER_TSCONFIG_TYPE_UNDEFINED | ALTER_TSCONFIG_ADD_MAPPING | ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN | ALTER_TSCONFIG_REPLACE_DICT | ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN | ALTER_TSCONFIG_DROP_MAPPING 
    let to_int = function
      | ALTER_TSCONFIG_TYPE_UNDEFINED -> 0
      | ALTER_TSCONFIG_ADD_MAPPING -> 1
      | ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN -> 2
      | ALTER_TSCONFIG_REPLACE_DICT -> 3
      | ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN -> 4
      | ALTER_TSCONFIG_DROP_MAPPING -> 5
    
    let from_int = function
      | 0 -> Ok ALTER_TSCONFIG_TYPE_UNDEFINED
      | 1 -> Ok ALTER_TSCONFIG_ADD_MAPPING
      | 2 -> Ok ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN
      | 3 -> Ok ALTER_TSCONFIG_REPLACE_DICT
      | 4 -> Ok ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN
      | 5 -> Ok ALTER_TSCONFIG_DROP_MAPPING
      | n -> Error (`Unknown_enum_value n)
    
  end
  and PublicationObjSpecType : sig
    type t = PUBLICATION_OBJ_SPEC_TYPE_UNDEFINED | PUBLICATIONOBJ_TABLE | PUBLICATIONOBJ_TABLES_IN_SCHEMA | PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA | PUBLICATIONOBJ_CONTINUATION 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = PUBLICATION_OBJ_SPEC_TYPE_UNDEFINED | PUBLICATIONOBJ_TABLE | PUBLICATIONOBJ_TABLES_IN_SCHEMA | PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA | PUBLICATIONOBJ_CONTINUATION 
    let to_int = function
      | PUBLICATION_OBJ_SPEC_TYPE_UNDEFINED -> 0
      | PUBLICATIONOBJ_TABLE -> 1
      | PUBLICATIONOBJ_TABLES_IN_SCHEMA -> 2
      | PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA -> 3
      | PUBLICATIONOBJ_CONTINUATION -> 4
    
    let from_int = function
      | 0 -> Ok PUBLICATION_OBJ_SPEC_TYPE_UNDEFINED
      | 1 -> Ok PUBLICATIONOBJ_TABLE
      | 2 -> Ok PUBLICATIONOBJ_TABLES_IN_SCHEMA
      | 3 -> Ok PUBLICATIONOBJ_TABLES_IN_CUR_SCHEMA
      | 4 -> Ok PUBLICATIONOBJ_CONTINUATION
      | n -> Error (`Unknown_enum_value n)
    
  end
  and AlterPublicationAction : sig
    type t = ALTER_PUBLICATION_ACTION_UNDEFINED | AP_AddObjects | AP_DropObjects | AP_SetObjects 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = ALTER_PUBLICATION_ACTION_UNDEFINED | AP_AddObjects | AP_DropObjects | AP_SetObjects 
    let to_int = function
      | ALTER_PUBLICATION_ACTION_UNDEFINED -> 0
      | AP_AddObjects -> 1
      | AP_DropObjects -> 2
      | AP_SetObjects -> 3
    
    let from_int = function
      | 0 -> Ok ALTER_PUBLICATION_ACTION_UNDEFINED
      | 1 -> Ok AP_AddObjects
      | 2 -> Ok AP_DropObjects
      | 3 -> Ok AP_SetObjects
      | n -> Error (`Unknown_enum_value n)
    
  end
  and AlterSubscriptionType : sig
    type t = ALTER_SUBSCRIPTION_TYPE_UNDEFINED | ALTER_SUBSCRIPTION_OPTIONS | ALTER_SUBSCRIPTION_CONNECTION | ALTER_SUBSCRIPTION_SET_PUBLICATION | ALTER_SUBSCRIPTION_ADD_PUBLICATION | ALTER_SUBSCRIPTION_DROP_PUBLICATION | ALTER_SUBSCRIPTION_REFRESH | ALTER_SUBSCRIPTION_ENABLED | ALTER_SUBSCRIPTION_SKIP 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = ALTER_SUBSCRIPTION_TYPE_UNDEFINED | ALTER_SUBSCRIPTION_OPTIONS | ALTER_SUBSCRIPTION_CONNECTION | ALTER_SUBSCRIPTION_SET_PUBLICATION | ALTER_SUBSCRIPTION_ADD_PUBLICATION | ALTER_SUBSCRIPTION_DROP_PUBLICATION | ALTER_SUBSCRIPTION_REFRESH | ALTER_SUBSCRIPTION_ENABLED | ALTER_SUBSCRIPTION_SKIP 
    let to_int = function
      | ALTER_SUBSCRIPTION_TYPE_UNDEFINED -> 0
      | ALTER_SUBSCRIPTION_OPTIONS -> 1
      | ALTER_SUBSCRIPTION_CONNECTION -> 2
      | ALTER_SUBSCRIPTION_SET_PUBLICATION -> 3
      | ALTER_SUBSCRIPTION_ADD_PUBLICATION -> 4
      | ALTER_SUBSCRIPTION_DROP_PUBLICATION -> 5
      | ALTER_SUBSCRIPTION_REFRESH -> 6
      | ALTER_SUBSCRIPTION_ENABLED -> 7
      | ALTER_SUBSCRIPTION_SKIP -> 8
    
    let from_int = function
      | 0 -> Ok ALTER_SUBSCRIPTION_TYPE_UNDEFINED
      | 1 -> Ok ALTER_SUBSCRIPTION_OPTIONS
      | 2 -> Ok ALTER_SUBSCRIPTION_CONNECTION
      | 3 -> Ok ALTER_SUBSCRIPTION_SET_PUBLICATION
      | 4 -> Ok ALTER_SUBSCRIPTION_ADD_PUBLICATION
      | 5 -> Ok ALTER_SUBSCRIPTION_DROP_PUBLICATION
      | 6 -> Ok ALTER_SUBSCRIPTION_REFRESH
      | 7 -> Ok ALTER_SUBSCRIPTION_ENABLED
      | 8 -> Ok ALTER_SUBSCRIPTION_SKIP
      | n -> Error (`Unknown_enum_value n)
    
  end
  and OnCommitAction : sig
    type t = ON_COMMIT_ACTION_UNDEFINED | ONCOMMIT_NOOP | ONCOMMIT_PRESERVE_ROWS | ONCOMMIT_DELETE_ROWS | ONCOMMIT_DROP 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = ON_COMMIT_ACTION_UNDEFINED | ONCOMMIT_NOOP | ONCOMMIT_PRESERVE_ROWS | ONCOMMIT_DELETE_ROWS | ONCOMMIT_DROP 
    let to_int = function
      | ON_COMMIT_ACTION_UNDEFINED -> 0
      | ONCOMMIT_NOOP -> 1
      | ONCOMMIT_PRESERVE_ROWS -> 2
      | ONCOMMIT_DELETE_ROWS -> 3
      | ONCOMMIT_DROP -> 4
    
    let from_int = function
      | 0 -> Ok ON_COMMIT_ACTION_UNDEFINED
      | 1 -> Ok ONCOMMIT_NOOP
      | 2 -> Ok ONCOMMIT_PRESERVE_ROWS
      | 3 -> Ok ONCOMMIT_DELETE_ROWS
      | 4 -> Ok ONCOMMIT_DROP
      | n -> Error (`Unknown_enum_value n)
    
  end
  and ParamKind : sig
    type t = PARAM_KIND_UNDEFINED | PARAM_EXTERN | PARAM_EXEC | PARAM_SUBLINK | PARAM_MULTIEXPR 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = PARAM_KIND_UNDEFINED | PARAM_EXTERN | PARAM_EXEC | PARAM_SUBLINK | PARAM_MULTIEXPR 
    let to_int = function
      | PARAM_KIND_UNDEFINED -> 0
      | PARAM_EXTERN -> 1
      | PARAM_EXEC -> 2
      | PARAM_SUBLINK -> 3
      | PARAM_MULTIEXPR -> 4
    
    let from_int = function
      | 0 -> Ok PARAM_KIND_UNDEFINED
      | 1 -> Ok PARAM_EXTERN
      | 2 -> Ok PARAM_EXEC
      | 3 -> Ok PARAM_SUBLINK
      | 4 -> Ok PARAM_MULTIEXPR
      | n -> Error (`Unknown_enum_value n)
    
  end
  and CoercionContext : sig
    type t = COERCION_CONTEXT_UNDEFINED | COERCION_IMPLICIT | COERCION_ASSIGNMENT | COERCION_PLPGSQL | COERCION_EXPLICIT 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = COERCION_CONTEXT_UNDEFINED | COERCION_IMPLICIT | COERCION_ASSIGNMENT | COERCION_PLPGSQL | COERCION_EXPLICIT 
    let to_int = function
      | COERCION_CONTEXT_UNDEFINED -> 0
      | COERCION_IMPLICIT -> 1
      | COERCION_ASSIGNMENT -> 2
      | COERCION_PLPGSQL -> 3
      | COERCION_EXPLICIT -> 4
    
    let from_int = function
      | 0 -> Ok COERCION_CONTEXT_UNDEFINED
      | 1 -> Ok COERCION_IMPLICIT
      | 2 -> Ok COERCION_ASSIGNMENT
      | 3 -> Ok COERCION_PLPGSQL
      | 4 -> Ok COERCION_EXPLICIT
      | n -> Error (`Unknown_enum_value n)
    
  end
  and CoercionForm : sig
    type t = COERCION_FORM_UNDEFINED | COERCE_EXPLICIT_CALL | COERCE_EXPLICIT_CAST | COERCE_IMPLICIT_CAST | COERCE_SQL_SYNTAX 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = COERCION_FORM_UNDEFINED | COERCE_EXPLICIT_CALL | COERCE_EXPLICIT_CAST | COERCE_IMPLICIT_CAST | COERCE_SQL_SYNTAX 
    let to_int = function
      | COERCION_FORM_UNDEFINED -> 0
      | COERCE_EXPLICIT_CALL -> 1
      | COERCE_EXPLICIT_CAST -> 2
      | COERCE_IMPLICIT_CAST -> 3
      | COERCE_SQL_SYNTAX -> 4
    
    let from_int = function
      | 0 -> Ok COERCION_FORM_UNDEFINED
      | 1 -> Ok COERCE_EXPLICIT_CALL
      | 2 -> Ok COERCE_EXPLICIT_CAST
      | 3 -> Ok COERCE_IMPLICIT_CAST
      | 4 -> Ok COERCE_SQL_SYNTAX
      | n -> Error (`Unknown_enum_value n)
    
  end
  and BoolExprType : sig
    type t = BOOL_EXPR_TYPE_UNDEFINED | AND_EXPR | OR_EXPR | NOT_EXPR 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = BOOL_EXPR_TYPE_UNDEFINED | AND_EXPR | OR_EXPR | NOT_EXPR 
    let to_int = function
      | BOOL_EXPR_TYPE_UNDEFINED -> 0
      | AND_EXPR -> 1
      | OR_EXPR -> 2
      | NOT_EXPR -> 3
    
    let from_int = function
      | 0 -> Ok BOOL_EXPR_TYPE_UNDEFINED
      | 1 -> Ok AND_EXPR
      | 2 -> Ok OR_EXPR
      | 3 -> Ok NOT_EXPR
      | n -> Error (`Unknown_enum_value n)
    
  end
  and SubLinkType : sig
    type t = SUB_LINK_TYPE_UNDEFINED | EXISTS_SUBLINK | ALL_SUBLINK | ANY_SUBLINK | ROWCOMPARE_SUBLINK | EXPR_SUBLINK | MULTIEXPR_SUBLINK | ARRAY_SUBLINK | CTE_SUBLINK 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = SUB_LINK_TYPE_UNDEFINED | EXISTS_SUBLINK | ALL_SUBLINK | ANY_SUBLINK | ROWCOMPARE_SUBLINK | EXPR_SUBLINK | MULTIEXPR_SUBLINK | ARRAY_SUBLINK | CTE_SUBLINK 
    let to_int = function
      | SUB_LINK_TYPE_UNDEFINED -> 0
      | EXISTS_SUBLINK -> 1
      | ALL_SUBLINK -> 2
      | ANY_SUBLINK -> 3
      | ROWCOMPARE_SUBLINK -> 4
      | EXPR_SUBLINK -> 5
      | MULTIEXPR_SUBLINK -> 6
      | ARRAY_SUBLINK -> 7
      | CTE_SUBLINK -> 8
    
    let from_int = function
      | 0 -> Ok SUB_LINK_TYPE_UNDEFINED
      | 1 -> Ok EXISTS_SUBLINK
      | 2 -> Ok ALL_SUBLINK
      | 3 -> Ok ANY_SUBLINK
      | 4 -> Ok ROWCOMPARE_SUBLINK
      | 5 -> Ok EXPR_SUBLINK
      | 6 -> Ok MULTIEXPR_SUBLINK
      | 7 -> Ok ARRAY_SUBLINK
      | 8 -> Ok CTE_SUBLINK
      | n -> Error (`Unknown_enum_value n)
    
  end
  and RowCompareType : sig
    type t = ROW_COMPARE_TYPE_UNDEFINED | ROWCOMPARE_LT | ROWCOMPARE_LE | ROWCOMPARE_EQ | ROWCOMPARE_GE | ROWCOMPARE_GT | ROWCOMPARE_NE 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = ROW_COMPARE_TYPE_UNDEFINED | ROWCOMPARE_LT | ROWCOMPARE_LE | ROWCOMPARE_EQ | ROWCOMPARE_GE | ROWCOMPARE_GT | ROWCOMPARE_NE 
    let to_int = function
      | ROW_COMPARE_TYPE_UNDEFINED -> 0
      | ROWCOMPARE_LT -> 1
      | ROWCOMPARE_LE -> 2
      | ROWCOMPARE_EQ -> 3
      | ROWCOMPARE_GE -> 4
      | ROWCOMPARE_GT -> 5
      | ROWCOMPARE_NE -> 6
    
    let from_int = function
      | 0 -> Ok ROW_COMPARE_TYPE_UNDEFINED
      | 1 -> Ok ROWCOMPARE_LT
      | 2 -> Ok ROWCOMPARE_LE
      | 3 -> Ok ROWCOMPARE_EQ
      | 4 -> Ok ROWCOMPARE_GE
      | 5 -> Ok ROWCOMPARE_GT
      | 6 -> Ok ROWCOMPARE_NE
      | n -> Error (`Unknown_enum_value n)
    
  end
  and MinMaxOp : sig
    type t = MIN_MAX_OP_UNDEFINED | IS_GREATEST | IS_LEAST 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = MIN_MAX_OP_UNDEFINED | IS_GREATEST | IS_LEAST 
    let to_int = function
      | MIN_MAX_OP_UNDEFINED -> 0
      | IS_GREATEST -> 1
      | IS_LEAST -> 2
    
    let from_int = function
      | 0 -> Ok MIN_MAX_OP_UNDEFINED
      | 1 -> Ok IS_GREATEST
      | 2 -> Ok IS_LEAST
      | n -> Error (`Unknown_enum_value n)
    
  end
  and SQLValueFunctionOp : sig
    type t = SQLVALUE_FUNCTION_OP_UNDEFINED | SVFOP_CURRENT_DATE | SVFOP_CURRENT_TIME | SVFOP_CURRENT_TIME_N | SVFOP_CURRENT_TIMESTAMP | SVFOP_CURRENT_TIMESTAMP_N | SVFOP_LOCALTIME | SVFOP_LOCALTIME_N | SVFOP_LOCALTIMESTAMP | SVFOP_LOCALTIMESTAMP_N | SVFOP_CURRENT_ROLE | SVFOP_CURRENT_USER | SVFOP_USER | SVFOP_SESSION_USER | SVFOP_CURRENT_CATALOG | SVFOP_CURRENT_SCHEMA 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = SQLVALUE_FUNCTION_OP_UNDEFINED | SVFOP_CURRENT_DATE | SVFOP_CURRENT_TIME | SVFOP_CURRENT_TIME_N | SVFOP_CURRENT_TIMESTAMP | SVFOP_CURRENT_TIMESTAMP_N | SVFOP_LOCALTIME | SVFOP_LOCALTIME_N | SVFOP_LOCALTIMESTAMP | SVFOP_LOCALTIMESTAMP_N | SVFOP_CURRENT_ROLE | SVFOP_CURRENT_USER | SVFOP_USER | SVFOP_SESSION_USER | SVFOP_CURRENT_CATALOG | SVFOP_CURRENT_SCHEMA 
    let to_int = function
      | SQLVALUE_FUNCTION_OP_UNDEFINED -> 0
      | SVFOP_CURRENT_DATE -> 1
      | SVFOP_CURRENT_TIME -> 2
      | SVFOP_CURRENT_TIME_N -> 3
      | SVFOP_CURRENT_TIMESTAMP -> 4
      | SVFOP_CURRENT_TIMESTAMP_N -> 5
      | SVFOP_LOCALTIME -> 6
      | SVFOP_LOCALTIME_N -> 7
      | SVFOP_LOCALTIMESTAMP -> 8
      | SVFOP_LOCALTIMESTAMP_N -> 9
      | SVFOP_CURRENT_ROLE -> 10
      | SVFOP_CURRENT_USER -> 11
      | SVFOP_USER -> 12
      | SVFOP_SESSION_USER -> 13
      | SVFOP_CURRENT_CATALOG -> 14
      | SVFOP_CURRENT_SCHEMA -> 15
    
    let from_int = function
      | 0 -> Ok SQLVALUE_FUNCTION_OP_UNDEFINED
      | 1 -> Ok SVFOP_CURRENT_DATE
      | 2 -> Ok SVFOP_CURRENT_TIME
      | 3 -> Ok SVFOP_CURRENT_TIME_N
      | 4 -> Ok SVFOP_CURRENT_TIMESTAMP
      | 5 -> Ok SVFOP_CURRENT_TIMESTAMP_N
      | 6 -> Ok SVFOP_LOCALTIME
      | 7 -> Ok SVFOP_LOCALTIME_N
      | 8 -> Ok SVFOP_LOCALTIMESTAMP
      | 9 -> Ok SVFOP_LOCALTIMESTAMP_N
      | 10 -> Ok SVFOP_CURRENT_ROLE
      | 11 -> Ok SVFOP_CURRENT_USER
      | 12 -> Ok SVFOP_USER
      | 13 -> Ok SVFOP_SESSION_USER
      | 14 -> Ok SVFOP_CURRENT_CATALOG
      | 15 -> Ok SVFOP_CURRENT_SCHEMA
      | n -> Error (`Unknown_enum_value n)
    
  end
  and XmlExprOp : sig
    type t = XML_EXPR_OP_UNDEFINED | IS_XMLCONCAT | IS_XMLELEMENT | IS_XMLFOREST | IS_XMLPARSE | IS_XMLPI | IS_XMLROOT | IS_XMLSERIALIZE | IS_DOCUMENT 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = XML_EXPR_OP_UNDEFINED | IS_XMLCONCAT | IS_XMLELEMENT | IS_XMLFOREST | IS_XMLPARSE | IS_XMLPI | IS_XMLROOT | IS_XMLSERIALIZE | IS_DOCUMENT 
    let to_int = function
      | XML_EXPR_OP_UNDEFINED -> 0
      | IS_XMLCONCAT -> 1
      | IS_XMLELEMENT -> 2
      | IS_XMLFOREST -> 3
      | IS_XMLPARSE -> 4
      | IS_XMLPI -> 5
      | IS_XMLROOT -> 6
      | IS_XMLSERIALIZE -> 7
      | IS_DOCUMENT -> 8
    
    let from_int = function
      | 0 -> Ok XML_EXPR_OP_UNDEFINED
      | 1 -> Ok IS_XMLCONCAT
      | 2 -> Ok IS_XMLELEMENT
      | 3 -> Ok IS_XMLFOREST
      | 4 -> Ok IS_XMLPARSE
      | 5 -> Ok IS_XMLPI
      | 6 -> Ok IS_XMLROOT
      | 7 -> Ok IS_XMLSERIALIZE
      | 8 -> Ok IS_DOCUMENT
      | n -> Error (`Unknown_enum_value n)
    
  end
  and XmlOptionType : sig
    type t = XML_OPTION_TYPE_UNDEFINED | XMLOPTION_DOCUMENT | XMLOPTION_CONTENT 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = XML_OPTION_TYPE_UNDEFINED | XMLOPTION_DOCUMENT | XMLOPTION_CONTENT 
    let to_int = function
      | XML_OPTION_TYPE_UNDEFINED -> 0
      | XMLOPTION_DOCUMENT -> 1
      | XMLOPTION_CONTENT -> 2
    
    let from_int = function
      | 0 -> Ok XML_OPTION_TYPE_UNDEFINED
      | 1 -> Ok XMLOPTION_DOCUMENT
      | 2 -> Ok XMLOPTION_CONTENT
      | n -> Error (`Unknown_enum_value n)
    
  end
  and NullTestType : sig
    type t = NULL_TEST_TYPE_UNDEFINED | IS_NULL | IS_NOT_NULL 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = NULL_TEST_TYPE_UNDEFINED | IS_NULL | IS_NOT_NULL 
    let to_int = function
      | NULL_TEST_TYPE_UNDEFINED -> 0
      | IS_NULL -> 1
      | IS_NOT_NULL -> 2
    
    let from_int = function
      | 0 -> Ok NULL_TEST_TYPE_UNDEFINED
      | 1 -> Ok IS_NULL
      | 2 -> Ok IS_NOT_NULL
      | n -> Error (`Unknown_enum_value n)
    
  end
  and BoolTestType : sig
    type t = BOOL_TEST_TYPE_UNDEFINED | IS_TRUE | IS_NOT_TRUE | IS_FALSE | IS_NOT_FALSE | IS_UNKNOWN | IS_NOT_UNKNOWN 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = BOOL_TEST_TYPE_UNDEFINED | IS_TRUE | IS_NOT_TRUE | IS_FALSE | IS_NOT_FALSE | IS_UNKNOWN | IS_NOT_UNKNOWN 
    let to_int = function
      | BOOL_TEST_TYPE_UNDEFINED -> 0
      | IS_TRUE -> 1
      | IS_NOT_TRUE -> 2
      | IS_FALSE -> 3
      | IS_NOT_FALSE -> 4
      | IS_UNKNOWN -> 5
      | IS_NOT_UNKNOWN -> 6
    
    let from_int = function
      | 0 -> Ok BOOL_TEST_TYPE_UNDEFINED
      | 1 -> Ok IS_TRUE
      | 2 -> Ok IS_NOT_TRUE
      | 3 -> Ok IS_FALSE
      | 4 -> Ok IS_NOT_FALSE
      | 5 -> Ok IS_UNKNOWN
      | 6 -> Ok IS_NOT_UNKNOWN
      | n -> Error (`Unknown_enum_value n)
    
  end
  and CmdType : sig
    type t = CMD_TYPE_UNDEFINED | CMD_UNKNOWN | CMD_SELECT | CMD_UPDATE | CMD_INSERT | CMD_DELETE | CMD_MERGE | CMD_UTILITY | CMD_NOTHING 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = CMD_TYPE_UNDEFINED | CMD_UNKNOWN | CMD_SELECT | CMD_UPDATE | CMD_INSERT | CMD_DELETE | CMD_MERGE | CMD_UTILITY | CMD_NOTHING 
    let to_int = function
      | CMD_TYPE_UNDEFINED -> 0
      | CMD_UNKNOWN -> 1
      | CMD_SELECT -> 2
      | CMD_UPDATE -> 3
      | CMD_INSERT -> 4
      | CMD_DELETE -> 5
      | CMD_MERGE -> 6
      | CMD_UTILITY -> 7
      | CMD_NOTHING -> 8
    
    let from_int = function
      | 0 -> Ok CMD_TYPE_UNDEFINED
      | 1 -> Ok CMD_UNKNOWN
      | 2 -> Ok CMD_SELECT
      | 3 -> Ok CMD_UPDATE
      | 4 -> Ok CMD_INSERT
      | 5 -> Ok CMD_DELETE
      | 6 -> Ok CMD_MERGE
      | 7 -> Ok CMD_UTILITY
      | 8 -> Ok CMD_NOTHING
      | n -> Error (`Unknown_enum_value n)
    
  end
  and JoinType : sig
    type t = JOIN_TYPE_UNDEFINED | JOIN_INNER | JOIN_LEFT | JOIN_FULL | JOIN_RIGHT | JOIN_SEMI | JOIN_ANTI | JOIN_UNIQUE_OUTER | JOIN_UNIQUE_INNER 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = JOIN_TYPE_UNDEFINED | JOIN_INNER | JOIN_LEFT | JOIN_FULL | JOIN_RIGHT | JOIN_SEMI | JOIN_ANTI | JOIN_UNIQUE_OUTER | JOIN_UNIQUE_INNER 
    let to_int = function
      | JOIN_TYPE_UNDEFINED -> 0
      | JOIN_INNER -> 1
      | JOIN_LEFT -> 2
      | JOIN_FULL -> 3
      | JOIN_RIGHT -> 4
      | JOIN_SEMI -> 5
      | JOIN_ANTI -> 6
      | JOIN_UNIQUE_OUTER -> 7
      | JOIN_UNIQUE_INNER -> 8
    
    let from_int = function
      | 0 -> Ok JOIN_TYPE_UNDEFINED
      | 1 -> Ok JOIN_INNER
      | 2 -> Ok JOIN_LEFT
      | 3 -> Ok JOIN_FULL
      | 4 -> Ok JOIN_RIGHT
      | 5 -> Ok JOIN_SEMI
      | 6 -> Ok JOIN_ANTI
      | 7 -> Ok JOIN_UNIQUE_OUTER
      | 8 -> Ok JOIN_UNIQUE_INNER
      | n -> Error (`Unknown_enum_value n)
    
  end
  and AggStrategy : sig
    type t = AGG_STRATEGY_UNDEFINED | AGG_PLAIN | AGG_SORTED | AGG_HASHED | AGG_MIXED 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = AGG_STRATEGY_UNDEFINED | AGG_PLAIN | AGG_SORTED | AGG_HASHED | AGG_MIXED 
    let to_int = function
      | AGG_STRATEGY_UNDEFINED -> 0
      | AGG_PLAIN -> 1
      | AGG_SORTED -> 2
      | AGG_HASHED -> 3
      | AGG_MIXED -> 4
    
    let from_int = function
      | 0 -> Ok AGG_STRATEGY_UNDEFINED
      | 1 -> Ok AGG_PLAIN
      | 2 -> Ok AGG_SORTED
      | 3 -> Ok AGG_HASHED
      | 4 -> Ok AGG_MIXED
      | n -> Error (`Unknown_enum_value n)
    
  end
  and AggSplit : sig
    type t = AGG_SPLIT_UNDEFINED | AGGSPLIT_SIMPLE | AGGSPLIT_INITIAL_SERIAL | AGGSPLIT_FINAL_DESERIAL 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = AGG_SPLIT_UNDEFINED | AGGSPLIT_SIMPLE | AGGSPLIT_INITIAL_SERIAL | AGGSPLIT_FINAL_DESERIAL 
    let to_int = function
      | AGG_SPLIT_UNDEFINED -> 0
      | AGGSPLIT_SIMPLE -> 1
      | AGGSPLIT_INITIAL_SERIAL -> 2
      | AGGSPLIT_FINAL_DESERIAL -> 3
    
    let from_int = function
      | 0 -> Ok AGG_SPLIT_UNDEFINED
      | 1 -> Ok AGGSPLIT_SIMPLE
      | 2 -> Ok AGGSPLIT_INITIAL_SERIAL
      | 3 -> Ok AGGSPLIT_FINAL_DESERIAL
      | n -> Error (`Unknown_enum_value n)
    
  end
  and SetOpCmd : sig
    type t = SET_OP_CMD_UNDEFINED | SETOPCMD_INTERSECT | SETOPCMD_INTERSECT_ALL | SETOPCMD_EXCEPT | SETOPCMD_EXCEPT_ALL 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = SET_OP_CMD_UNDEFINED | SETOPCMD_INTERSECT | SETOPCMD_INTERSECT_ALL | SETOPCMD_EXCEPT | SETOPCMD_EXCEPT_ALL 
    let to_int = function
      | SET_OP_CMD_UNDEFINED -> 0
      | SETOPCMD_INTERSECT -> 1
      | SETOPCMD_INTERSECT_ALL -> 2
      | SETOPCMD_EXCEPT -> 3
      | SETOPCMD_EXCEPT_ALL -> 4
    
    let from_int = function
      | 0 -> Ok SET_OP_CMD_UNDEFINED
      | 1 -> Ok SETOPCMD_INTERSECT
      | 2 -> Ok SETOPCMD_INTERSECT_ALL
      | 3 -> Ok SETOPCMD_EXCEPT
      | 4 -> Ok SETOPCMD_EXCEPT_ALL
      | n -> Error (`Unknown_enum_value n)
    
  end
  and SetOpStrategy : sig
    type t = SET_OP_STRATEGY_UNDEFINED | SETOP_SORTED | SETOP_HASHED 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = SET_OP_STRATEGY_UNDEFINED | SETOP_SORTED | SETOP_HASHED 
    let to_int = function
      | SET_OP_STRATEGY_UNDEFINED -> 0
      | SETOP_SORTED -> 1
      | SETOP_HASHED -> 2
    
    let from_int = function
      | 0 -> Ok SET_OP_STRATEGY_UNDEFINED
      | 1 -> Ok SETOP_SORTED
      | 2 -> Ok SETOP_HASHED
      | n -> Error (`Unknown_enum_value n)
    
  end
  and OnConflictAction : sig
    type t = ON_CONFLICT_ACTION_UNDEFINED | ONCONFLICT_NONE | ONCONFLICT_NOTHING | ONCONFLICT_UPDATE 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = ON_CONFLICT_ACTION_UNDEFINED | ONCONFLICT_NONE | ONCONFLICT_NOTHING | ONCONFLICT_UPDATE 
    let to_int = function
      | ON_CONFLICT_ACTION_UNDEFINED -> 0
      | ONCONFLICT_NONE -> 1
      | ONCONFLICT_NOTHING -> 2
      | ONCONFLICT_UPDATE -> 3
    
    let from_int = function
      | 0 -> Ok ON_CONFLICT_ACTION_UNDEFINED
      | 1 -> Ok ONCONFLICT_NONE
      | 2 -> Ok ONCONFLICT_NOTHING
      | 3 -> Ok ONCONFLICT_UPDATE
      | n -> Error (`Unknown_enum_value n)
    
  end
  and LimitOption : sig
    type t = LIMIT_OPTION_UNDEFINED | LIMIT_OPTION_DEFAULT | LIMIT_OPTION_COUNT | LIMIT_OPTION_WITH_TIES 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = LIMIT_OPTION_UNDEFINED | LIMIT_OPTION_DEFAULT | LIMIT_OPTION_COUNT | LIMIT_OPTION_WITH_TIES 
    let to_int = function
      | LIMIT_OPTION_UNDEFINED -> 0
      | LIMIT_OPTION_DEFAULT -> 1
      | LIMIT_OPTION_COUNT -> 2
      | LIMIT_OPTION_WITH_TIES -> 3
    
    let from_int = function
      | 0 -> Ok LIMIT_OPTION_UNDEFINED
      | 1 -> Ok LIMIT_OPTION_DEFAULT
      | 2 -> Ok LIMIT_OPTION_COUNT
      | 3 -> Ok LIMIT_OPTION_WITH_TIES
      | n -> Error (`Unknown_enum_value n)
    
  end
  and LockClauseStrength : sig
    type t = LOCK_CLAUSE_STRENGTH_UNDEFINED | LCS_NONE | LCS_FORKEYSHARE | LCS_FORSHARE | LCS_FORNOKEYUPDATE | LCS_FORUPDATE 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = LOCK_CLAUSE_STRENGTH_UNDEFINED | LCS_NONE | LCS_FORKEYSHARE | LCS_FORSHARE | LCS_FORNOKEYUPDATE | LCS_FORUPDATE 
    let to_int = function
      | LOCK_CLAUSE_STRENGTH_UNDEFINED -> 0
      | LCS_NONE -> 1
      | LCS_FORKEYSHARE -> 2
      | LCS_FORSHARE -> 3
      | LCS_FORNOKEYUPDATE -> 4
      | LCS_FORUPDATE -> 5
    
    let from_int = function
      | 0 -> Ok LOCK_CLAUSE_STRENGTH_UNDEFINED
      | 1 -> Ok LCS_NONE
      | 2 -> Ok LCS_FORKEYSHARE
      | 3 -> Ok LCS_FORSHARE
      | 4 -> Ok LCS_FORNOKEYUPDATE
      | 5 -> Ok LCS_FORUPDATE
      | n -> Error (`Unknown_enum_value n)
    
  end
  and LockWaitPolicy : sig
    type t = LOCK_WAIT_POLICY_UNDEFINED | LockWaitBlock | LockWaitSkip | LockWaitError 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = LOCK_WAIT_POLICY_UNDEFINED | LockWaitBlock | LockWaitSkip | LockWaitError 
    let to_int = function
      | LOCK_WAIT_POLICY_UNDEFINED -> 0
      | LockWaitBlock -> 1
      | LockWaitSkip -> 2
      | LockWaitError -> 3
    
    let from_int = function
      | 0 -> Ok LOCK_WAIT_POLICY_UNDEFINED
      | 1 -> Ok LockWaitBlock
      | 2 -> Ok LockWaitSkip
      | 3 -> Ok LockWaitError
      | n -> Error (`Unknown_enum_value n)
    
  end
  and LockTupleMode : sig
    type t = LOCK_TUPLE_MODE_UNDEFINED | LockTupleKeyShare | LockTupleShare | LockTupleNoKeyExclusive | LockTupleExclusive 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = LOCK_TUPLE_MODE_UNDEFINED | LockTupleKeyShare | LockTupleShare | LockTupleNoKeyExclusive | LockTupleExclusive 
    let to_int = function
      | LOCK_TUPLE_MODE_UNDEFINED -> 0
      | LockTupleKeyShare -> 1
      | LockTupleShare -> 2
      | LockTupleNoKeyExclusive -> 3
      | LockTupleExclusive -> 4
    
    let from_int = function
      | 0 -> Ok LOCK_TUPLE_MODE_UNDEFINED
      | 1 -> Ok LockTupleKeyShare
      | 2 -> Ok LockTupleShare
      | 3 -> Ok LockTupleNoKeyExclusive
      | 4 -> Ok LockTupleExclusive
      | n -> Error (`Unknown_enum_value n)
    
  end
  and KeywordKind : sig
    type t = NO_KEYWORD | UNRESERVED_KEYWORD | COL_NAME_KEYWORD | TYPE_FUNC_NAME_KEYWORD | RESERVED_KEYWORD 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = NO_KEYWORD | UNRESERVED_KEYWORD | COL_NAME_KEYWORD | TYPE_FUNC_NAME_KEYWORD | RESERVED_KEYWORD 
    let to_int = function
      | NO_KEYWORD -> 0
      | UNRESERVED_KEYWORD -> 1
      | COL_NAME_KEYWORD -> 2
      | TYPE_FUNC_NAME_KEYWORD -> 3
      | RESERVED_KEYWORD -> 4
    
    let from_int = function
      | 0 -> Ok NO_KEYWORD
      | 1 -> Ok UNRESERVED_KEYWORD
      | 2 -> Ok COL_NAME_KEYWORD
      | 3 -> Ok TYPE_FUNC_NAME_KEYWORD
      | 4 -> Ok RESERVED_KEYWORD
      | n -> Error (`Unknown_enum_value n)
    
  end
  and Token : sig
    type t = NUL | ASCII_37 | ASCII_40 | ASCII_41 | ASCII_42 | ASCII_43 | ASCII_44 | ASCII_45 | ASCII_46 | ASCII_47 | ASCII_58 | ASCII_59 | ASCII_60 | ASCII_61 | ASCII_62 | ASCII_63 | ASCII_91 | ASCII_92 | ASCII_93 | ASCII_94 | IDENT | UIDENT | FCONST | SCONST | USCONST | BCONST | XCONST | Op | ICONST | PARAM | TYPECAST | DOT_DOT | COLON_EQUALS | EQUALS_GREATER | LESS_EQUALS | GREATER_EQUALS | NOT_EQUALS | SQL_COMMENT | C_COMMENT | ABORT_P | ABSOLUTE_P | ACCESS | ACTION | ADD_P | ADMIN | AFTER | AGGREGATE | ALL | ALSO | ALTER | ALWAYS | ANALYSE | ANALYZE | AND | ANY | ARRAY | AS | ASC | ASENSITIVE | ASSERTION | ASSIGNMENT | ASYMMETRIC | ATOMIC | AT | ATTACH | ATTRIBUTE | AUTHORIZATION | BACKWARD | BEFORE | BEGIN_P | BETWEEN | BIGINT | BINARY | BIT | BOOLEAN_P | BOTH | BREADTH | BY | CACHE | CALL | CALLED | CASCADE | CASCADED | CASE | CAST | CATALOG_P | CHAIN | CHAR_P | CHARACTER | CHARACTERISTICS | CHECK | CHECKPOINT | CLASS | CLOSE | CLUSTER | COALESCE | COLLATE | COLLATION | COLUMN | COLUMNS | COMMENT | COMMENTS | COMMIT | COMMITTED | COMPRESSION | CONCURRENTLY | CONFIGURATION | CONFLICT | CONNECTION | CONSTRAINT | CONSTRAINTS | CONTENT_P | CONTINUE_P | CONVERSION_P | COPY | COST | CREATE | CROSS | CSV | CUBE | CURRENT_P | CURRENT_CATALOG | CURRENT_DATE | CURRENT_ROLE | CURRENT_SCHEMA | CURRENT_TIME | CURRENT_TIMESTAMP | CURRENT_USER | CURSOR | CYCLE | DATA_P | DATABASE | DAY_P | DEALLOCATE | DEC | DECIMAL_P | DECLARE | DEFAULT | DEFAULTS | DEFERRABLE | DEFERRED | DEFINER | DELETE_P | DELIMITER | DELIMITERS | DEPENDS | DEPTH | DESC | DETACH | DICTIONARY | DISABLE_P | DISCARD | DISTINCT | DO | DOCUMENT_P | DOMAIN_P | DOUBLE_P | DROP | EACH | ELSE | ENABLE_P | ENCODING | ENCRYPTED | END_P | ENUM_P | ESCAPE | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXCLUSIVE | EXECUTE | EXISTS | EXPLAIN | EXPRESSION | EXTENSION | EXTERNAL | EXTRACT | FALSE_P | FAMILY | FETCH | FILTER | FINALIZE | FIRST_P | FLOAT_P | FOLLOWING | FOR | FORCE | FOREIGN | FORWARD | FREEZE | FROM | FULL | FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRANT | GRANTED | GREATEST | GROUP_P | GROUPING | GROUPS | HANDLER | HAVING | HEADER_P | HOLD | HOUR_P | IDENTITY_P | IF_P | ILIKE | IMMEDIATE | IMMUTABLE | IMPLICIT_P | IMPORT_P | IN_P | INCLUDE | INCLUDING | INCREMENT | INDEX | INDEXES | INHERIT | INHERITS | INITIALLY | INLINE_P | INNER_P | INOUT | INPUT_P | INSENSITIVE | INSERT | INSTEAD | INT_P | INTEGER | INTERSECT | INTERVAL | INTO | INVOKER | IS | ISNULL | ISOLATION | JOIN | KEY | LABEL | LANGUAGE | LARGE_P | LAST_P | LATERAL_P | LEADING | LEAKPROOF | LEAST | LEFT | LEVEL | LIKE | LIMIT | LISTEN | LOAD | LOCAL | LOCALTIME | LOCALTIMESTAMP | LOCATION | LOCK_P | LOCKED | LOGGED | MAPPING | MATCH | MATCHED | MATERIALIZED | MAXVALUE | MERGE | METHOD | MINUTE_P | MINVALUE | MODE | MONTH_P | MOVE | NAME_P | NAMES | NATIONAL | NATURAL | NCHAR | NEW | NEXT | NFC | NFD | NFKC | NFKD | NO | NONE | NORMALIZE | NORMALIZED | NOT | NOTHING | NOTIFY | NOTNULL | NOWAIT | NULL_P | NULLIF | NULLS_P | NUMERIC | OBJECT_P | OF | OFF | OFFSET | OIDS | OLD | ON | ONLY | OPERATOR | OPTION | OPTIONS | OR | ORDER | ORDINALITY | OTHERS | OUT_P | OUTER_P | OVER | OVERLAPS | OVERLAY | OVERRIDING | OWNED | OWNER | PARALLEL | PARAMETER | PARSER | PARTIAL | PARTITION | PASSING | PASSWORD | PLACING | PLANS | POLICY | POSITION | PRECEDING | PRECISION | PRESERVE | PREPARE | PREPARED | PRIMARY | PRIOR | PRIVILEGES | PROCEDURAL | PROCEDURE | PROCEDURES | PROGRAM | PUBLICATION | QUOTE | RANGE | READ | REAL | REASSIGN | RECHECK | RECURSIVE | REF_P | REFERENCES | REFERENCING | REFRESH | REINDEX | RELATIVE_P | RELEASE | RENAME | REPEATABLE | REPLACE | REPLICA | RESET | RESTART | RESTRICT | RETURN | RETURNING | RETURNS | REVOKE | RIGHT | ROLE | ROLLBACK | ROLLUP | ROUTINE | ROUTINES | ROW | ROWS | RULE | SAVEPOINT | SCHEMA | SCHEMAS | SCROLL | SEARCH | SECOND_P | SECURITY | SELECT | SEQUENCE | SEQUENCES | SERIALIZABLE | SERVER | SESSION | SESSION_USER | SET | SETS | SETOF | SHARE | SHOW | SIMILAR | SIMPLE | SKIP | SMALLINT | SNAPSHOT | SOME | SQL_P | STABLE | STANDALONE_P | START | STATEMENT | STATISTICS | STDIN | STDOUT | STORAGE | STORED | STRICT_P | STRIP_P | SUBSCRIPTION | SUBSTRING | SUPPORT | SYMMETRIC | SYSID | SYSTEM_P | TABLE | TABLES | TABLESAMPLE | TABLESPACE | TEMP | TEMPLATE | TEMPORARY | TEXT_P | THEN | TIES | TIME | TIMESTAMP | TO | TRAILING | TRANSACTION | TRANSFORM | TREAT | TRIGGER | TRIM | TRUE_P | TRUNCATE | TRUSTED | TYPE_P | TYPES_P | UESCAPE | UNBOUNDED | UNCOMMITTED | UNENCRYPTED | UNION | UNIQUE | UNKNOWN | UNLISTEN | UNLOGGED | UNTIL | UPDATE | USER | USING | VACUUM | VALID | VALIDATE | VALIDATOR | VALUE_P | VALUES | VARCHAR | VARIADIC | VARYING | VERBOSE | VERSION_P | VIEW | VIEWS | VOLATILE | WHEN | WHERE | WHITESPACE_P | WINDOW | WITH | WITHIN | WITHOUT | WORK | WRAPPER | WRITE | XML_P | XMLATTRIBUTES | XMLCONCAT | XMLELEMENT | XMLEXISTS | XMLFOREST | XMLNAMESPACES | XMLPARSE | XMLPI | XMLROOT | XMLSERIALIZE | XMLTABLE | YEAR_P | YES_P | ZONE | NOT_LA | NULLS_LA | WITH_LA | MODE_TYPE_NAME | MODE_PLPGSQL_EXPR | MODE_PLPGSQL_ASSIGN1 | MODE_PLPGSQL_ASSIGN2 | MODE_PLPGSQL_ASSIGN3 | UMINUS 
    val to_int: t -> int
    val from_int: int -> (t, [> Runtime'.Result.error]) result
  end = struct 
    type t = NUL | ASCII_37 | ASCII_40 | ASCII_41 | ASCII_42 | ASCII_43 | ASCII_44 | ASCII_45 | ASCII_46 | ASCII_47 | ASCII_58 | ASCII_59 | ASCII_60 | ASCII_61 | ASCII_62 | ASCII_63 | ASCII_91 | ASCII_92 | ASCII_93 | ASCII_94 | IDENT | UIDENT | FCONST | SCONST | USCONST | BCONST | XCONST | Op | ICONST | PARAM | TYPECAST | DOT_DOT | COLON_EQUALS | EQUALS_GREATER | LESS_EQUALS | GREATER_EQUALS | NOT_EQUALS | SQL_COMMENT | C_COMMENT | ABORT_P | ABSOLUTE_P | ACCESS | ACTION | ADD_P | ADMIN | AFTER | AGGREGATE | ALL | ALSO | ALTER | ALWAYS | ANALYSE | ANALYZE | AND | ANY | ARRAY | AS | ASC | ASENSITIVE | ASSERTION | ASSIGNMENT | ASYMMETRIC | ATOMIC | AT | ATTACH | ATTRIBUTE | AUTHORIZATION | BACKWARD | BEFORE | BEGIN_P | BETWEEN | BIGINT | BINARY | BIT | BOOLEAN_P | BOTH | BREADTH | BY | CACHE | CALL | CALLED | CASCADE | CASCADED | CASE | CAST | CATALOG_P | CHAIN | CHAR_P | CHARACTER | CHARACTERISTICS | CHECK | CHECKPOINT | CLASS | CLOSE | CLUSTER | COALESCE | COLLATE | COLLATION | COLUMN | COLUMNS | COMMENT | COMMENTS | COMMIT | COMMITTED | COMPRESSION | CONCURRENTLY | CONFIGURATION | CONFLICT | CONNECTION | CONSTRAINT | CONSTRAINTS | CONTENT_P | CONTINUE_P | CONVERSION_P | COPY | COST | CREATE | CROSS | CSV | CUBE | CURRENT_P | CURRENT_CATALOG | CURRENT_DATE | CURRENT_ROLE | CURRENT_SCHEMA | CURRENT_TIME | CURRENT_TIMESTAMP | CURRENT_USER | CURSOR | CYCLE | DATA_P | DATABASE | DAY_P | DEALLOCATE | DEC | DECIMAL_P | DECLARE | DEFAULT | DEFAULTS | DEFERRABLE | DEFERRED | DEFINER | DELETE_P | DELIMITER | DELIMITERS | DEPENDS | DEPTH | DESC | DETACH | DICTIONARY | DISABLE_P | DISCARD | DISTINCT | DO | DOCUMENT_P | DOMAIN_P | DOUBLE_P | DROP | EACH | ELSE | ENABLE_P | ENCODING | ENCRYPTED | END_P | ENUM_P | ESCAPE | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXCLUSIVE | EXECUTE | EXISTS | EXPLAIN | EXPRESSION | EXTENSION | EXTERNAL | EXTRACT | FALSE_P | FAMILY | FETCH | FILTER | FINALIZE | FIRST_P | FLOAT_P | FOLLOWING | FOR | FORCE | FOREIGN | FORWARD | FREEZE | FROM | FULL | FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRANT | GRANTED | GREATEST | GROUP_P | GROUPING | GROUPS | HANDLER | HAVING | HEADER_P | HOLD | HOUR_P | IDENTITY_P | IF_P | ILIKE | IMMEDIATE | IMMUTABLE | IMPLICIT_P | IMPORT_P | IN_P | INCLUDE | INCLUDING | INCREMENT | INDEX | INDEXES | INHERIT | INHERITS | INITIALLY | INLINE_P | INNER_P | INOUT | INPUT_P | INSENSITIVE | INSERT | INSTEAD | INT_P | INTEGER | INTERSECT | INTERVAL | INTO | INVOKER | IS | ISNULL | ISOLATION | JOIN | KEY | LABEL | LANGUAGE | LARGE_P | LAST_P | LATERAL_P | LEADING | LEAKPROOF | LEAST | LEFT | LEVEL | LIKE | LIMIT | LISTEN | LOAD | LOCAL | LOCALTIME | LOCALTIMESTAMP | LOCATION | LOCK_P | LOCKED | LOGGED | MAPPING | MATCH | MATCHED | MATERIALIZED | MAXVALUE | MERGE | METHOD | MINUTE_P | MINVALUE | MODE | MONTH_P | MOVE | NAME_P | NAMES | NATIONAL | NATURAL | NCHAR | NEW | NEXT | NFC | NFD | NFKC | NFKD | NO | NONE | NORMALIZE | NORMALIZED | NOT | NOTHING | NOTIFY | NOTNULL | NOWAIT | NULL_P | NULLIF | NULLS_P | NUMERIC | OBJECT_P | OF | OFF | OFFSET | OIDS | OLD | ON | ONLY | OPERATOR | OPTION | OPTIONS | OR | ORDER | ORDINALITY | OTHERS | OUT_P | OUTER_P | OVER | OVERLAPS | OVERLAY | OVERRIDING | OWNED | OWNER | PARALLEL | PARAMETER | PARSER | PARTIAL | PARTITION | PASSING | PASSWORD | PLACING | PLANS | POLICY | POSITION | PRECEDING | PRECISION | PRESERVE | PREPARE | PREPARED | PRIMARY | PRIOR | PRIVILEGES | PROCEDURAL | PROCEDURE | PROCEDURES | PROGRAM | PUBLICATION | QUOTE | RANGE | READ | REAL | REASSIGN | RECHECK | RECURSIVE | REF_P | REFERENCES | REFERENCING | REFRESH | REINDEX | RELATIVE_P | RELEASE | RENAME | REPEATABLE | REPLACE | REPLICA | RESET | RESTART | RESTRICT | RETURN | RETURNING | RETURNS | REVOKE | RIGHT | ROLE | ROLLBACK | ROLLUP | ROUTINE | ROUTINES | ROW | ROWS | RULE | SAVEPOINT | SCHEMA | SCHEMAS | SCROLL | SEARCH | SECOND_P | SECURITY | SELECT | SEQUENCE | SEQUENCES | SERIALIZABLE | SERVER | SESSION | SESSION_USER | SET | SETS | SETOF | SHARE | SHOW | SIMILAR | SIMPLE | SKIP | SMALLINT | SNAPSHOT | SOME | SQL_P | STABLE | STANDALONE_P | START | STATEMENT | STATISTICS | STDIN | STDOUT | STORAGE | STORED | STRICT_P | STRIP_P | SUBSCRIPTION | SUBSTRING | SUPPORT | SYMMETRIC | SYSID | SYSTEM_P | TABLE | TABLES | TABLESAMPLE | TABLESPACE | TEMP | TEMPLATE | TEMPORARY | TEXT_P | THEN | TIES | TIME | TIMESTAMP | TO | TRAILING | TRANSACTION | TRANSFORM | TREAT | TRIGGER | TRIM | TRUE_P | TRUNCATE | TRUSTED | TYPE_P | TYPES_P | UESCAPE | UNBOUNDED | UNCOMMITTED | UNENCRYPTED | UNION | UNIQUE | UNKNOWN | UNLISTEN | UNLOGGED | UNTIL | UPDATE | USER | USING | VACUUM | VALID | VALIDATE | VALIDATOR | VALUE_P | VALUES | VARCHAR | VARIADIC | VARYING | VERBOSE | VERSION_P | VIEW | VIEWS | VOLATILE | WHEN | WHERE | WHITESPACE_P | WINDOW | WITH | WITHIN | WITHOUT | WORK | WRAPPER | WRITE | XML_P | XMLATTRIBUTES | XMLCONCAT | XMLELEMENT | XMLEXISTS | XMLFOREST | XMLNAMESPACES | XMLPARSE | XMLPI | XMLROOT | XMLSERIALIZE | XMLTABLE | YEAR_P | YES_P | ZONE | NOT_LA | NULLS_LA | WITH_LA | MODE_TYPE_NAME | MODE_PLPGSQL_EXPR | MODE_PLPGSQL_ASSIGN1 | MODE_PLPGSQL_ASSIGN2 | MODE_PLPGSQL_ASSIGN3 | UMINUS 
    let to_int = function
      | NUL -> 0
      | ASCII_37 -> 37
      | ASCII_40 -> 40
      | ASCII_41 -> 41
      | ASCII_42 -> 42
      | ASCII_43 -> 43
      | ASCII_44 -> 44
      | ASCII_45 -> 45
      | ASCII_46 -> 46
      | ASCII_47 -> 47
      | ASCII_58 -> 58
      | ASCII_59 -> 59
      | ASCII_60 -> 60
      | ASCII_61 -> 61
      | ASCII_62 -> 62
      | ASCII_63 -> 63
      | ASCII_91 -> 91
      | ASCII_92 -> 92
      | ASCII_93 -> 93
      | ASCII_94 -> 94
      | IDENT -> 258
      | UIDENT -> 259
      | FCONST -> 260
      | SCONST -> 261
      | USCONST -> 262
      | BCONST -> 263
      | XCONST -> 264
      | Op -> 265
      | ICONST -> 266
      | PARAM -> 267
      | TYPECAST -> 268
      | DOT_DOT -> 269
      | COLON_EQUALS -> 270
      | EQUALS_GREATER -> 271
      | LESS_EQUALS -> 272
      | GREATER_EQUALS -> 273
      | NOT_EQUALS -> 274
      | SQL_COMMENT -> 275
      | C_COMMENT -> 276
      | ABORT_P -> 277
      | ABSOLUTE_P -> 278
      | ACCESS -> 279
      | ACTION -> 280
      | ADD_P -> 281
      | ADMIN -> 282
      | AFTER -> 283
      | AGGREGATE -> 284
      | ALL -> 285
      | ALSO -> 286
      | ALTER -> 287
      | ALWAYS -> 288
      | ANALYSE -> 289
      | ANALYZE -> 290
      | AND -> 291
      | ANY -> 292
      | ARRAY -> 293
      | AS -> 294
      | ASC -> 295
      | ASENSITIVE -> 296
      | ASSERTION -> 297
      | ASSIGNMENT -> 298
      | ASYMMETRIC -> 299
      | ATOMIC -> 300
      | AT -> 301
      | ATTACH -> 302
      | ATTRIBUTE -> 303
      | AUTHORIZATION -> 304
      | BACKWARD -> 305
      | BEFORE -> 306
      | BEGIN_P -> 307
      | BETWEEN -> 308
      | BIGINT -> 309
      | BINARY -> 310
      | BIT -> 311
      | BOOLEAN_P -> 312
      | BOTH -> 313
      | BREADTH -> 314
      | BY -> 315
      | CACHE -> 316
      | CALL -> 317
      | CALLED -> 318
      | CASCADE -> 319
      | CASCADED -> 320
      | CASE -> 321
      | CAST -> 322
      | CATALOG_P -> 323
      | CHAIN -> 324
      | CHAR_P -> 325
      | CHARACTER -> 326
      | CHARACTERISTICS -> 327
      | CHECK -> 328
      | CHECKPOINT -> 329
      | CLASS -> 330
      | CLOSE -> 331
      | CLUSTER -> 332
      | COALESCE -> 333
      | COLLATE -> 334
      | COLLATION -> 335
      | COLUMN -> 336
      | COLUMNS -> 337
      | COMMENT -> 338
      | COMMENTS -> 339
      | COMMIT -> 340
      | COMMITTED -> 341
      | COMPRESSION -> 342
      | CONCURRENTLY -> 343
      | CONFIGURATION -> 344
      | CONFLICT -> 345
      | CONNECTION -> 346
      | CONSTRAINT -> 347
      | CONSTRAINTS -> 348
      | CONTENT_P -> 349
      | CONTINUE_P -> 350
      | CONVERSION_P -> 351
      | COPY -> 352
      | COST -> 353
      | CREATE -> 354
      | CROSS -> 355
      | CSV -> 356
      | CUBE -> 357
      | CURRENT_P -> 358
      | CURRENT_CATALOG -> 359
      | CURRENT_DATE -> 360
      | CURRENT_ROLE -> 361
      | CURRENT_SCHEMA -> 362
      | CURRENT_TIME -> 363
      | CURRENT_TIMESTAMP -> 364
      | CURRENT_USER -> 365
      | CURSOR -> 366
      | CYCLE -> 367
      | DATA_P -> 368
      | DATABASE -> 369
      | DAY_P -> 370
      | DEALLOCATE -> 371
      | DEC -> 372
      | DECIMAL_P -> 373
      | DECLARE -> 374
      | DEFAULT -> 375
      | DEFAULTS -> 376
      | DEFERRABLE -> 377
      | DEFERRED -> 378
      | DEFINER -> 379
      | DELETE_P -> 380
      | DELIMITER -> 381
      | DELIMITERS -> 382
      | DEPENDS -> 383
      | DEPTH -> 384
      | DESC -> 385
      | DETACH -> 386
      | DICTIONARY -> 387
      | DISABLE_P -> 388
      | DISCARD -> 389
      | DISTINCT -> 390
      | DO -> 391
      | DOCUMENT_P -> 392
      | DOMAIN_P -> 393
      | DOUBLE_P -> 394
      | DROP -> 395
      | EACH -> 396
      | ELSE -> 397
      | ENABLE_P -> 398
      | ENCODING -> 399
      | ENCRYPTED -> 400
      | END_P -> 401
      | ENUM_P -> 402
      | ESCAPE -> 403
      | EVENT -> 404
      | EXCEPT -> 405
      | EXCLUDE -> 406
      | EXCLUDING -> 407
      | EXCLUSIVE -> 408
      | EXECUTE -> 409
      | EXISTS -> 410
      | EXPLAIN -> 411
      | EXPRESSION -> 412
      | EXTENSION -> 413
      | EXTERNAL -> 414
      | EXTRACT -> 415
      | FALSE_P -> 416
      | FAMILY -> 417
      | FETCH -> 418
      | FILTER -> 419
      | FINALIZE -> 420
      | FIRST_P -> 421
      | FLOAT_P -> 422
      | FOLLOWING -> 423
      | FOR -> 424
      | FORCE -> 425
      | FOREIGN -> 426
      | FORWARD -> 427
      | FREEZE -> 428
      | FROM -> 429
      | FULL -> 430
      | FUNCTION -> 431
      | FUNCTIONS -> 432
      | GENERATED -> 433
      | GLOBAL -> 434
      | GRANT -> 435
      | GRANTED -> 436
      | GREATEST -> 437
      | GROUP_P -> 438
      | GROUPING -> 439
      | GROUPS -> 440
      | HANDLER -> 441
      | HAVING -> 442
      | HEADER_P -> 443
      | HOLD -> 444
      | HOUR_P -> 445
      | IDENTITY_P -> 446
      | IF_P -> 447
      | ILIKE -> 448
      | IMMEDIATE -> 449
      | IMMUTABLE -> 450
      | IMPLICIT_P -> 451
      | IMPORT_P -> 452
      | IN_P -> 453
      | INCLUDE -> 454
      | INCLUDING -> 455
      | INCREMENT -> 456
      | INDEX -> 457
      | INDEXES -> 458
      | INHERIT -> 459
      | INHERITS -> 460
      | INITIALLY -> 461
      | INLINE_P -> 462
      | INNER_P -> 463
      | INOUT -> 464
      | INPUT_P -> 465
      | INSENSITIVE -> 466
      | INSERT -> 467
      | INSTEAD -> 468
      | INT_P -> 469
      | INTEGER -> 470
      | INTERSECT -> 471
      | INTERVAL -> 472
      | INTO -> 473
      | INVOKER -> 474
      | IS -> 475
      | ISNULL -> 476
      | ISOLATION -> 477
      | JOIN -> 478
      | KEY -> 479
      | LABEL -> 480
      | LANGUAGE -> 481
      | LARGE_P -> 482
      | LAST_P -> 483
      | LATERAL_P -> 484
      | LEADING -> 485
      | LEAKPROOF -> 486
      | LEAST -> 487
      | LEFT -> 488
      | LEVEL -> 489
      | LIKE -> 490
      | LIMIT -> 491
      | LISTEN -> 492
      | LOAD -> 493
      | LOCAL -> 494
      | LOCALTIME -> 495
      | LOCALTIMESTAMP -> 496
      | LOCATION -> 497
      | LOCK_P -> 498
      | LOCKED -> 499
      | LOGGED -> 500
      | MAPPING -> 501
      | MATCH -> 502
      | MATCHED -> 503
      | MATERIALIZED -> 504
      | MAXVALUE -> 505
      | MERGE -> 506
      | METHOD -> 507
      | MINUTE_P -> 508
      | MINVALUE -> 509
      | MODE -> 510
      | MONTH_P -> 511
      | MOVE -> 512
      | NAME_P -> 513
      | NAMES -> 514
      | NATIONAL -> 515
      | NATURAL -> 516
      | NCHAR -> 517
      | NEW -> 518
      | NEXT -> 519
      | NFC -> 520
      | NFD -> 521
      | NFKC -> 522
      | NFKD -> 523
      | NO -> 524
      | NONE -> 525
      | NORMALIZE -> 526
      | NORMALIZED -> 527
      | NOT -> 528
      | NOTHING -> 529
      | NOTIFY -> 530
      | NOTNULL -> 531
      | NOWAIT -> 532
      | NULL_P -> 533
      | NULLIF -> 534
      | NULLS_P -> 535
      | NUMERIC -> 536
      | OBJECT_P -> 537
      | OF -> 538
      | OFF -> 539
      | OFFSET -> 540
      | OIDS -> 541
      | OLD -> 542
      | ON -> 543
      | ONLY -> 544
      | OPERATOR -> 545
      | OPTION -> 546
      | OPTIONS -> 547
      | OR -> 548
      | ORDER -> 549
      | ORDINALITY -> 550
      | OTHERS -> 551
      | OUT_P -> 552
      | OUTER_P -> 553
      | OVER -> 554
      | OVERLAPS -> 555
      | OVERLAY -> 556
      | OVERRIDING -> 557
      | OWNED -> 558
      | OWNER -> 559
      | PARALLEL -> 560
      | PARAMETER -> 561
      | PARSER -> 562
      | PARTIAL -> 563
      | PARTITION -> 564
      | PASSING -> 565
      | PASSWORD -> 566
      | PLACING -> 567
      | PLANS -> 568
      | POLICY -> 569
      | POSITION -> 570
      | PRECEDING -> 571
      | PRECISION -> 572
      | PRESERVE -> 573
      | PREPARE -> 574
      | PREPARED -> 575
      | PRIMARY -> 576
      | PRIOR -> 577
      | PRIVILEGES -> 578
      | PROCEDURAL -> 579
      | PROCEDURE -> 580
      | PROCEDURES -> 581
      | PROGRAM -> 582
      | PUBLICATION -> 583
      | QUOTE -> 584
      | RANGE -> 585
      | READ -> 586
      | REAL -> 587
      | REASSIGN -> 588
      | RECHECK -> 589
      | RECURSIVE -> 590
      | REF_P -> 591
      | REFERENCES -> 592
      | REFERENCING -> 593
      | REFRESH -> 594
      | REINDEX -> 595
      | RELATIVE_P -> 596
      | RELEASE -> 597
      | RENAME -> 598
      | REPEATABLE -> 599
      | REPLACE -> 600
      | REPLICA -> 601
      | RESET -> 602
      | RESTART -> 603
      | RESTRICT -> 604
      | RETURN -> 605
      | RETURNING -> 606
      | RETURNS -> 607
      | REVOKE -> 608
      | RIGHT -> 609
      | ROLE -> 610
      | ROLLBACK -> 611
      | ROLLUP -> 612
      | ROUTINE -> 613
      | ROUTINES -> 614
      | ROW -> 615
      | ROWS -> 616
      | RULE -> 617
      | SAVEPOINT -> 618
      | SCHEMA -> 619
      | SCHEMAS -> 620
      | SCROLL -> 621
      | SEARCH -> 622
      | SECOND_P -> 623
      | SECURITY -> 624
      | SELECT -> 625
      | SEQUENCE -> 626
      | SEQUENCES -> 627
      | SERIALIZABLE -> 628
      | SERVER -> 629
      | SESSION -> 630
      | SESSION_USER -> 631
      | SET -> 632
      | SETS -> 633
      | SETOF -> 634
      | SHARE -> 635
      | SHOW -> 636
      | SIMILAR -> 637
      | SIMPLE -> 638
      | SKIP -> 639
      | SMALLINT -> 640
      | SNAPSHOT -> 641
      | SOME -> 642
      | SQL_P -> 643
      | STABLE -> 644
      | STANDALONE_P -> 645
      | START -> 646
      | STATEMENT -> 647
      | STATISTICS -> 648
      | STDIN -> 649
      | STDOUT -> 650
      | STORAGE -> 651
      | STORED -> 652
      | STRICT_P -> 653
      | STRIP_P -> 654
      | SUBSCRIPTION -> 655
      | SUBSTRING -> 656
      | SUPPORT -> 657
      | SYMMETRIC -> 658
      | SYSID -> 659
      | SYSTEM_P -> 660
      | TABLE -> 661
      | TABLES -> 662
      | TABLESAMPLE -> 663
      | TABLESPACE -> 664
      | TEMP -> 665
      | TEMPLATE -> 666
      | TEMPORARY -> 667
      | TEXT_P -> 668
      | THEN -> 669
      | TIES -> 670
      | TIME -> 671
      | TIMESTAMP -> 672
      | TO -> 673
      | TRAILING -> 674
      | TRANSACTION -> 675
      | TRANSFORM -> 676
      | TREAT -> 677
      | TRIGGER -> 678
      | TRIM -> 679
      | TRUE_P -> 680
      | TRUNCATE -> 681
      | TRUSTED -> 682
      | TYPE_P -> 683
      | TYPES_P -> 684
      | UESCAPE -> 685
      | UNBOUNDED -> 686
      | UNCOMMITTED -> 687
      | UNENCRYPTED -> 688
      | UNION -> 689
      | UNIQUE -> 690
      | UNKNOWN -> 691
      | UNLISTEN -> 692
      | UNLOGGED -> 693
      | UNTIL -> 694
      | UPDATE -> 695
      | USER -> 696
      | USING -> 697
      | VACUUM -> 698
      | VALID -> 699
      | VALIDATE -> 700
      | VALIDATOR -> 701
      | VALUE_P -> 702
      | VALUES -> 703
      | VARCHAR -> 704
      | VARIADIC -> 705
      | VARYING -> 706
      | VERBOSE -> 707
      | VERSION_P -> 708
      | VIEW -> 709
      | VIEWS -> 710
      | VOLATILE -> 711
      | WHEN -> 712
      | WHERE -> 713
      | WHITESPACE_P -> 714
      | WINDOW -> 715
      | WITH -> 716
      | WITHIN -> 717
      | WITHOUT -> 718
      | WORK -> 719
      | WRAPPER -> 720
      | WRITE -> 721
      | XML_P -> 722
      | XMLATTRIBUTES -> 723
      | XMLCONCAT -> 724
      | XMLELEMENT -> 725
      | XMLEXISTS -> 726
      | XMLFOREST -> 727
      | XMLNAMESPACES -> 728
      | XMLPARSE -> 729
      | XMLPI -> 730
      | XMLROOT -> 731
      | XMLSERIALIZE -> 732
      | XMLTABLE -> 733
      | YEAR_P -> 734
      | YES_P -> 735
      | ZONE -> 736
      | NOT_LA -> 737
      | NULLS_LA -> 738
      | WITH_LA -> 739
      | MODE_TYPE_NAME -> 740
      | MODE_PLPGSQL_EXPR -> 741
      | MODE_PLPGSQL_ASSIGN1 -> 742
      | MODE_PLPGSQL_ASSIGN2 -> 743
      | MODE_PLPGSQL_ASSIGN3 -> 744
      | UMINUS -> 745
    
    let from_int = function
      | 0 -> Ok NUL
      | 37 -> Ok ASCII_37
      | 40 -> Ok ASCII_40
      | 41 -> Ok ASCII_41
      | 42 -> Ok ASCII_42
      | 43 -> Ok ASCII_43
      | 44 -> Ok ASCII_44
      | 45 -> Ok ASCII_45
      | 46 -> Ok ASCII_46
      | 47 -> Ok ASCII_47
      | 58 -> Ok ASCII_58
      | 59 -> Ok ASCII_59
      | 60 -> Ok ASCII_60
      | 61 -> Ok ASCII_61
      | 62 -> Ok ASCII_62
      | 63 -> Ok ASCII_63
      | 91 -> Ok ASCII_91
      | 92 -> Ok ASCII_92
      | 93 -> Ok ASCII_93
      | 94 -> Ok ASCII_94
      | 258 -> Ok IDENT
      | 259 -> Ok UIDENT
      | 260 -> Ok FCONST
      | 261 -> Ok SCONST
      | 262 -> Ok USCONST
      | 263 -> Ok BCONST
      | 264 -> Ok XCONST
      | 265 -> Ok Op
      | 266 -> Ok ICONST
      | 267 -> Ok PARAM
      | 268 -> Ok TYPECAST
      | 269 -> Ok DOT_DOT
      | 270 -> Ok COLON_EQUALS
      | 271 -> Ok EQUALS_GREATER
      | 272 -> Ok LESS_EQUALS
      | 273 -> Ok GREATER_EQUALS
      | 274 -> Ok NOT_EQUALS
      | 275 -> Ok SQL_COMMENT
      | 276 -> Ok C_COMMENT
      | 277 -> Ok ABORT_P
      | 278 -> Ok ABSOLUTE_P
      | 279 -> Ok ACCESS
      | 280 -> Ok ACTION
      | 281 -> Ok ADD_P
      | 282 -> Ok ADMIN
      | 283 -> Ok AFTER
      | 284 -> Ok AGGREGATE
      | 285 -> Ok ALL
      | 286 -> Ok ALSO
      | 287 -> Ok ALTER
      | 288 -> Ok ALWAYS
      | 289 -> Ok ANALYSE
      | 290 -> Ok ANALYZE
      | 291 -> Ok AND
      | 292 -> Ok ANY
      | 293 -> Ok ARRAY
      | 294 -> Ok AS
      | 295 -> Ok ASC
      | 296 -> Ok ASENSITIVE
      | 297 -> Ok ASSERTION
      | 298 -> Ok ASSIGNMENT
      | 299 -> Ok ASYMMETRIC
      | 300 -> Ok ATOMIC
      | 301 -> Ok AT
      | 302 -> Ok ATTACH
      | 303 -> Ok ATTRIBUTE
      | 304 -> Ok AUTHORIZATION
      | 305 -> Ok BACKWARD
      | 306 -> Ok BEFORE
      | 307 -> Ok BEGIN_P
      | 308 -> Ok BETWEEN
      | 309 -> Ok BIGINT
      | 310 -> Ok BINARY
      | 311 -> Ok BIT
      | 312 -> Ok BOOLEAN_P
      | 313 -> Ok BOTH
      | 314 -> Ok BREADTH
      | 315 -> Ok BY
      | 316 -> Ok CACHE
      | 317 -> Ok CALL
      | 318 -> Ok CALLED
      | 319 -> Ok CASCADE
      | 320 -> Ok CASCADED
      | 321 -> Ok CASE
      | 322 -> Ok CAST
      | 323 -> Ok CATALOG_P
      | 324 -> Ok CHAIN
      | 325 -> Ok CHAR_P
      | 326 -> Ok CHARACTER
      | 327 -> Ok CHARACTERISTICS
      | 328 -> Ok CHECK
      | 329 -> Ok CHECKPOINT
      | 330 -> Ok CLASS
      | 331 -> Ok CLOSE
      | 332 -> Ok CLUSTER
      | 333 -> Ok COALESCE
      | 334 -> Ok COLLATE
      | 335 -> Ok COLLATION
      | 336 -> Ok COLUMN
      | 337 -> Ok COLUMNS
      | 338 -> Ok COMMENT
      | 339 -> Ok COMMENTS
      | 340 -> Ok COMMIT
      | 341 -> Ok COMMITTED
      | 342 -> Ok COMPRESSION
      | 343 -> Ok CONCURRENTLY
      | 344 -> Ok CONFIGURATION
      | 345 -> Ok CONFLICT
      | 346 -> Ok CONNECTION
      | 347 -> Ok CONSTRAINT
      | 348 -> Ok CONSTRAINTS
      | 349 -> Ok CONTENT_P
      | 350 -> Ok CONTINUE_P
      | 351 -> Ok CONVERSION_P
      | 352 -> Ok COPY
      | 353 -> Ok COST
      | 354 -> Ok CREATE
      | 355 -> Ok CROSS
      | 356 -> Ok CSV
      | 357 -> Ok CUBE
      | 358 -> Ok CURRENT_P
      | 359 -> Ok CURRENT_CATALOG
      | 360 -> Ok CURRENT_DATE
      | 361 -> Ok CURRENT_ROLE
      | 362 -> Ok CURRENT_SCHEMA
      | 363 -> Ok CURRENT_TIME
      | 364 -> Ok CURRENT_TIMESTAMP
      | 365 -> Ok CURRENT_USER
      | 366 -> Ok CURSOR
      | 367 -> Ok CYCLE
      | 368 -> Ok DATA_P
      | 369 -> Ok DATABASE
      | 370 -> Ok DAY_P
      | 371 -> Ok DEALLOCATE
      | 372 -> Ok DEC
      | 373 -> Ok DECIMAL_P
      | 374 -> Ok DECLARE
      | 375 -> Ok DEFAULT
      | 376 -> Ok DEFAULTS
      | 377 -> Ok DEFERRABLE
      | 378 -> Ok DEFERRED
      | 379 -> Ok DEFINER
      | 380 -> Ok DELETE_P
      | 381 -> Ok DELIMITER
      | 382 -> Ok DELIMITERS
      | 383 -> Ok DEPENDS
      | 384 -> Ok DEPTH
      | 385 -> Ok DESC
      | 386 -> Ok DETACH
      | 387 -> Ok DICTIONARY
      | 388 -> Ok DISABLE_P
      | 389 -> Ok DISCARD
      | 390 -> Ok DISTINCT
      | 391 -> Ok DO
      | 392 -> Ok DOCUMENT_P
      | 393 -> Ok DOMAIN_P
      | 394 -> Ok DOUBLE_P
      | 395 -> Ok DROP
      | 396 -> Ok EACH
      | 397 -> Ok ELSE
      | 398 -> Ok ENABLE_P
      | 399 -> Ok ENCODING
      | 400 -> Ok ENCRYPTED
      | 401 -> Ok END_P
      | 402 -> Ok ENUM_P
      | 403 -> Ok ESCAPE
      | 404 -> Ok EVENT
      | 405 -> Ok EXCEPT
      | 406 -> Ok EXCLUDE
      | 407 -> Ok EXCLUDING
      | 408 -> Ok EXCLUSIVE
      | 409 -> Ok EXECUTE
      | 410 -> Ok EXISTS
      | 411 -> Ok EXPLAIN
      | 412 -> Ok EXPRESSION
      | 413 -> Ok EXTENSION
      | 414 -> Ok EXTERNAL
      | 415 -> Ok EXTRACT
      | 416 -> Ok FALSE_P
      | 417 -> Ok FAMILY
      | 418 -> Ok FETCH
      | 419 -> Ok FILTER
      | 420 -> Ok FINALIZE
      | 421 -> Ok FIRST_P
      | 422 -> Ok FLOAT_P
      | 423 -> Ok FOLLOWING
      | 424 -> Ok FOR
      | 425 -> Ok FORCE
      | 426 -> Ok FOREIGN
      | 427 -> Ok FORWARD
      | 428 -> Ok FREEZE
      | 429 -> Ok FROM
      | 430 -> Ok FULL
      | 431 -> Ok FUNCTION
      | 432 -> Ok FUNCTIONS
      | 433 -> Ok GENERATED
      | 434 -> Ok GLOBAL
      | 435 -> Ok GRANT
      | 436 -> Ok GRANTED
      | 437 -> Ok GREATEST
      | 438 -> Ok GROUP_P
      | 439 -> Ok GROUPING
      | 440 -> Ok GROUPS
      | 441 -> Ok HANDLER
      | 442 -> Ok HAVING
      | 443 -> Ok HEADER_P
      | 444 -> Ok HOLD
      | 445 -> Ok HOUR_P
      | 446 -> Ok IDENTITY_P
      | 447 -> Ok IF_P
      | 448 -> Ok ILIKE
      | 449 -> Ok IMMEDIATE
      | 450 -> Ok IMMUTABLE
      | 451 -> Ok IMPLICIT_P
      | 452 -> Ok IMPORT_P
      | 453 -> Ok IN_P
      | 454 -> Ok INCLUDE
      | 455 -> Ok INCLUDING
      | 456 -> Ok INCREMENT
      | 457 -> Ok INDEX
      | 458 -> Ok INDEXES
      | 459 -> Ok INHERIT
      | 460 -> Ok INHERITS
      | 461 -> Ok INITIALLY
      | 462 -> Ok INLINE_P
      | 463 -> Ok INNER_P
      | 464 -> Ok INOUT
      | 465 -> Ok INPUT_P
      | 466 -> Ok INSENSITIVE
      | 467 -> Ok INSERT
      | 468 -> Ok INSTEAD
      | 469 -> Ok INT_P
      | 470 -> Ok INTEGER
      | 471 -> Ok INTERSECT
      | 472 -> Ok INTERVAL
      | 473 -> Ok INTO
      | 474 -> Ok INVOKER
      | 475 -> Ok IS
      | 476 -> Ok ISNULL
      | 477 -> Ok ISOLATION
      | 478 -> Ok JOIN
      | 479 -> Ok KEY
      | 480 -> Ok LABEL
      | 481 -> Ok LANGUAGE
      | 482 -> Ok LARGE_P
      | 483 -> Ok LAST_P
      | 484 -> Ok LATERAL_P
      | 485 -> Ok LEADING
      | 486 -> Ok LEAKPROOF
      | 487 -> Ok LEAST
      | 488 -> Ok LEFT
      | 489 -> Ok LEVEL
      | 490 -> Ok LIKE
      | 491 -> Ok LIMIT
      | 492 -> Ok LISTEN
      | 493 -> Ok LOAD
      | 494 -> Ok LOCAL
      | 495 -> Ok LOCALTIME
      | 496 -> Ok LOCALTIMESTAMP
      | 497 -> Ok LOCATION
      | 498 -> Ok LOCK_P
      | 499 -> Ok LOCKED
      | 500 -> Ok LOGGED
      | 501 -> Ok MAPPING
      | 502 -> Ok MATCH
      | 503 -> Ok MATCHED
      | 504 -> Ok MATERIALIZED
      | 505 -> Ok MAXVALUE
      | 506 -> Ok MERGE
      | 507 -> Ok METHOD
      | 508 -> Ok MINUTE_P
      | 509 -> Ok MINVALUE
      | 510 -> Ok MODE
      | 511 -> Ok MONTH_P
      | 512 -> Ok MOVE
      | 513 -> Ok NAME_P
      | 514 -> Ok NAMES
      | 515 -> Ok NATIONAL
      | 516 -> Ok NATURAL
      | 517 -> Ok NCHAR
      | 518 -> Ok NEW
      | 519 -> Ok NEXT
      | 520 -> Ok NFC
      | 521 -> Ok NFD
      | 522 -> Ok NFKC
      | 523 -> Ok NFKD
      | 524 -> Ok NO
      | 525 -> Ok NONE
      | 526 -> Ok NORMALIZE
      | 527 -> Ok NORMALIZED
      | 528 -> Ok NOT
      | 529 -> Ok NOTHING
      | 530 -> Ok NOTIFY
      | 531 -> Ok NOTNULL
      | 532 -> Ok NOWAIT
      | 533 -> Ok NULL_P
      | 534 -> Ok NULLIF
      | 535 -> Ok NULLS_P
      | 536 -> Ok NUMERIC
      | 537 -> Ok OBJECT_P
      | 538 -> Ok OF
      | 539 -> Ok OFF
      | 540 -> Ok OFFSET
      | 541 -> Ok OIDS
      | 542 -> Ok OLD
      | 543 -> Ok ON
      | 544 -> Ok ONLY
      | 545 -> Ok OPERATOR
      | 546 -> Ok OPTION
      | 547 -> Ok OPTIONS
      | 548 -> Ok OR
      | 549 -> Ok ORDER
      | 550 -> Ok ORDINALITY
      | 551 -> Ok OTHERS
      | 552 -> Ok OUT_P
      | 553 -> Ok OUTER_P
      | 554 -> Ok OVER
      | 555 -> Ok OVERLAPS
      | 556 -> Ok OVERLAY
      | 557 -> Ok OVERRIDING
      | 558 -> Ok OWNED
      | 559 -> Ok OWNER
      | 560 -> Ok PARALLEL
      | 561 -> Ok PARAMETER
      | 562 -> Ok PARSER
      | 563 -> Ok PARTIAL
      | 564 -> Ok PARTITION
      | 565 -> Ok PASSING
      | 566 -> Ok PASSWORD
      | 567 -> Ok PLACING
      | 568 -> Ok PLANS
      | 569 -> Ok POLICY
      | 570 -> Ok POSITION
      | 571 -> Ok PRECEDING
      | 572 -> Ok PRECISION
      | 573 -> Ok PRESERVE
      | 574 -> Ok PREPARE
      | 575 -> Ok PREPARED
      | 576 -> Ok PRIMARY
      | 577 -> Ok PRIOR
      | 578 -> Ok PRIVILEGES
      | 579 -> Ok PROCEDURAL
      | 580 -> Ok PROCEDURE
      | 581 -> Ok PROCEDURES
      | 582 -> Ok PROGRAM
      | 583 -> Ok PUBLICATION
      | 584 -> Ok QUOTE
      | 585 -> Ok RANGE
      | 586 -> Ok READ
      | 587 -> Ok REAL
      | 588 -> Ok REASSIGN
      | 589 -> Ok RECHECK
      | 590 -> Ok RECURSIVE
      | 591 -> Ok REF_P
      | 592 -> Ok REFERENCES
      | 593 -> Ok REFERENCING
      | 594 -> Ok REFRESH
      | 595 -> Ok REINDEX
      | 596 -> Ok RELATIVE_P
      | 597 -> Ok RELEASE
      | 598 -> Ok RENAME
      | 599 -> Ok REPEATABLE
      | 600 -> Ok REPLACE
      | 601 -> Ok REPLICA
      | 602 -> Ok RESET
      | 603 -> Ok RESTART
      | 604 -> Ok RESTRICT
      | 605 -> Ok RETURN
      | 606 -> Ok RETURNING
      | 607 -> Ok RETURNS
      | 608 -> Ok REVOKE
      | 609 -> Ok RIGHT
      | 610 -> Ok ROLE
      | 611 -> Ok ROLLBACK
      | 612 -> Ok ROLLUP
      | 613 -> Ok ROUTINE
      | 614 -> Ok ROUTINES
      | 615 -> Ok ROW
      | 616 -> Ok ROWS
      | 617 -> Ok RULE
      | 618 -> Ok SAVEPOINT
      | 619 -> Ok SCHEMA
      | 620 -> Ok SCHEMAS
      | 621 -> Ok SCROLL
      | 622 -> Ok SEARCH
      | 623 -> Ok SECOND_P
      | 624 -> Ok SECURITY
      | 625 -> Ok SELECT
      | 626 -> Ok SEQUENCE
      | 627 -> Ok SEQUENCES
      | 628 -> Ok SERIALIZABLE
      | 629 -> Ok SERVER
      | 630 -> Ok SESSION
      | 631 -> Ok SESSION_USER
      | 632 -> Ok SET
      | 633 -> Ok SETS
      | 634 -> Ok SETOF
      | 635 -> Ok SHARE
      | 636 -> Ok SHOW
      | 637 -> Ok SIMILAR
      | 638 -> Ok SIMPLE
      | 639 -> Ok SKIP
      | 640 -> Ok SMALLINT
      | 641 -> Ok SNAPSHOT
      | 642 -> Ok SOME
      | 643 -> Ok SQL_P
      | 644 -> Ok STABLE
      | 645 -> Ok STANDALONE_P
      | 646 -> Ok START
      | 647 -> Ok STATEMENT
      | 648 -> Ok STATISTICS
      | 649 -> Ok STDIN
      | 650 -> Ok STDOUT
      | 651 -> Ok STORAGE
      | 652 -> Ok STORED
      | 653 -> Ok STRICT_P
      | 654 -> Ok STRIP_P
      | 655 -> Ok SUBSCRIPTION
      | 656 -> Ok SUBSTRING
      | 657 -> Ok SUPPORT
      | 658 -> Ok SYMMETRIC
      | 659 -> Ok SYSID
      | 660 -> Ok SYSTEM_P
      | 661 -> Ok TABLE
      | 662 -> Ok TABLES
      | 663 -> Ok TABLESAMPLE
      | 664 -> Ok TABLESPACE
      | 665 -> Ok TEMP
      | 666 -> Ok TEMPLATE
      | 667 -> Ok TEMPORARY
      | 668 -> Ok TEXT_P
      | 669 -> Ok THEN
      | 670 -> Ok TIES
      | 671 -> Ok TIME
      | 672 -> Ok TIMESTAMP
      | 673 -> Ok TO
      | 674 -> Ok TRAILING
      | 675 -> Ok TRANSACTION
      | 676 -> Ok TRANSFORM
      | 677 -> Ok TREAT
      | 678 -> Ok TRIGGER
      | 679 -> Ok TRIM
      | 680 -> Ok TRUE_P
      | 681 -> Ok TRUNCATE
      | 682 -> Ok TRUSTED
      | 683 -> Ok TYPE_P
      | 684 -> Ok TYPES_P
      | 685 -> Ok UESCAPE
      | 686 -> Ok UNBOUNDED
      | 687 -> Ok UNCOMMITTED
      | 688 -> Ok UNENCRYPTED
      | 689 -> Ok UNION
      | 690 -> Ok UNIQUE
      | 691 -> Ok UNKNOWN
      | 692 -> Ok UNLISTEN
      | 693 -> Ok UNLOGGED
      | 694 -> Ok UNTIL
      | 695 -> Ok UPDATE
      | 696 -> Ok USER
      | 697 -> Ok USING
      | 698 -> Ok VACUUM
      | 699 -> Ok VALID
      | 700 -> Ok VALIDATE
      | 701 -> Ok VALIDATOR
      | 702 -> Ok VALUE_P
      | 703 -> Ok VALUES
      | 704 -> Ok VARCHAR
      | 705 -> Ok VARIADIC
      | 706 -> Ok VARYING
      | 707 -> Ok VERBOSE
      | 708 -> Ok VERSION_P
      | 709 -> Ok VIEW
      | 710 -> Ok VIEWS
      | 711 -> Ok VOLATILE
      | 712 -> Ok WHEN
      | 713 -> Ok WHERE
      | 714 -> Ok WHITESPACE_P
      | 715 -> Ok WINDOW
      | 716 -> Ok WITH
      | 717 -> Ok WITHIN
      | 718 -> Ok WITHOUT
      | 719 -> Ok WORK
      | 720 -> Ok WRAPPER
      | 721 -> Ok WRITE
      | 722 -> Ok XML_P
      | 723 -> Ok XMLATTRIBUTES
      | 724 -> Ok XMLCONCAT
      | 725 -> Ok XMLELEMENT
      | 726 -> Ok XMLEXISTS
      | 727 -> Ok XMLFOREST
      | 728 -> Ok XMLNAMESPACES
      | 729 -> Ok XMLPARSE
      | 730 -> Ok XMLPI
      | 731 -> Ok XMLROOT
      | 732 -> Ok XMLSERIALIZE
      | 733 -> Ok XMLTABLE
      | 734 -> Ok YEAR_P
      | 735 -> Ok YES_P
      | 736 -> Ok ZONE
      | 737 -> Ok NOT_LA
      | 738 -> Ok NULLS_LA
      | 739 -> Ok WITH_LA
      | 740 -> Ok MODE_TYPE_NAME
      | 741 -> Ok MODE_PLPGSQL_EXPR
      | 742 -> Ok MODE_PLPGSQL_ASSIGN1
      | 743 -> Ok MODE_PLPGSQL_ASSIGN2
      | 744 -> Ok MODE_PLPGSQL_ASSIGN3
      | 745 -> Ok UMINUS
      | n -> Error (`Unknown_enum_value n)
    
  end
  and ParseResult : sig
    val name': unit -> string
    type t = { version: int; stmts: RawStmt.t list } 
    val make : ?version:int -> ?stmts:RawStmt.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ParseResult"
    type t = { version: int; stmts: RawStmt.t list }
    let make =
      fun ?version ?stmts () -> 
      let version = match version with Some v -> v | None -> 0 in
      let stmts = match stmts with Some v -> v | None -> [] in
      { version; stmts }
    
    let to_proto =
      let apply = fun ~f:f' { version; stmts } -> f' [] version stmts in
      let spec = Runtime'.Serialize.C.( basic (1, int32_int, proto3) ^:: repeated (2, (message (fun t -> RawStmt.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions version stmts -> { version; stmts } in
      let spec = Runtime'.Deserialize.C.( basic (1, int32_int, proto3) ^:: repeated (2, (message (fun t -> RawStmt.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ScanResult : sig
    val name': unit -> string
    type t = { version: int; tokens: ScanToken.t list } 
    val make : ?version:int -> ?tokens:ScanToken.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ScanResult"
    type t = { version: int; tokens: ScanToken.t list }
    let make =
      fun ?version ?tokens () -> 
      let version = match version with Some v -> v | None -> 0 in
      let tokens = match tokens with Some v -> v | None -> [] in
      { version; tokens }
    
    let to_proto =
      let apply = fun ~f:f' { version; tokens } -> f' [] version tokens in
      let spec = Runtime'.Serialize.C.( basic (1, int32_int, proto3) ^:: repeated (2, (message (fun t -> ScanToken.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions version tokens -> { version; tokens } in
      let spec = Runtime'.Deserialize.C.( basic (1, int32_int, proto3) ^:: repeated (2, (message (fun t -> ScanToken.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Node : sig
    val name': unit -> string
    type t = [ `not_set | `Alias of Alias.t | `Range_var of RangeVar.t | `Table_func of TableFunc.t | `Var of Var.t | `Param of Param.t | `Aggref of Aggref.t | `Grouping_func of GroupingFunc.t | `Window_func of WindowFunc.t | `Subscripting_ref of SubscriptingRef.t | `Func_expr of FuncExpr.t | `Named_arg_expr of NamedArgExpr.t | `Op_expr of OpExpr.t | `Distinct_expr of DistinctExpr.t | `Null_if_expr of NullIfExpr.t | `Scalar_array_op_expr of ScalarArrayOpExpr.t | `Bool_expr of BoolExpr.t | `Sub_link of SubLink.t | `Sub_plan of SubPlan.t | `Alternative_sub_plan of AlternativeSubPlan.t | `Field_select of FieldSelect.t | `Field_store of FieldStore.t | `Relabel_type of RelabelType.t | `Coerce_via_io of CoerceViaIO.t | `Array_coerce_expr of ArrayCoerceExpr.t | `Convert_rowtype_expr of ConvertRowtypeExpr.t | `Collate_expr of CollateExpr.t | `Case_expr of CaseExpr.t | `Case_when of CaseWhen.t | `Case_test_expr of CaseTestExpr.t | `Array_expr of ArrayExpr.t | `Row_expr of RowExpr.t | `Row_compare_expr of RowCompareExpr.t | `Coalesce_expr of CoalesceExpr.t | `Min_max_expr of MinMaxExpr.t | `Sqlvalue_function of SQLValueFunction.t | `Xml_expr of XmlExpr.t | `Null_test of NullTest.t | `Boolean_test of BooleanTest.t | `Coerce_to_domain of CoerceToDomain.t | `Coerce_to_domain_value of CoerceToDomainValue.t | `Set_to_default of SetToDefault.t | `Current_of_expr of CurrentOfExpr.t | `Next_value_expr of NextValueExpr.t | `Inference_elem of InferenceElem.t | `Target_entry of TargetEntry.t | `Range_tbl_ref of RangeTblRef.t | `Join_expr of JoinExpr.t | `From_expr of FromExpr.t | `On_conflict_expr of OnConflictExpr.t | `Into_clause of IntoClause.t | `Merge_action of MergeAction.t | `Raw_stmt of RawStmt.t | `Query of Query.t | `Insert_stmt of InsertStmt.t | `Delete_stmt of DeleteStmt.t | `Update_stmt of UpdateStmt.t | `Merge_stmt of MergeStmt.t | `Select_stmt of SelectStmt.t | `Return_stmt of ReturnStmt.t | `Plassign_stmt of PLAssignStmt.t | `Alter_table_stmt of AlterTableStmt.t | `Alter_table_cmd of AlterTableCmd.t | `Alter_domain_stmt of AlterDomainStmt.t | `Set_operation_stmt of SetOperationStmt.t | `Grant_stmt of GrantStmt.t | `Grant_role_stmt of GrantRoleStmt.t | `Alter_default_privileges_stmt of AlterDefaultPrivilegesStmt.t | `Close_portal_stmt of ClosePortalStmt.t | `Cluster_stmt of ClusterStmt.t | `Copy_stmt of CopyStmt.t | `Create_stmt of CreateStmt.t | `Define_stmt of DefineStmt.t | `Drop_stmt of DropStmt.t | `Truncate_stmt of TruncateStmt.t | `Comment_stmt of CommentStmt.t | `Fetch_stmt of FetchStmt.t | `Index_stmt of IndexStmt.t | `Create_function_stmt of CreateFunctionStmt.t | `Alter_function_stmt of AlterFunctionStmt.t | `Do_stmt of DoStmt.t | `Rename_stmt of RenameStmt.t | `Rule_stmt of RuleStmt.t | `Notify_stmt of NotifyStmt.t | `Listen_stmt of ListenStmt.t | `Unlisten_stmt of UnlistenStmt.t | `Transaction_stmt of TransactionStmt.t | `View_stmt of ViewStmt.t | `Load_stmt of LoadStmt.t | `Create_domain_stmt of CreateDomainStmt.t | `Createdb_stmt of CreatedbStmt.t | `Dropdb_stmt of DropdbStmt.t | `Vacuum_stmt of VacuumStmt.t | `Explain_stmt of ExplainStmt.t | `Create_table_as_stmt of CreateTableAsStmt.t | `Create_seq_stmt of CreateSeqStmt.t | `Alter_seq_stmt of AlterSeqStmt.t | `Variable_set_stmt of VariableSetStmt.t | `Variable_show_stmt of VariableShowStmt.t | `Discard_stmt of DiscardStmt.t | `Create_trig_stmt of CreateTrigStmt.t | `Create_plang_stmt of CreatePLangStmt.t | `Create_role_stmt of CreateRoleStmt.t | `Alter_role_stmt of AlterRoleStmt.t | `Drop_role_stmt of DropRoleStmt.t | `Lock_stmt of LockStmt.t | `Constraints_set_stmt of ConstraintsSetStmt.t | `Reindex_stmt of ReindexStmt.t | `Check_point_stmt of CheckPointStmt.t | `Create_schema_stmt of CreateSchemaStmt.t | `Alter_database_stmt of AlterDatabaseStmt.t | `Alter_database_refresh_coll_stmt of AlterDatabaseRefreshCollStmt.t | `Alter_database_set_stmt of AlterDatabaseSetStmt.t | `Alter_role_set_stmt of AlterRoleSetStmt.t | `Create_conversion_stmt of CreateConversionStmt.t | `Create_cast_stmt of CreateCastStmt.t | `Create_op_class_stmt of CreateOpClassStmt.t | `Create_op_family_stmt of CreateOpFamilyStmt.t | `Alter_op_family_stmt of AlterOpFamilyStmt.t | `Prepare_stmt of PrepareStmt.t | `Execute_stmt of ExecuteStmt.t | `Deallocate_stmt of DeallocateStmt.t | `Declare_cursor_stmt of DeclareCursorStmt.t | `Create_table_space_stmt of CreateTableSpaceStmt.t | `Drop_table_space_stmt of DropTableSpaceStmt.t | `Alter_object_depends_stmt of AlterObjectDependsStmt.t | `Alter_object_schema_stmt of AlterObjectSchemaStmt.t | `Alter_owner_stmt of AlterOwnerStmt.t | `Alter_operator_stmt of AlterOperatorStmt.t | `Alter_type_stmt of AlterTypeStmt.t | `Drop_owned_stmt of DropOwnedStmt.t | `Reassign_owned_stmt of ReassignOwnedStmt.t | `Composite_type_stmt of CompositeTypeStmt.t | `Create_enum_stmt of CreateEnumStmt.t | `Create_range_stmt of CreateRangeStmt.t | `Alter_enum_stmt of AlterEnumStmt.t | `Alter_tsdictionary_stmt of AlterTSDictionaryStmt.t | `Alter_tsconfiguration_stmt of AlterTSConfigurationStmt.t | `Create_fdw_stmt of CreateFdwStmt.t | `Alter_fdw_stmt of AlterFdwStmt.t | `Create_foreign_server_stmt of CreateForeignServerStmt.t | `Alter_foreign_server_stmt of AlterForeignServerStmt.t | `Create_user_mapping_stmt of CreateUserMappingStmt.t | `Alter_user_mapping_stmt of AlterUserMappingStmt.t | `Drop_user_mapping_stmt of DropUserMappingStmt.t | `Alter_table_space_options_stmt of AlterTableSpaceOptionsStmt.t | `Alter_table_move_all_stmt of AlterTableMoveAllStmt.t | `Sec_label_stmt of SecLabelStmt.t | `Create_foreign_table_stmt of CreateForeignTableStmt.t | `Import_foreign_schema_stmt of ImportForeignSchemaStmt.t | `Create_extension_stmt of CreateExtensionStmt.t | `Alter_extension_stmt of AlterExtensionStmt.t | `Alter_extension_contents_stmt of AlterExtensionContentsStmt.t | `Create_event_trig_stmt of CreateEventTrigStmt.t | `Alter_event_trig_stmt of AlterEventTrigStmt.t | `Refresh_mat_view_stmt of RefreshMatViewStmt.t | `Replica_identity_stmt of ReplicaIdentityStmt.t | `Alter_system_stmt of AlterSystemStmt.t | `Create_policy_stmt of CreatePolicyStmt.t | `Alter_policy_stmt of AlterPolicyStmt.t | `Create_transform_stmt of CreateTransformStmt.t | `Create_am_stmt of CreateAmStmt.t | `Create_publication_stmt of CreatePublicationStmt.t | `Alter_publication_stmt of AlterPublicationStmt.t | `Create_subscription_stmt of CreateSubscriptionStmt.t | `Alter_subscription_stmt of AlterSubscriptionStmt.t | `Drop_subscription_stmt of DropSubscriptionStmt.t | `Create_stats_stmt of CreateStatsStmt.t | `Alter_collation_stmt of AlterCollationStmt.t | `Call_stmt of CallStmt.t | `Alter_stats_stmt of AlterStatsStmt.t | `A_expr of A_Expr.t | `Column_ref of ColumnRef.t | `Param_ref of ParamRef.t | `Func_call of FuncCall.t | `A_star of A_Star.t | `A_indices of A_Indices.t | `A_indirection of A_Indirection.t | `A_array_expr of A_ArrayExpr.t | `Res_target of ResTarget.t | `Multi_assign_ref of MultiAssignRef.t | `Type_cast of TypeCast.t | `Collate_clause of CollateClause.t | `Sort_by of SortBy.t | `Window_def of WindowDef.t | `Range_subselect of RangeSubselect.t | `Range_function of RangeFunction.t | `Range_table_sample of RangeTableSample.t | `Range_table_func of RangeTableFunc.t | `Range_table_func_col of RangeTableFuncCol.t | `Type_name of TypeName.t | `Column_def of ColumnDef.t | `Index_elem of IndexElem.t | `Stats_elem of StatsElem.t | `Constraint of Constraint.t | `Def_elem of DefElem.t | `Range_tbl_entry of RangeTblEntry.t | `Range_tbl_function of RangeTblFunction.t | `Table_sample_clause of TableSampleClause.t | `With_check_option of WithCheckOption.t | `Sort_group_clause of SortGroupClause.t | `Grouping_set of GroupingSet.t | `Window_clause of WindowClause.t | `Object_with_args of ObjectWithArgs.t | `Access_priv of AccessPriv.t | `Create_op_class_item of CreateOpClassItem.t | `Table_like_clause of TableLikeClause.t | `Function_parameter of FunctionParameter.t | `Locking_clause of LockingClause.t | `Row_mark_clause of RowMarkClause.t | `Xml_serialize of XmlSerialize.t | `With_clause of WithClause.t | `Infer_clause of InferClause.t | `On_conflict_clause of OnConflictClause.t | `Ctesearch_clause of CTESearchClause.t | `Ctecycle_clause of CTECycleClause.t | `Common_table_expr of CommonTableExpr.t | `Merge_when_clause of MergeWhenClause.t | `Role_spec of RoleSpec.t | `Trigger_transition of TriggerTransition.t | `Partition_elem of PartitionElem.t | `Partition_spec of PartitionSpec.t | `Partition_bound_spec of PartitionBoundSpec.t | `Partition_range_datum of PartitionRangeDatum.t | `Partition_cmd of PartitionCmd.t | `Vacuum_relation of VacuumRelation.t | `Publication_obj_spec of PublicationObjSpec.t | `Publication_table of PublicationTable.t | `Inline_code_block of InlineCodeBlock.t | `Call_context of CallContext.t | `Integer of Integer.t | `Float of Float.t | `Boolean of Boolean.t | `String of String.t | `Bit_string of BitString.t | `List of List.t | `Int_list of IntList.t | `Oid_list of OidList.t | `A_const of A_Const.t ] 
    val make : ?node:[ `not_set | `Alias of Alias.t | `Range_var of RangeVar.t | `Table_func of TableFunc.t | `Var of Var.t | `Param of Param.t | `Aggref of Aggref.t | `Grouping_func of GroupingFunc.t | `Window_func of WindowFunc.t | `Subscripting_ref of SubscriptingRef.t | `Func_expr of FuncExpr.t | `Named_arg_expr of NamedArgExpr.t | `Op_expr of OpExpr.t | `Distinct_expr of DistinctExpr.t | `Null_if_expr of NullIfExpr.t | `Scalar_array_op_expr of ScalarArrayOpExpr.t | `Bool_expr of BoolExpr.t | `Sub_link of SubLink.t | `Sub_plan of SubPlan.t | `Alternative_sub_plan of AlternativeSubPlan.t | `Field_select of FieldSelect.t | `Field_store of FieldStore.t | `Relabel_type of RelabelType.t | `Coerce_via_io of CoerceViaIO.t | `Array_coerce_expr of ArrayCoerceExpr.t | `Convert_rowtype_expr of ConvertRowtypeExpr.t | `Collate_expr of CollateExpr.t | `Case_expr of CaseExpr.t | `Case_when of CaseWhen.t | `Case_test_expr of CaseTestExpr.t | `Array_expr of ArrayExpr.t | `Row_expr of RowExpr.t | `Row_compare_expr of RowCompareExpr.t | `Coalesce_expr of CoalesceExpr.t | `Min_max_expr of MinMaxExpr.t | `Sqlvalue_function of SQLValueFunction.t | `Xml_expr of XmlExpr.t | `Null_test of NullTest.t | `Boolean_test of BooleanTest.t | `Coerce_to_domain of CoerceToDomain.t | `Coerce_to_domain_value of CoerceToDomainValue.t | `Set_to_default of SetToDefault.t | `Current_of_expr of CurrentOfExpr.t | `Next_value_expr of NextValueExpr.t | `Inference_elem of InferenceElem.t | `Target_entry of TargetEntry.t | `Range_tbl_ref of RangeTblRef.t | `Join_expr of JoinExpr.t | `From_expr of FromExpr.t | `On_conflict_expr of OnConflictExpr.t | `Into_clause of IntoClause.t | `Merge_action of MergeAction.t | `Raw_stmt of RawStmt.t | `Query of Query.t | `Insert_stmt of InsertStmt.t | `Delete_stmt of DeleteStmt.t | `Update_stmt of UpdateStmt.t | `Merge_stmt of MergeStmt.t | `Select_stmt of SelectStmt.t | `Return_stmt of ReturnStmt.t | `Plassign_stmt of PLAssignStmt.t | `Alter_table_stmt of AlterTableStmt.t | `Alter_table_cmd of AlterTableCmd.t | `Alter_domain_stmt of AlterDomainStmt.t | `Set_operation_stmt of SetOperationStmt.t | `Grant_stmt of GrantStmt.t | `Grant_role_stmt of GrantRoleStmt.t | `Alter_default_privileges_stmt of AlterDefaultPrivilegesStmt.t | `Close_portal_stmt of ClosePortalStmt.t | `Cluster_stmt of ClusterStmt.t | `Copy_stmt of CopyStmt.t | `Create_stmt of CreateStmt.t | `Define_stmt of DefineStmt.t | `Drop_stmt of DropStmt.t | `Truncate_stmt of TruncateStmt.t | `Comment_stmt of CommentStmt.t | `Fetch_stmt of FetchStmt.t | `Index_stmt of IndexStmt.t | `Create_function_stmt of CreateFunctionStmt.t | `Alter_function_stmt of AlterFunctionStmt.t | `Do_stmt of DoStmt.t | `Rename_stmt of RenameStmt.t | `Rule_stmt of RuleStmt.t | `Notify_stmt of NotifyStmt.t | `Listen_stmt of ListenStmt.t | `Unlisten_stmt of UnlistenStmt.t | `Transaction_stmt of TransactionStmt.t | `View_stmt of ViewStmt.t | `Load_stmt of LoadStmt.t | `Create_domain_stmt of CreateDomainStmt.t | `Createdb_stmt of CreatedbStmt.t | `Dropdb_stmt of DropdbStmt.t | `Vacuum_stmt of VacuumStmt.t | `Explain_stmt of ExplainStmt.t | `Create_table_as_stmt of CreateTableAsStmt.t | `Create_seq_stmt of CreateSeqStmt.t | `Alter_seq_stmt of AlterSeqStmt.t | `Variable_set_stmt of VariableSetStmt.t | `Variable_show_stmt of VariableShowStmt.t | `Discard_stmt of DiscardStmt.t | `Create_trig_stmt of CreateTrigStmt.t | `Create_plang_stmt of CreatePLangStmt.t | `Create_role_stmt of CreateRoleStmt.t | `Alter_role_stmt of AlterRoleStmt.t | `Drop_role_stmt of DropRoleStmt.t | `Lock_stmt of LockStmt.t | `Constraints_set_stmt of ConstraintsSetStmt.t | `Reindex_stmt of ReindexStmt.t | `Check_point_stmt of CheckPointStmt.t | `Create_schema_stmt of CreateSchemaStmt.t | `Alter_database_stmt of AlterDatabaseStmt.t | `Alter_database_refresh_coll_stmt of AlterDatabaseRefreshCollStmt.t | `Alter_database_set_stmt of AlterDatabaseSetStmt.t | `Alter_role_set_stmt of AlterRoleSetStmt.t | `Create_conversion_stmt of CreateConversionStmt.t | `Create_cast_stmt of CreateCastStmt.t | `Create_op_class_stmt of CreateOpClassStmt.t | `Create_op_family_stmt of CreateOpFamilyStmt.t | `Alter_op_family_stmt of AlterOpFamilyStmt.t | `Prepare_stmt of PrepareStmt.t | `Execute_stmt of ExecuteStmt.t | `Deallocate_stmt of DeallocateStmt.t | `Declare_cursor_stmt of DeclareCursorStmt.t | `Create_table_space_stmt of CreateTableSpaceStmt.t | `Drop_table_space_stmt of DropTableSpaceStmt.t | `Alter_object_depends_stmt of AlterObjectDependsStmt.t | `Alter_object_schema_stmt of AlterObjectSchemaStmt.t | `Alter_owner_stmt of AlterOwnerStmt.t | `Alter_operator_stmt of AlterOperatorStmt.t | `Alter_type_stmt of AlterTypeStmt.t | `Drop_owned_stmt of DropOwnedStmt.t | `Reassign_owned_stmt of ReassignOwnedStmt.t | `Composite_type_stmt of CompositeTypeStmt.t | `Create_enum_stmt of CreateEnumStmt.t | `Create_range_stmt of CreateRangeStmt.t | `Alter_enum_stmt of AlterEnumStmt.t | `Alter_tsdictionary_stmt of AlterTSDictionaryStmt.t | `Alter_tsconfiguration_stmt of AlterTSConfigurationStmt.t | `Create_fdw_stmt of CreateFdwStmt.t | `Alter_fdw_stmt of AlterFdwStmt.t | `Create_foreign_server_stmt of CreateForeignServerStmt.t | `Alter_foreign_server_stmt of AlterForeignServerStmt.t | `Create_user_mapping_stmt of CreateUserMappingStmt.t | `Alter_user_mapping_stmt of AlterUserMappingStmt.t | `Drop_user_mapping_stmt of DropUserMappingStmt.t | `Alter_table_space_options_stmt of AlterTableSpaceOptionsStmt.t | `Alter_table_move_all_stmt of AlterTableMoveAllStmt.t | `Sec_label_stmt of SecLabelStmt.t | `Create_foreign_table_stmt of CreateForeignTableStmt.t | `Import_foreign_schema_stmt of ImportForeignSchemaStmt.t | `Create_extension_stmt of CreateExtensionStmt.t | `Alter_extension_stmt of AlterExtensionStmt.t | `Alter_extension_contents_stmt of AlterExtensionContentsStmt.t | `Create_event_trig_stmt of CreateEventTrigStmt.t | `Alter_event_trig_stmt of AlterEventTrigStmt.t | `Refresh_mat_view_stmt of RefreshMatViewStmt.t | `Replica_identity_stmt of ReplicaIdentityStmt.t | `Alter_system_stmt of AlterSystemStmt.t | `Create_policy_stmt of CreatePolicyStmt.t | `Alter_policy_stmt of AlterPolicyStmt.t | `Create_transform_stmt of CreateTransformStmt.t | `Create_am_stmt of CreateAmStmt.t | `Create_publication_stmt of CreatePublicationStmt.t | `Alter_publication_stmt of AlterPublicationStmt.t | `Create_subscription_stmt of CreateSubscriptionStmt.t | `Alter_subscription_stmt of AlterSubscriptionStmt.t | `Drop_subscription_stmt of DropSubscriptionStmt.t | `Create_stats_stmt of CreateStatsStmt.t | `Alter_collation_stmt of AlterCollationStmt.t | `Call_stmt of CallStmt.t | `Alter_stats_stmt of AlterStatsStmt.t | `A_expr of A_Expr.t | `Column_ref of ColumnRef.t | `Param_ref of ParamRef.t | `Func_call of FuncCall.t | `A_star of A_Star.t | `A_indices of A_Indices.t | `A_indirection of A_Indirection.t | `A_array_expr of A_ArrayExpr.t | `Res_target of ResTarget.t | `Multi_assign_ref of MultiAssignRef.t | `Type_cast of TypeCast.t | `Collate_clause of CollateClause.t | `Sort_by of SortBy.t | `Window_def of WindowDef.t | `Range_subselect of RangeSubselect.t | `Range_function of RangeFunction.t | `Range_table_sample of RangeTableSample.t | `Range_table_func of RangeTableFunc.t | `Range_table_func_col of RangeTableFuncCol.t | `Type_name of TypeName.t | `Column_def of ColumnDef.t | `Index_elem of IndexElem.t | `Stats_elem of StatsElem.t | `Constraint of Constraint.t | `Def_elem of DefElem.t | `Range_tbl_entry of RangeTblEntry.t | `Range_tbl_function of RangeTblFunction.t | `Table_sample_clause of TableSampleClause.t | `With_check_option of WithCheckOption.t | `Sort_group_clause of SortGroupClause.t | `Grouping_set of GroupingSet.t | `Window_clause of WindowClause.t | `Object_with_args of ObjectWithArgs.t | `Access_priv of AccessPriv.t | `Create_op_class_item of CreateOpClassItem.t | `Table_like_clause of TableLikeClause.t | `Function_parameter of FunctionParameter.t | `Locking_clause of LockingClause.t | `Row_mark_clause of RowMarkClause.t | `Xml_serialize of XmlSerialize.t | `With_clause of WithClause.t | `Infer_clause of InferClause.t | `On_conflict_clause of OnConflictClause.t | `Ctesearch_clause of CTESearchClause.t | `Ctecycle_clause of CTECycleClause.t | `Common_table_expr of CommonTableExpr.t | `Merge_when_clause of MergeWhenClause.t | `Role_spec of RoleSpec.t | `Trigger_transition of TriggerTransition.t | `Partition_elem of PartitionElem.t | `Partition_spec of PartitionSpec.t | `Partition_bound_spec of PartitionBoundSpec.t | `Partition_range_datum of PartitionRangeDatum.t | `Partition_cmd of PartitionCmd.t | `Vacuum_relation of VacuumRelation.t | `Publication_obj_spec of PublicationObjSpec.t | `Publication_table of PublicationTable.t | `Inline_code_block of InlineCodeBlock.t | `Call_context of CallContext.t | `Integer of Integer.t | `Float of Float.t | `Boolean of Boolean.t | `String of String.t | `Bit_string of BitString.t | `List of List.t | `Int_list of IntList.t | `Oid_list of OidList.t | `A_const of A_Const.t ] -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.Node"
    type t = [ `not_set | `Alias of Alias.t | `Range_var of RangeVar.t | `Table_func of TableFunc.t | `Var of Var.t | `Param of Param.t | `Aggref of Aggref.t | `Grouping_func of GroupingFunc.t | `Window_func of WindowFunc.t | `Subscripting_ref of SubscriptingRef.t | `Func_expr of FuncExpr.t | `Named_arg_expr of NamedArgExpr.t | `Op_expr of OpExpr.t | `Distinct_expr of DistinctExpr.t | `Null_if_expr of NullIfExpr.t | `Scalar_array_op_expr of ScalarArrayOpExpr.t | `Bool_expr of BoolExpr.t | `Sub_link of SubLink.t | `Sub_plan of SubPlan.t | `Alternative_sub_plan of AlternativeSubPlan.t | `Field_select of FieldSelect.t | `Field_store of FieldStore.t | `Relabel_type of RelabelType.t | `Coerce_via_io of CoerceViaIO.t | `Array_coerce_expr of ArrayCoerceExpr.t | `Convert_rowtype_expr of ConvertRowtypeExpr.t | `Collate_expr of CollateExpr.t | `Case_expr of CaseExpr.t | `Case_when of CaseWhen.t | `Case_test_expr of CaseTestExpr.t | `Array_expr of ArrayExpr.t | `Row_expr of RowExpr.t | `Row_compare_expr of RowCompareExpr.t | `Coalesce_expr of CoalesceExpr.t | `Min_max_expr of MinMaxExpr.t | `Sqlvalue_function of SQLValueFunction.t | `Xml_expr of XmlExpr.t | `Null_test of NullTest.t | `Boolean_test of BooleanTest.t | `Coerce_to_domain of CoerceToDomain.t | `Coerce_to_domain_value of CoerceToDomainValue.t | `Set_to_default of SetToDefault.t | `Current_of_expr of CurrentOfExpr.t | `Next_value_expr of NextValueExpr.t | `Inference_elem of InferenceElem.t | `Target_entry of TargetEntry.t | `Range_tbl_ref of RangeTblRef.t | `Join_expr of JoinExpr.t | `From_expr of FromExpr.t | `On_conflict_expr of OnConflictExpr.t | `Into_clause of IntoClause.t | `Merge_action of MergeAction.t | `Raw_stmt of RawStmt.t | `Query of Query.t | `Insert_stmt of InsertStmt.t | `Delete_stmt of DeleteStmt.t | `Update_stmt of UpdateStmt.t | `Merge_stmt of MergeStmt.t | `Select_stmt of SelectStmt.t | `Return_stmt of ReturnStmt.t | `Plassign_stmt of PLAssignStmt.t | `Alter_table_stmt of AlterTableStmt.t | `Alter_table_cmd of AlterTableCmd.t | `Alter_domain_stmt of AlterDomainStmt.t | `Set_operation_stmt of SetOperationStmt.t | `Grant_stmt of GrantStmt.t | `Grant_role_stmt of GrantRoleStmt.t | `Alter_default_privileges_stmt of AlterDefaultPrivilegesStmt.t | `Close_portal_stmt of ClosePortalStmt.t | `Cluster_stmt of ClusterStmt.t | `Copy_stmt of CopyStmt.t | `Create_stmt of CreateStmt.t | `Define_stmt of DefineStmt.t | `Drop_stmt of DropStmt.t | `Truncate_stmt of TruncateStmt.t | `Comment_stmt of CommentStmt.t | `Fetch_stmt of FetchStmt.t | `Index_stmt of IndexStmt.t | `Create_function_stmt of CreateFunctionStmt.t | `Alter_function_stmt of AlterFunctionStmt.t | `Do_stmt of DoStmt.t | `Rename_stmt of RenameStmt.t | `Rule_stmt of RuleStmt.t | `Notify_stmt of NotifyStmt.t | `Listen_stmt of ListenStmt.t | `Unlisten_stmt of UnlistenStmt.t | `Transaction_stmt of TransactionStmt.t | `View_stmt of ViewStmt.t | `Load_stmt of LoadStmt.t | `Create_domain_stmt of CreateDomainStmt.t | `Createdb_stmt of CreatedbStmt.t | `Dropdb_stmt of DropdbStmt.t | `Vacuum_stmt of VacuumStmt.t | `Explain_stmt of ExplainStmt.t | `Create_table_as_stmt of CreateTableAsStmt.t | `Create_seq_stmt of CreateSeqStmt.t | `Alter_seq_stmt of AlterSeqStmt.t | `Variable_set_stmt of VariableSetStmt.t | `Variable_show_stmt of VariableShowStmt.t | `Discard_stmt of DiscardStmt.t | `Create_trig_stmt of CreateTrigStmt.t | `Create_plang_stmt of CreatePLangStmt.t | `Create_role_stmt of CreateRoleStmt.t | `Alter_role_stmt of AlterRoleStmt.t | `Drop_role_stmt of DropRoleStmt.t | `Lock_stmt of LockStmt.t | `Constraints_set_stmt of ConstraintsSetStmt.t | `Reindex_stmt of ReindexStmt.t | `Check_point_stmt of CheckPointStmt.t | `Create_schema_stmt of CreateSchemaStmt.t | `Alter_database_stmt of AlterDatabaseStmt.t | `Alter_database_refresh_coll_stmt of AlterDatabaseRefreshCollStmt.t | `Alter_database_set_stmt of AlterDatabaseSetStmt.t | `Alter_role_set_stmt of AlterRoleSetStmt.t | `Create_conversion_stmt of CreateConversionStmt.t | `Create_cast_stmt of CreateCastStmt.t | `Create_op_class_stmt of CreateOpClassStmt.t | `Create_op_family_stmt of CreateOpFamilyStmt.t | `Alter_op_family_stmt of AlterOpFamilyStmt.t | `Prepare_stmt of PrepareStmt.t | `Execute_stmt of ExecuteStmt.t | `Deallocate_stmt of DeallocateStmt.t | `Declare_cursor_stmt of DeclareCursorStmt.t | `Create_table_space_stmt of CreateTableSpaceStmt.t | `Drop_table_space_stmt of DropTableSpaceStmt.t | `Alter_object_depends_stmt of AlterObjectDependsStmt.t | `Alter_object_schema_stmt of AlterObjectSchemaStmt.t | `Alter_owner_stmt of AlterOwnerStmt.t | `Alter_operator_stmt of AlterOperatorStmt.t | `Alter_type_stmt of AlterTypeStmt.t | `Drop_owned_stmt of DropOwnedStmt.t | `Reassign_owned_stmt of ReassignOwnedStmt.t | `Composite_type_stmt of CompositeTypeStmt.t | `Create_enum_stmt of CreateEnumStmt.t | `Create_range_stmt of CreateRangeStmt.t | `Alter_enum_stmt of AlterEnumStmt.t | `Alter_tsdictionary_stmt of AlterTSDictionaryStmt.t | `Alter_tsconfiguration_stmt of AlterTSConfigurationStmt.t | `Create_fdw_stmt of CreateFdwStmt.t | `Alter_fdw_stmt of AlterFdwStmt.t | `Create_foreign_server_stmt of CreateForeignServerStmt.t | `Alter_foreign_server_stmt of AlterForeignServerStmt.t | `Create_user_mapping_stmt of CreateUserMappingStmt.t | `Alter_user_mapping_stmt of AlterUserMappingStmt.t | `Drop_user_mapping_stmt of DropUserMappingStmt.t | `Alter_table_space_options_stmt of AlterTableSpaceOptionsStmt.t | `Alter_table_move_all_stmt of AlterTableMoveAllStmt.t | `Sec_label_stmt of SecLabelStmt.t | `Create_foreign_table_stmt of CreateForeignTableStmt.t | `Import_foreign_schema_stmt of ImportForeignSchemaStmt.t | `Create_extension_stmt of CreateExtensionStmt.t | `Alter_extension_stmt of AlterExtensionStmt.t | `Alter_extension_contents_stmt of AlterExtensionContentsStmt.t | `Create_event_trig_stmt of CreateEventTrigStmt.t | `Alter_event_trig_stmt of AlterEventTrigStmt.t | `Refresh_mat_view_stmt of RefreshMatViewStmt.t | `Replica_identity_stmt of ReplicaIdentityStmt.t | `Alter_system_stmt of AlterSystemStmt.t | `Create_policy_stmt of CreatePolicyStmt.t | `Alter_policy_stmt of AlterPolicyStmt.t | `Create_transform_stmt of CreateTransformStmt.t | `Create_am_stmt of CreateAmStmt.t | `Create_publication_stmt of CreatePublicationStmt.t | `Alter_publication_stmt of AlterPublicationStmt.t | `Create_subscription_stmt of CreateSubscriptionStmt.t | `Alter_subscription_stmt of AlterSubscriptionStmt.t | `Drop_subscription_stmt of DropSubscriptionStmt.t | `Create_stats_stmt of CreateStatsStmt.t | `Alter_collation_stmt of AlterCollationStmt.t | `Call_stmt of CallStmt.t | `Alter_stats_stmt of AlterStatsStmt.t | `A_expr of A_Expr.t | `Column_ref of ColumnRef.t | `Param_ref of ParamRef.t | `Func_call of FuncCall.t | `A_star of A_Star.t | `A_indices of A_Indices.t | `A_indirection of A_Indirection.t | `A_array_expr of A_ArrayExpr.t | `Res_target of ResTarget.t | `Multi_assign_ref of MultiAssignRef.t | `Type_cast of TypeCast.t | `Collate_clause of CollateClause.t | `Sort_by of SortBy.t | `Window_def of WindowDef.t | `Range_subselect of RangeSubselect.t | `Range_function of RangeFunction.t | `Range_table_sample of RangeTableSample.t | `Range_table_func of RangeTableFunc.t | `Range_table_func_col of RangeTableFuncCol.t | `Type_name of TypeName.t | `Column_def of ColumnDef.t | `Index_elem of IndexElem.t | `Stats_elem of StatsElem.t | `Constraint of Constraint.t | `Def_elem of DefElem.t | `Range_tbl_entry of RangeTblEntry.t | `Range_tbl_function of RangeTblFunction.t | `Table_sample_clause of TableSampleClause.t | `With_check_option of WithCheckOption.t | `Sort_group_clause of SortGroupClause.t | `Grouping_set of GroupingSet.t | `Window_clause of WindowClause.t | `Object_with_args of ObjectWithArgs.t | `Access_priv of AccessPriv.t | `Create_op_class_item of CreateOpClassItem.t | `Table_like_clause of TableLikeClause.t | `Function_parameter of FunctionParameter.t | `Locking_clause of LockingClause.t | `Row_mark_clause of RowMarkClause.t | `Xml_serialize of XmlSerialize.t | `With_clause of WithClause.t | `Infer_clause of InferClause.t | `On_conflict_clause of OnConflictClause.t | `Ctesearch_clause of CTESearchClause.t | `Ctecycle_clause of CTECycleClause.t | `Common_table_expr of CommonTableExpr.t | `Merge_when_clause of MergeWhenClause.t | `Role_spec of RoleSpec.t | `Trigger_transition of TriggerTransition.t | `Partition_elem of PartitionElem.t | `Partition_spec of PartitionSpec.t | `Partition_bound_spec of PartitionBoundSpec.t | `Partition_range_datum of PartitionRangeDatum.t | `Partition_cmd of PartitionCmd.t | `Vacuum_relation of VacuumRelation.t | `Publication_obj_spec of PublicationObjSpec.t | `Publication_table of PublicationTable.t | `Inline_code_block of InlineCodeBlock.t | `Call_context of CallContext.t | `Integer of Integer.t | `Float of Float.t | `Boolean of Boolean.t | `String of String.t | `Bit_string of BitString.t | `List of List.t | `Int_list of IntList.t | `Oid_list of OidList.t | `A_const of A_Const.t ]
    let make =
      fun ?node () -> 
      let node = match node with Some v -> v | None -> `not_set in
      node
    
    let to_proto =
      let apply = fun ~f:f' node -> f' [] node in
      let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Alias v -> oneof_elem (1, (message (fun t -> Alias.to_proto t)), v) | `Range_var v -> oneof_elem (2, (message (fun t -> RangeVar.to_proto t)), v) | `Table_func v -> oneof_elem (3, (message (fun t -> TableFunc.to_proto t)), v) | `Var v -> oneof_elem (4, (message (fun t -> Var.to_proto t)), v) | `Param v -> oneof_elem (5, (message (fun t -> Param.to_proto t)), v) | `Aggref v -> oneof_elem (6, (message (fun t -> Aggref.to_proto t)), v) | `Grouping_func v -> oneof_elem (7, (message (fun t -> GroupingFunc.to_proto t)), v) | `Window_func v -> oneof_elem (8, (message (fun t -> WindowFunc.to_proto t)), v) | `Subscripting_ref v -> oneof_elem (9, (message (fun t -> SubscriptingRef.to_proto t)), v) | `Func_expr v -> oneof_elem (10, (message (fun t -> FuncExpr.to_proto t)), v) | `Named_arg_expr v -> oneof_elem (11, (message (fun t -> NamedArgExpr.to_proto t)), v) | `Op_expr v -> oneof_elem (12, (message (fun t -> OpExpr.to_proto t)), v) | `Distinct_expr v -> oneof_elem (13, (message (fun t -> DistinctExpr.to_proto t)), v) | `Null_if_expr v -> oneof_elem (14, (message (fun t -> NullIfExpr.to_proto t)), v) | `Scalar_array_op_expr v -> oneof_elem (15, (message (fun t -> ScalarArrayOpExpr.to_proto t)), v) | `Bool_expr v -> oneof_elem (16, (message (fun t -> BoolExpr.to_proto t)), v) | `Sub_link v -> oneof_elem (17, (message (fun t -> SubLink.to_proto t)), v) | `Sub_plan v -> oneof_elem (18, (message (fun t -> SubPlan.to_proto t)), v) | `Alternative_sub_plan v -> oneof_elem (19, (message (fun t -> AlternativeSubPlan.to_proto t)), v) | `Field_select v -> oneof_elem (20, (message (fun t -> FieldSelect.to_proto t)), v) | `Field_store v -> oneof_elem (21, (message (fun t -> FieldStore.to_proto t)), v) | `Relabel_type v -> oneof_elem (22, (message (fun t -> RelabelType.to_proto t)), v) | `Coerce_via_io v -> oneof_elem (23, (message (fun t -> CoerceViaIO.to_proto t)), v) | `Array_coerce_expr v -> oneof_elem (24, (message (fun t -> ArrayCoerceExpr.to_proto t)), v) | `Convert_rowtype_expr v -> oneof_elem (25, (message (fun t -> ConvertRowtypeExpr.to_proto t)), v) | `Collate_expr v -> oneof_elem (26, (message (fun t -> CollateExpr.to_proto t)), v) | `Case_expr v -> oneof_elem (27, (message (fun t -> CaseExpr.to_proto t)), v) | `Case_when v -> oneof_elem (28, (message (fun t -> CaseWhen.to_proto t)), v) | `Case_test_expr v -> oneof_elem (29, (message (fun t -> CaseTestExpr.to_proto t)), v) | `Array_expr v -> oneof_elem (30, (message (fun t -> ArrayExpr.to_proto t)), v) | `Row_expr v -> oneof_elem (31, (message (fun t -> RowExpr.to_proto t)), v) | `Row_compare_expr v -> oneof_elem (32, (message (fun t -> RowCompareExpr.to_proto t)), v) | `Coalesce_expr v -> oneof_elem (33, (message (fun t -> CoalesceExpr.to_proto t)), v) | `Min_max_expr v -> oneof_elem (34, (message (fun t -> MinMaxExpr.to_proto t)), v) | `Sqlvalue_function v -> oneof_elem (35, (message (fun t -> SQLValueFunction.to_proto t)), v) | `Xml_expr v -> oneof_elem (36, (message (fun t -> XmlExpr.to_proto t)), v) | `Null_test v -> oneof_elem (37, (message (fun t -> NullTest.to_proto t)), v) | `Boolean_test v -> oneof_elem (38, (message (fun t -> BooleanTest.to_proto t)), v) | `Coerce_to_domain v -> oneof_elem (39, (message (fun t -> CoerceToDomain.to_proto t)), v) | `Coerce_to_domain_value v -> oneof_elem (40, (message (fun t -> CoerceToDomainValue.to_proto t)), v) | `Set_to_default v -> oneof_elem (41, (message (fun t -> SetToDefault.to_proto t)), v) | `Current_of_expr v -> oneof_elem (42, (message (fun t -> CurrentOfExpr.to_proto t)), v) | `Next_value_expr v -> oneof_elem (43, (message (fun t -> NextValueExpr.to_proto t)), v) | `Inference_elem v -> oneof_elem (44, (message (fun t -> InferenceElem.to_proto t)), v) | `Target_entry v -> oneof_elem (45, (message (fun t -> TargetEntry.to_proto t)), v) | `Range_tbl_ref v -> oneof_elem (46, (message (fun t -> RangeTblRef.to_proto t)), v) | `Join_expr v -> oneof_elem (47, (message (fun t -> JoinExpr.to_proto t)), v) | `From_expr v -> oneof_elem (48, (message (fun t -> FromExpr.to_proto t)), v) | `On_conflict_expr v -> oneof_elem (49, (message (fun t -> OnConflictExpr.to_proto t)), v) | `Into_clause v -> oneof_elem (50, (message (fun t -> IntoClause.to_proto t)), v) | `Merge_action v -> oneof_elem (51, (message (fun t -> MergeAction.to_proto t)), v) | `Raw_stmt v -> oneof_elem (52, (message (fun t -> RawStmt.to_proto t)), v) | `Query v -> oneof_elem (53, (message (fun t -> Query.to_proto t)), v) | `Insert_stmt v -> oneof_elem (54, (message (fun t -> InsertStmt.to_proto t)), v) | `Delete_stmt v -> oneof_elem (55, (message (fun t -> DeleteStmt.to_proto t)), v) | `Update_stmt v -> oneof_elem (56, (message (fun t -> UpdateStmt.to_proto t)), v) | `Merge_stmt v -> oneof_elem (57, (message (fun t -> MergeStmt.to_proto t)), v) | `Select_stmt v -> oneof_elem (58, (message (fun t -> SelectStmt.to_proto t)), v) | `Return_stmt v -> oneof_elem (59, (message (fun t -> ReturnStmt.to_proto t)), v) | `Plassign_stmt v -> oneof_elem (60, (message (fun t -> PLAssignStmt.to_proto t)), v) | `Alter_table_stmt v -> oneof_elem (61, (message (fun t -> AlterTableStmt.to_proto t)), v) | `Alter_table_cmd v -> oneof_elem (62, (message (fun t -> AlterTableCmd.to_proto t)), v) | `Alter_domain_stmt v -> oneof_elem (63, (message (fun t -> AlterDomainStmt.to_proto t)), v) | `Set_operation_stmt v -> oneof_elem (64, (message (fun t -> SetOperationStmt.to_proto t)), v) | `Grant_stmt v -> oneof_elem (65, (message (fun t -> GrantStmt.to_proto t)), v) | `Grant_role_stmt v -> oneof_elem (66, (message (fun t -> GrantRoleStmt.to_proto t)), v) | `Alter_default_privileges_stmt v -> oneof_elem (67, (message (fun t -> AlterDefaultPrivilegesStmt.to_proto t)), v) | `Close_portal_stmt v -> oneof_elem (68, (message (fun t -> ClosePortalStmt.to_proto t)), v) | `Cluster_stmt v -> oneof_elem (69, (message (fun t -> ClusterStmt.to_proto t)), v) | `Copy_stmt v -> oneof_elem (70, (message (fun t -> CopyStmt.to_proto t)), v) | `Create_stmt v -> oneof_elem (71, (message (fun t -> CreateStmt.to_proto t)), v) | `Define_stmt v -> oneof_elem (72, (message (fun t -> DefineStmt.to_proto t)), v) | `Drop_stmt v -> oneof_elem (73, (message (fun t -> DropStmt.to_proto t)), v) | `Truncate_stmt v -> oneof_elem (74, (message (fun t -> TruncateStmt.to_proto t)), v) | `Comment_stmt v -> oneof_elem (75, (message (fun t -> CommentStmt.to_proto t)), v) | `Fetch_stmt v -> oneof_elem (76, (message (fun t -> FetchStmt.to_proto t)), v) | `Index_stmt v -> oneof_elem (77, (message (fun t -> IndexStmt.to_proto t)), v) | `Create_function_stmt v -> oneof_elem (78, (message (fun t -> CreateFunctionStmt.to_proto t)), v) | `Alter_function_stmt v -> oneof_elem (79, (message (fun t -> AlterFunctionStmt.to_proto t)), v) | `Do_stmt v -> oneof_elem (80, (message (fun t -> DoStmt.to_proto t)), v) | `Rename_stmt v -> oneof_elem (81, (message (fun t -> RenameStmt.to_proto t)), v) | `Rule_stmt v -> oneof_elem (82, (message (fun t -> RuleStmt.to_proto t)), v) | `Notify_stmt v -> oneof_elem (83, (message (fun t -> NotifyStmt.to_proto t)), v) | `Listen_stmt v -> oneof_elem (84, (message (fun t -> ListenStmt.to_proto t)), v) | `Unlisten_stmt v -> oneof_elem (85, (message (fun t -> UnlistenStmt.to_proto t)), v) | `Transaction_stmt v -> oneof_elem (86, (message (fun t -> TransactionStmt.to_proto t)), v) | `View_stmt v -> oneof_elem (87, (message (fun t -> ViewStmt.to_proto t)), v) | `Load_stmt v -> oneof_elem (88, (message (fun t -> LoadStmt.to_proto t)), v) | `Create_domain_stmt v -> oneof_elem (89, (message (fun t -> CreateDomainStmt.to_proto t)), v) | `Createdb_stmt v -> oneof_elem (90, (message (fun t -> CreatedbStmt.to_proto t)), v) | `Dropdb_stmt v -> oneof_elem (91, (message (fun t -> DropdbStmt.to_proto t)), v) | `Vacuum_stmt v -> oneof_elem (92, (message (fun t -> VacuumStmt.to_proto t)), v) | `Explain_stmt v -> oneof_elem (93, (message (fun t -> ExplainStmt.to_proto t)), v) | `Create_table_as_stmt v -> oneof_elem (94, (message (fun t -> CreateTableAsStmt.to_proto t)), v) | `Create_seq_stmt v -> oneof_elem (95, (message (fun t -> CreateSeqStmt.to_proto t)), v) | `Alter_seq_stmt v -> oneof_elem (96, (message (fun t -> AlterSeqStmt.to_proto t)), v) | `Variable_set_stmt v -> oneof_elem (97, (message (fun t -> VariableSetStmt.to_proto t)), v) | `Variable_show_stmt v -> oneof_elem (98, (message (fun t -> VariableShowStmt.to_proto t)), v) | `Discard_stmt v -> oneof_elem (99, (message (fun t -> DiscardStmt.to_proto t)), v) | `Create_trig_stmt v -> oneof_elem (100, (message (fun t -> CreateTrigStmt.to_proto t)), v) | `Create_plang_stmt v -> oneof_elem (101, (message (fun t -> CreatePLangStmt.to_proto t)), v) | `Create_role_stmt v -> oneof_elem (102, (message (fun t -> CreateRoleStmt.to_proto t)), v) | `Alter_role_stmt v -> oneof_elem (103, (message (fun t -> AlterRoleStmt.to_proto t)), v) | `Drop_role_stmt v -> oneof_elem (104, (message (fun t -> DropRoleStmt.to_proto t)), v) | `Lock_stmt v -> oneof_elem (105, (message (fun t -> LockStmt.to_proto t)), v) | `Constraints_set_stmt v -> oneof_elem (106, (message (fun t -> ConstraintsSetStmt.to_proto t)), v) | `Reindex_stmt v -> oneof_elem (107, (message (fun t -> ReindexStmt.to_proto t)), v) | `Check_point_stmt v -> oneof_elem (108, (message (fun t -> CheckPointStmt.to_proto t)), v) | `Create_schema_stmt v -> oneof_elem (109, (message (fun t -> CreateSchemaStmt.to_proto t)), v) | `Alter_database_stmt v -> oneof_elem (110, (message (fun t -> AlterDatabaseStmt.to_proto t)), v) | `Alter_database_refresh_coll_stmt v -> oneof_elem (111, (message (fun t -> AlterDatabaseRefreshCollStmt.to_proto t)), v) | `Alter_database_set_stmt v -> oneof_elem (112, (message (fun t -> AlterDatabaseSetStmt.to_proto t)), v) | `Alter_role_set_stmt v -> oneof_elem (113, (message (fun t -> AlterRoleSetStmt.to_proto t)), v) | `Create_conversion_stmt v -> oneof_elem (114, (message (fun t -> CreateConversionStmt.to_proto t)), v) | `Create_cast_stmt v -> oneof_elem (115, (message (fun t -> CreateCastStmt.to_proto t)), v) | `Create_op_class_stmt v -> oneof_elem (116, (message (fun t -> CreateOpClassStmt.to_proto t)), v) | `Create_op_family_stmt v -> oneof_elem (117, (message (fun t -> CreateOpFamilyStmt.to_proto t)), v) | `Alter_op_family_stmt v -> oneof_elem (118, (message (fun t -> AlterOpFamilyStmt.to_proto t)), v) | `Prepare_stmt v -> oneof_elem (119, (message (fun t -> PrepareStmt.to_proto t)), v) | `Execute_stmt v -> oneof_elem (120, (message (fun t -> ExecuteStmt.to_proto t)), v) | `Deallocate_stmt v -> oneof_elem (121, (message (fun t -> DeallocateStmt.to_proto t)), v) | `Declare_cursor_stmt v -> oneof_elem (122, (message (fun t -> DeclareCursorStmt.to_proto t)), v) | `Create_table_space_stmt v -> oneof_elem (123, (message (fun t -> CreateTableSpaceStmt.to_proto t)), v) | `Drop_table_space_stmt v -> oneof_elem (124, (message (fun t -> DropTableSpaceStmt.to_proto t)), v) | `Alter_object_depends_stmt v -> oneof_elem (125, (message (fun t -> AlterObjectDependsStmt.to_proto t)), v) | `Alter_object_schema_stmt v -> oneof_elem (126, (message (fun t -> AlterObjectSchemaStmt.to_proto t)), v) | `Alter_owner_stmt v -> oneof_elem (127, (message (fun t -> AlterOwnerStmt.to_proto t)), v) | `Alter_operator_stmt v -> oneof_elem (128, (message (fun t -> AlterOperatorStmt.to_proto t)), v) | `Alter_type_stmt v -> oneof_elem (129, (message (fun t -> AlterTypeStmt.to_proto t)), v) | `Drop_owned_stmt v -> oneof_elem (130, (message (fun t -> DropOwnedStmt.to_proto t)), v) | `Reassign_owned_stmt v -> oneof_elem (131, (message (fun t -> ReassignOwnedStmt.to_proto t)), v) | `Composite_type_stmt v -> oneof_elem (132, (message (fun t -> CompositeTypeStmt.to_proto t)), v) | `Create_enum_stmt v -> oneof_elem (133, (message (fun t -> CreateEnumStmt.to_proto t)), v) | `Create_range_stmt v -> oneof_elem (134, (message (fun t -> CreateRangeStmt.to_proto t)), v) | `Alter_enum_stmt v -> oneof_elem (135, (message (fun t -> AlterEnumStmt.to_proto t)), v) | `Alter_tsdictionary_stmt v -> oneof_elem (136, (message (fun t -> AlterTSDictionaryStmt.to_proto t)), v) | `Alter_tsconfiguration_stmt v -> oneof_elem (137, (message (fun t -> AlterTSConfigurationStmt.to_proto t)), v) | `Create_fdw_stmt v -> oneof_elem (138, (message (fun t -> CreateFdwStmt.to_proto t)), v) | `Alter_fdw_stmt v -> oneof_elem (139, (message (fun t -> AlterFdwStmt.to_proto t)), v) | `Create_foreign_server_stmt v -> oneof_elem (140, (message (fun t -> CreateForeignServerStmt.to_proto t)), v) | `Alter_foreign_server_stmt v -> oneof_elem (141, (message (fun t -> AlterForeignServerStmt.to_proto t)), v) | `Create_user_mapping_stmt v -> oneof_elem (142, (message (fun t -> CreateUserMappingStmt.to_proto t)), v) | `Alter_user_mapping_stmt v -> oneof_elem (143, (message (fun t -> AlterUserMappingStmt.to_proto t)), v) | `Drop_user_mapping_stmt v -> oneof_elem (144, (message (fun t -> DropUserMappingStmt.to_proto t)), v) | `Alter_table_space_options_stmt v -> oneof_elem (145, (message (fun t -> AlterTableSpaceOptionsStmt.to_proto t)), v) | `Alter_table_move_all_stmt v -> oneof_elem (146, (message (fun t -> AlterTableMoveAllStmt.to_proto t)), v) | `Sec_label_stmt v -> oneof_elem (147, (message (fun t -> SecLabelStmt.to_proto t)), v) | `Create_foreign_table_stmt v -> oneof_elem (148, (message (fun t -> CreateForeignTableStmt.to_proto t)), v) | `Import_foreign_schema_stmt v -> oneof_elem (149, (message (fun t -> ImportForeignSchemaStmt.to_proto t)), v) | `Create_extension_stmt v -> oneof_elem (150, (message (fun t -> CreateExtensionStmt.to_proto t)), v) | `Alter_extension_stmt v -> oneof_elem (151, (message (fun t -> AlterExtensionStmt.to_proto t)), v) | `Alter_extension_contents_stmt v -> oneof_elem (152, (message (fun t -> AlterExtensionContentsStmt.to_proto t)), v) | `Create_event_trig_stmt v -> oneof_elem (153, (message (fun t -> CreateEventTrigStmt.to_proto t)), v) | `Alter_event_trig_stmt v -> oneof_elem (154, (message (fun t -> AlterEventTrigStmt.to_proto t)), v) | `Refresh_mat_view_stmt v -> oneof_elem (155, (message (fun t -> RefreshMatViewStmt.to_proto t)), v) | `Replica_identity_stmt v -> oneof_elem (156, (message (fun t -> ReplicaIdentityStmt.to_proto t)), v) | `Alter_system_stmt v -> oneof_elem (157, (message (fun t -> AlterSystemStmt.to_proto t)), v) | `Create_policy_stmt v -> oneof_elem (158, (message (fun t -> CreatePolicyStmt.to_proto t)), v) | `Alter_policy_stmt v -> oneof_elem (159, (message (fun t -> AlterPolicyStmt.to_proto t)), v) | `Create_transform_stmt v -> oneof_elem (160, (message (fun t -> CreateTransformStmt.to_proto t)), v) | `Create_am_stmt v -> oneof_elem (161, (message (fun t -> CreateAmStmt.to_proto t)), v) | `Create_publication_stmt v -> oneof_elem (162, (message (fun t -> CreatePublicationStmt.to_proto t)), v) | `Alter_publication_stmt v -> oneof_elem (163, (message (fun t -> AlterPublicationStmt.to_proto t)), v) | `Create_subscription_stmt v -> oneof_elem (164, (message (fun t -> CreateSubscriptionStmt.to_proto t)), v) | `Alter_subscription_stmt v -> oneof_elem (165, (message (fun t -> AlterSubscriptionStmt.to_proto t)), v) | `Drop_subscription_stmt v -> oneof_elem (166, (message (fun t -> DropSubscriptionStmt.to_proto t)), v) | `Create_stats_stmt v -> oneof_elem (167, (message (fun t -> CreateStatsStmt.to_proto t)), v) | `Alter_collation_stmt v -> oneof_elem (168, (message (fun t -> AlterCollationStmt.to_proto t)), v) | `Call_stmt v -> oneof_elem (169, (message (fun t -> CallStmt.to_proto t)), v) | `Alter_stats_stmt v -> oneof_elem (170, (message (fun t -> AlterStatsStmt.to_proto t)), v) | `A_expr v -> oneof_elem (171, (message (fun t -> A_Expr.to_proto t)), v) | `Column_ref v -> oneof_elem (172, (message (fun t -> ColumnRef.to_proto t)), v) | `Param_ref v -> oneof_elem (173, (message (fun t -> ParamRef.to_proto t)), v) | `Func_call v -> oneof_elem (174, (message (fun t -> FuncCall.to_proto t)), v) | `A_star v -> oneof_elem (175, (message (fun t -> A_Star.to_proto t)), v) | `A_indices v -> oneof_elem (176, (message (fun t -> A_Indices.to_proto t)), v) | `A_indirection v -> oneof_elem (177, (message (fun t -> A_Indirection.to_proto t)), v) | `A_array_expr v -> oneof_elem (178, (message (fun t -> A_ArrayExpr.to_proto t)), v) | `Res_target v -> oneof_elem (179, (message (fun t -> ResTarget.to_proto t)), v) | `Multi_assign_ref v -> oneof_elem (180, (message (fun t -> MultiAssignRef.to_proto t)), v) | `Type_cast v -> oneof_elem (181, (message (fun t -> TypeCast.to_proto t)), v) | `Collate_clause v -> oneof_elem (182, (message (fun t -> CollateClause.to_proto t)), v) | `Sort_by v -> oneof_elem (183, (message (fun t -> SortBy.to_proto t)), v) | `Window_def v -> oneof_elem (184, (message (fun t -> WindowDef.to_proto t)), v) | `Range_subselect v -> oneof_elem (185, (message (fun t -> RangeSubselect.to_proto t)), v) | `Range_function v -> oneof_elem (186, (message (fun t -> RangeFunction.to_proto t)), v) | `Range_table_sample v -> oneof_elem (187, (message (fun t -> RangeTableSample.to_proto t)), v) | `Range_table_func v -> oneof_elem (188, (message (fun t -> RangeTableFunc.to_proto t)), v) | `Range_table_func_col v -> oneof_elem (189, (message (fun t -> RangeTableFuncCol.to_proto t)), v) | `Type_name v -> oneof_elem (190, (message (fun t -> TypeName.to_proto t)), v) | `Column_def v -> oneof_elem (191, (message (fun t -> ColumnDef.to_proto t)), v) | `Index_elem v -> oneof_elem (192, (message (fun t -> IndexElem.to_proto t)), v) | `Stats_elem v -> oneof_elem (193, (message (fun t -> StatsElem.to_proto t)), v) | `Constraint v -> oneof_elem (194, (message (fun t -> Constraint.to_proto t)), v) | `Def_elem v -> oneof_elem (195, (message (fun t -> DefElem.to_proto t)), v) | `Range_tbl_entry v -> oneof_elem (196, (message (fun t -> RangeTblEntry.to_proto t)), v) | `Range_tbl_function v -> oneof_elem (197, (message (fun t -> RangeTblFunction.to_proto t)), v) | `Table_sample_clause v -> oneof_elem (198, (message (fun t -> TableSampleClause.to_proto t)), v) | `With_check_option v -> oneof_elem (199, (message (fun t -> WithCheckOption.to_proto t)), v) | `Sort_group_clause v -> oneof_elem (200, (message (fun t -> SortGroupClause.to_proto t)), v) | `Grouping_set v -> oneof_elem (201, (message (fun t -> GroupingSet.to_proto t)), v) | `Window_clause v -> oneof_elem (202, (message (fun t -> WindowClause.to_proto t)), v) | `Object_with_args v -> oneof_elem (203, (message (fun t -> ObjectWithArgs.to_proto t)), v) | `Access_priv v -> oneof_elem (204, (message (fun t -> AccessPriv.to_proto t)), v) | `Create_op_class_item v -> oneof_elem (205, (message (fun t -> CreateOpClassItem.to_proto t)), v) | `Table_like_clause v -> oneof_elem (206, (message (fun t -> TableLikeClause.to_proto t)), v) | `Function_parameter v -> oneof_elem (207, (message (fun t -> FunctionParameter.to_proto t)), v) | `Locking_clause v -> oneof_elem (208, (message (fun t -> LockingClause.to_proto t)), v) | `Row_mark_clause v -> oneof_elem (209, (message (fun t -> RowMarkClause.to_proto t)), v) | `Xml_serialize v -> oneof_elem (210, (message (fun t -> XmlSerialize.to_proto t)), v) | `With_clause v -> oneof_elem (211, (message (fun t -> WithClause.to_proto t)), v) | `Infer_clause v -> oneof_elem (212, (message (fun t -> InferClause.to_proto t)), v) | `On_conflict_clause v -> oneof_elem (213, (message (fun t -> OnConflictClause.to_proto t)), v) | `Ctesearch_clause v -> oneof_elem (214, (message (fun t -> CTESearchClause.to_proto t)), v) | `Ctecycle_clause v -> oneof_elem (215, (message (fun t -> CTECycleClause.to_proto t)), v) | `Common_table_expr v -> oneof_elem (216, (message (fun t -> CommonTableExpr.to_proto t)), v) | `Merge_when_clause v -> oneof_elem (217, (message (fun t -> MergeWhenClause.to_proto t)), v) | `Role_spec v -> oneof_elem (218, (message (fun t -> RoleSpec.to_proto t)), v) | `Trigger_transition v -> oneof_elem (219, (message (fun t -> TriggerTransition.to_proto t)), v) | `Partition_elem v -> oneof_elem (220, (message (fun t -> PartitionElem.to_proto t)), v) | `Partition_spec v -> oneof_elem (221, (message (fun t -> PartitionSpec.to_proto t)), v) | `Partition_bound_spec v -> oneof_elem (222, (message (fun t -> PartitionBoundSpec.to_proto t)), v) | `Partition_range_datum v -> oneof_elem (223, (message (fun t -> PartitionRangeDatum.to_proto t)), v) | `Partition_cmd v -> oneof_elem (224, (message (fun t -> PartitionCmd.to_proto t)), v) | `Vacuum_relation v -> oneof_elem (225, (message (fun t -> VacuumRelation.to_proto t)), v) | `Publication_obj_spec v -> oneof_elem (226, (message (fun t -> PublicationObjSpec.to_proto t)), v) | `Publication_table v -> oneof_elem (227, (message (fun t -> PublicationTable.to_proto t)), v) | `Inline_code_block v -> oneof_elem (228, (message (fun t -> InlineCodeBlock.to_proto t)), v) | `Call_context v -> oneof_elem (229, (message (fun t -> CallContext.to_proto t)), v) | `Integer v -> oneof_elem (230, (message (fun t -> Integer.to_proto t)), v) | `Float v -> oneof_elem (231, (message (fun t -> Float.to_proto t)), v) | `Boolean v -> oneof_elem (232, (message (fun t -> Boolean.to_proto t)), v) | `String v -> oneof_elem (233, (message (fun t -> String.to_proto t)), v) | `Bit_string v -> oneof_elem (234, (message (fun t -> BitString.to_proto t)), v) | `List v -> oneof_elem (235, (message (fun t -> List.to_proto t)), v) | `Int_list v -> oneof_elem (236, (message (fun t -> IntList.to_proto t)), v) | `Oid_list v -> oneof_elem (237, (message (fun t -> OidList.to_proto t)), v) | `A_const v -> oneof_elem (238, (message (fun t -> A_Const.to_proto t)), v))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions node -> node in
      let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> Alias.from_proto t)), fun v -> `Alias v); oneof_elem (2, (message (fun t -> RangeVar.from_proto t)), fun v -> `Range_var v); oneof_elem (3, (message (fun t -> TableFunc.from_proto t)), fun v -> `Table_func v); oneof_elem (4, (message (fun t -> Var.from_proto t)), fun v -> `Var v); oneof_elem (5, (message (fun t -> Param.from_proto t)), fun v -> `Param v); oneof_elem (6, (message (fun t -> Aggref.from_proto t)), fun v -> `Aggref v); oneof_elem (7, (message (fun t -> GroupingFunc.from_proto t)), fun v -> `Grouping_func v); oneof_elem (8, (message (fun t -> WindowFunc.from_proto t)), fun v -> `Window_func v); oneof_elem (9, (message (fun t -> SubscriptingRef.from_proto t)), fun v -> `Subscripting_ref v); oneof_elem (10, (message (fun t -> FuncExpr.from_proto t)), fun v -> `Func_expr v); oneof_elem (11, (message (fun t -> NamedArgExpr.from_proto t)), fun v -> `Named_arg_expr v); oneof_elem (12, (message (fun t -> OpExpr.from_proto t)), fun v -> `Op_expr v); oneof_elem (13, (message (fun t -> DistinctExpr.from_proto t)), fun v -> `Distinct_expr v); oneof_elem (14, (message (fun t -> NullIfExpr.from_proto t)), fun v -> `Null_if_expr v); oneof_elem (15, (message (fun t -> ScalarArrayOpExpr.from_proto t)), fun v -> `Scalar_array_op_expr v); oneof_elem (16, (message (fun t -> BoolExpr.from_proto t)), fun v -> `Bool_expr v); oneof_elem (17, (message (fun t -> SubLink.from_proto t)), fun v -> `Sub_link v); oneof_elem (18, (message (fun t -> SubPlan.from_proto t)), fun v -> `Sub_plan v); oneof_elem (19, (message (fun t -> AlternativeSubPlan.from_proto t)), fun v -> `Alternative_sub_plan v); oneof_elem (20, (message (fun t -> FieldSelect.from_proto t)), fun v -> `Field_select v); oneof_elem (21, (message (fun t -> FieldStore.from_proto t)), fun v -> `Field_store v); oneof_elem (22, (message (fun t -> RelabelType.from_proto t)), fun v -> `Relabel_type v); oneof_elem (23, (message (fun t -> CoerceViaIO.from_proto t)), fun v -> `Coerce_via_io v); oneof_elem (24, (message (fun t -> ArrayCoerceExpr.from_proto t)), fun v -> `Array_coerce_expr v); oneof_elem (25, (message (fun t -> ConvertRowtypeExpr.from_proto t)), fun v -> `Convert_rowtype_expr v); oneof_elem (26, (message (fun t -> CollateExpr.from_proto t)), fun v -> `Collate_expr v); oneof_elem (27, (message (fun t -> CaseExpr.from_proto t)), fun v -> `Case_expr v); oneof_elem (28, (message (fun t -> CaseWhen.from_proto t)), fun v -> `Case_when v); oneof_elem (29, (message (fun t -> CaseTestExpr.from_proto t)), fun v -> `Case_test_expr v); oneof_elem (30, (message (fun t -> ArrayExpr.from_proto t)), fun v -> `Array_expr v); oneof_elem (31, (message (fun t -> RowExpr.from_proto t)), fun v -> `Row_expr v); oneof_elem (32, (message (fun t -> RowCompareExpr.from_proto t)), fun v -> `Row_compare_expr v); oneof_elem (33, (message (fun t -> CoalesceExpr.from_proto t)), fun v -> `Coalesce_expr v); oneof_elem (34, (message (fun t -> MinMaxExpr.from_proto t)), fun v -> `Min_max_expr v); oneof_elem (35, (message (fun t -> SQLValueFunction.from_proto t)), fun v -> `Sqlvalue_function v); oneof_elem (36, (message (fun t -> XmlExpr.from_proto t)), fun v -> `Xml_expr v); oneof_elem (37, (message (fun t -> NullTest.from_proto t)), fun v -> `Null_test v); oneof_elem (38, (message (fun t -> BooleanTest.from_proto t)), fun v -> `Boolean_test v); oneof_elem (39, (message (fun t -> CoerceToDomain.from_proto t)), fun v -> `Coerce_to_domain v); oneof_elem (40, (message (fun t -> CoerceToDomainValue.from_proto t)), fun v -> `Coerce_to_domain_value v); oneof_elem (41, (message (fun t -> SetToDefault.from_proto t)), fun v -> `Set_to_default v); oneof_elem (42, (message (fun t -> CurrentOfExpr.from_proto t)), fun v -> `Current_of_expr v); oneof_elem (43, (message (fun t -> NextValueExpr.from_proto t)), fun v -> `Next_value_expr v); oneof_elem (44, (message (fun t -> InferenceElem.from_proto t)), fun v -> `Inference_elem v); oneof_elem (45, (message (fun t -> TargetEntry.from_proto t)), fun v -> `Target_entry v); oneof_elem (46, (message (fun t -> RangeTblRef.from_proto t)), fun v -> `Range_tbl_ref v); oneof_elem (47, (message (fun t -> JoinExpr.from_proto t)), fun v -> `Join_expr v); oneof_elem (48, (message (fun t -> FromExpr.from_proto t)), fun v -> `From_expr v); oneof_elem (49, (message (fun t -> OnConflictExpr.from_proto t)), fun v -> `On_conflict_expr v); oneof_elem (50, (message (fun t -> IntoClause.from_proto t)), fun v -> `Into_clause v); oneof_elem (51, (message (fun t -> MergeAction.from_proto t)), fun v -> `Merge_action v); oneof_elem (52, (message (fun t -> RawStmt.from_proto t)), fun v -> `Raw_stmt v); oneof_elem (53, (message (fun t -> Query.from_proto t)), fun v -> `Query v); oneof_elem (54, (message (fun t -> InsertStmt.from_proto t)), fun v -> `Insert_stmt v); oneof_elem (55, (message (fun t -> DeleteStmt.from_proto t)), fun v -> `Delete_stmt v); oneof_elem (56, (message (fun t -> UpdateStmt.from_proto t)), fun v -> `Update_stmt v); oneof_elem (57, (message (fun t -> MergeStmt.from_proto t)), fun v -> `Merge_stmt v); oneof_elem (58, (message (fun t -> SelectStmt.from_proto t)), fun v -> `Select_stmt v); oneof_elem (59, (message (fun t -> ReturnStmt.from_proto t)), fun v -> `Return_stmt v); oneof_elem (60, (message (fun t -> PLAssignStmt.from_proto t)), fun v -> `Plassign_stmt v); oneof_elem (61, (message (fun t -> AlterTableStmt.from_proto t)), fun v -> `Alter_table_stmt v); oneof_elem (62, (message (fun t -> AlterTableCmd.from_proto t)), fun v -> `Alter_table_cmd v); oneof_elem (63, (message (fun t -> AlterDomainStmt.from_proto t)), fun v -> `Alter_domain_stmt v); oneof_elem (64, (message (fun t -> SetOperationStmt.from_proto t)), fun v -> `Set_operation_stmt v); oneof_elem (65, (message (fun t -> GrantStmt.from_proto t)), fun v -> `Grant_stmt v); oneof_elem (66, (message (fun t -> GrantRoleStmt.from_proto t)), fun v -> `Grant_role_stmt v); oneof_elem (67, (message (fun t -> AlterDefaultPrivilegesStmt.from_proto t)), fun v -> `Alter_default_privileges_stmt v); oneof_elem (68, (message (fun t -> ClosePortalStmt.from_proto t)), fun v -> `Close_portal_stmt v); oneof_elem (69, (message (fun t -> ClusterStmt.from_proto t)), fun v -> `Cluster_stmt v); oneof_elem (70, (message (fun t -> CopyStmt.from_proto t)), fun v -> `Copy_stmt v); oneof_elem (71, (message (fun t -> CreateStmt.from_proto t)), fun v -> `Create_stmt v); oneof_elem (72, (message (fun t -> DefineStmt.from_proto t)), fun v -> `Define_stmt v); oneof_elem (73, (message (fun t -> DropStmt.from_proto t)), fun v -> `Drop_stmt v); oneof_elem (74, (message (fun t -> TruncateStmt.from_proto t)), fun v -> `Truncate_stmt v); oneof_elem (75, (message (fun t -> CommentStmt.from_proto t)), fun v -> `Comment_stmt v); oneof_elem (76, (message (fun t -> FetchStmt.from_proto t)), fun v -> `Fetch_stmt v); oneof_elem (77, (message (fun t -> IndexStmt.from_proto t)), fun v -> `Index_stmt v); oneof_elem (78, (message (fun t -> CreateFunctionStmt.from_proto t)), fun v -> `Create_function_stmt v); oneof_elem (79, (message (fun t -> AlterFunctionStmt.from_proto t)), fun v -> `Alter_function_stmt v); oneof_elem (80, (message (fun t -> DoStmt.from_proto t)), fun v -> `Do_stmt v); oneof_elem (81, (message (fun t -> RenameStmt.from_proto t)), fun v -> `Rename_stmt v); oneof_elem (82, (message (fun t -> RuleStmt.from_proto t)), fun v -> `Rule_stmt v); oneof_elem (83, (message (fun t -> NotifyStmt.from_proto t)), fun v -> `Notify_stmt v); oneof_elem (84, (message (fun t -> ListenStmt.from_proto t)), fun v -> `Listen_stmt v); oneof_elem (85, (message (fun t -> UnlistenStmt.from_proto t)), fun v -> `Unlisten_stmt v); oneof_elem (86, (message (fun t -> TransactionStmt.from_proto t)), fun v -> `Transaction_stmt v); oneof_elem (87, (message (fun t -> ViewStmt.from_proto t)), fun v -> `View_stmt v); oneof_elem (88, (message (fun t -> LoadStmt.from_proto t)), fun v -> `Load_stmt v); oneof_elem (89, (message (fun t -> CreateDomainStmt.from_proto t)), fun v -> `Create_domain_stmt v); oneof_elem (90, (message (fun t -> CreatedbStmt.from_proto t)), fun v -> `Createdb_stmt v); oneof_elem (91, (message (fun t -> DropdbStmt.from_proto t)), fun v -> `Dropdb_stmt v); oneof_elem (92, (message (fun t -> VacuumStmt.from_proto t)), fun v -> `Vacuum_stmt v); oneof_elem (93, (message (fun t -> ExplainStmt.from_proto t)), fun v -> `Explain_stmt v); oneof_elem (94, (message (fun t -> CreateTableAsStmt.from_proto t)), fun v -> `Create_table_as_stmt v); oneof_elem (95, (message (fun t -> CreateSeqStmt.from_proto t)), fun v -> `Create_seq_stmt v); oneof_elem (96, (message (fun t -> AlterSeqStmt.from_proto t)), fun v -> `Alter_seq_stmt v); oneof_elem (97, (message (fun t -> VariableSetStmt.from_proto t)), fun v -> `Variable_set_stmt v); oneof_elem (98, (message (fun t -> VariableShowStmt.from_proto t)), fun v -> `Variable_show_stmt v); oneof_elem (99, (message (fun t -> DiscardStmt.from_proto t)), fun v -> `Discard_stmt v); oneof_elem (100, (message (fun t -> CreateTrigStmt.from_proto t)), fun v -> `Create_trig_stmt v); oneof_elem (101, (message (fun t -> CreatePLangStmt.from_proto t)), fun v -> `Create_plang_stmt v); oneof_elem (102, (message (fun t -> CreateRoleStmt.from_proto t)), fun v -> `Create_role_stmt v); oneof_elem (103, (message (fun t -> AlterRoleStmt.from_proto t)), fun v -> `Alter_role_stmt v); oneof_elem (104, (message (fun t -> DropRoleStmt.from_proto t)), fun v -> `Drop_role_stmt v); oneof_elem (105, (message (fun t -> LockStmt.from_proto t)), fun v -> `Lock_stmt v); oneof_elem (106, (message (fun t -> ConstraintsSetStmt.from_proto t)), fun v -> `Constraints_set_stmt v); oneof_elem (107, (message (fun t -> ReindexStmt.from_proto t)), fun v -> `Reindex_stmt v); oneof_elem (108, (message (fun t -> CheckPointStmt.from_proto t)), fun v -> `Check_point_stmt v); oneof_elem (109, (message (fun t -> CreateSchemaStmt.from_proto t)), fun v -> `Create_schema_stmt v); oneof_elem (110, (message (fun t -> AlterDatabaseStmt.from_proto t)), fun v -> `Alter_database_stmt v); oneof_elem (111, (message (fun t -> AlterDatabaseRefreshCollStmt.from_proto t)), fun v -> `Alter_database_refresh_coll_stmt v); oneof_elem (112, (message (fun t -> AlterDatabaseSetStmt.from_proto t)), fun v -> `Alter_database_set_stmt v); oneof_elem (113, (message (fun t -> AlterRoleSetStmt.from_proto t)), fun v -> `Alter_role_set_stmt v); oneof_elem (114, (message (fun t -> CreateConversionStmt.from_proto t)), fun v -> `Create_conversion_stmt v); oneof_elem (115, (message (fun t -> CreateCastStmt.from_proto t)), fun v -> `Create_cast_stmt v); oneof_elem (116, (message (fun t -> CreateOpClassStmt.from_proto t)), fun v -> `Create_op_class_stmt v); oneof_elem (117, (message (fun t -> CreateOpFamilyStmt.from_proto t)), fun v -> `Create_op_family_stmt v); oneof_elem (118, (message (fun t -> AlterOpFamilyStmt.from_proto t)), fun v -> `Alter_op_family_stmt v); oneof_elem (119, (message (fun t -> PrepareStmt.from_proto t)), fun v -> `Prepare_stmt v); oneof_elem (120, (message (fun t -> ExecuteStmt.from_proto t)), fun v -> `Execute_stmt v); oneof_elem (121, (message (fun t -> DeallocateStmt.from_proto t)), fun v -> `Deallocate_stmt v); oneof_elem (122, (message (fun t -> DeclareCursorStmt.from_proto t)), fun v -> `Declare_cursor_stmt v); oneof_elem (123, (message (fun t -> CreateTableSpaceStmt.from_proto t)), fun v -> `Create_table_space_stmt v); oneof_elem (124, (message (fun t -> DropTableSpaceStmt.from_proto t)), fun v -> `Drop_table_space_stmt v); oneof_elem (125, (message (fun t -> AlterObjectDependsStmt.from_proto t)), fun v -> `Alter_object_depends_stmt v); oneof_elem (126, (message (fun t -> AlterObjectSchemaStmt.from_proto t)), fun v -> `Alter_object_schema_stmt v); oneof_elem (127, (message (fun t -> AlterOwnerStmt.from_proto t)), fun v -> `Alter_owner_stmt v); oneof_elem (128, (message (fun t -> AlterOperatorStmt.from_proto t)), fun v -> `Alter_operator_stmt v); oneof_elem (129, (message (fun t -> AlterTypeStmt.from_proto t)), fun v -> `Alter_type_stmt v); oneof_elem (130, (message (fun t -> DropOwnedStmt.from_proto t)), fun v -> `Drop_owned_stmt v); oneof_elem (131, (message (fun t -> ReassignOwnedStmt.from_proto t)), fun v -> `Reassign_owned_stmt v); oneof_elem (132, (message (fun t -> CompositeTypeStmt.from_proto t)), fun v -> `Composite_type_stmt v); oneof_elem (133, (message (fun t -> CreateEnumStmt.from_proto t)), fun v -> `Create_enum_stmt v); oneof_elem (134, (message (fun t -> CreateRangeStmt.from_proto t)), fun v -> `Create_range_stmt v); oneof_elem (135, (message (fun t -> AlterEnumStmt.from_proto t)), fun v -> `Alter_enum_stmt v); oneof_elem (136, (message (fun t -> AlterTSDictionaryStmt.from_proto t)), fun v -> `Alter_tsdictionary_stmt v); oneof_elem (137, (message (fun t -> AlterTSConfigurationStmt.from_proto t)), fun v -> `Alter_tsconfiguration_stmt v); oneof_elem (138, (message (fun t -> CreateFdwStmt.from_proto t)), fun v -> `Create_fdw_stmt v); oneof_elem (139, (message (fun t -> AlterFdwStmt.from_proto t)), fun v -> `Alter_fdw_stmt v); oneof_elem (140, (message (fun t -> CreateForeignServerStmt.from_proto t)), fun v -> `Create_foreign_server_stmt v); oneof_elem (141, (message (fun t -> AlterForeignServerStmt.from_proto t)), fun v -> `Alter_foreign_server_stmt v); oneof_elem (142, (message (fun t -> CreateUserMappingStmt.from_proto t)), fun v -> `Create_user_mapping_stmt v); oneof_elem (143, (message (fun t -> AlterUserMappingStmt.from_proto t)), fun v -> `Alter_user_mapping_stmt v); oneof_elem (144, (message (fun t -> DropUserMappingStmt.from_proto t)), fun v -> `Drop_user_mapping_stmt v); oneof_elem (145, (message (fun t -> AlterTableSpaceOptionsStmt.from_proto t)), fun v -> `Alter_table_space_options_stmt v); oneof_elem (146, (message (fun t -> AlterTableMoveAllStmt.from_proto t)), fun v -> `Alter_table_move_all_stmt v); oneof_elem (147, (message (fun t -> SecLabelStmt.from_proto t)), fun v -> `Sec_label_stmt v); oneof_elem (148, (message (fun t -> CreateForeignTableStmt.from_proto t)), fun v -> `Create_foreign_table_stmt v); oneof_elem (149, (message (fun t -> ImportForeignSchemaStmt.from_proto t)), fun v -> `Import_foreign_schema_stmt v); oneof_elem (150, (message (fun t -> CreateExtensionStmt.from_proto t)), fun v -> `Create_extension_stmt v); oneof_elem (151, (message (fun t -> AlterExtensionStmt.from_proto t)), fun v -> `Alter_extension_stmt v); oneof_elem (152, (message (fun t -> AlterExtensionContentsStmt.from_proto t)), fun v -> `Alter_extension_contents_stmt v); oneof_elem (153, (message (fun t -> CreateEventTrigStmt.from_proto t)), fun v -> `Create_event_trig_stmt v); oneof_elem (154, (message (fun t -> AlterEventTrigStmt.from_proto t)), fun v -> `Alter_event_trig_stmt v); oneof_elem (155, (message (fun t -> RefreshMatViewStmt.from_proto t)), fun v -> `Refresh_mat_view_stmt v); oneof_elem (156, (message (fun t -> ReplicaIdentityStmt.from_proto t)), fun v -> `Replica_identity_stmt v); oneof_elem (157, (message (fun t -> AlterSystemStmt.from_proto t)), fun v -> `Alter_system_stmt v); oneof_elem (158, (message (fun t -> CreatePolicyStmt.from_proto t)), fun v -> `Create_policy_stmt v); oneof_elem (159, (message (fun t -> AlterPolicyStmt.from_proto t)), fun v -> `Alter_policy_stmt v); oneof_elem (160, (message (fun t -> CreateTransformStmt.from_proto t)), fun v -> `Create_transform_stmt v); oneof_elem (161, (message (fun t -> CreateAmStmt.from_proto t)), fun v -> `Create_am_stmt v); oneof_elem (162, (message (fun t -> CreatePublicationStmt.from_proto t)), fun v -> `Create_publication_stmt v); oneof_elem (163, (message (fun t -> AlterPublicationStmt.from_proto t)), fun v -> `Alter_publication_stmt v); oneof_elem (164, (message (fun t -> CreateSubscriptionStmt.from_proto t)), fun v -> `Create_subscription_stmt v); oneof_elem (165, (message (fun t -> AlterSubscriptionStmt.from_proto t)), fun v -> `Alter_subscription_stmt v); oneof_elem (166, (message (fun t -> DropSubscriptionStmt.from_proto t)), fun v -> `Drop_subscription_stmt v); oneof_elem (167, (message (fun t -> CreateStatsStmt.from_proto t)), fun v -> `Create_stats_stmt v); oneof_elem (168, (message (fun t -> AlterCollationStmt.from_proto t)), fun v -> `Alter_collation_stmt v); oneof_elem (169, (message (fun t -> CallStmt.from_proto t)), fun v -> `Call_stmt v); oneof_elem (170, (message (fun t -> AlterStatsStmt.from_proto t)), fun v -> `Alter_stats_stmt v); oneof_elem (171, (message (fun t -> A_Expr.from_proto t)), fun v -> `A_expr v); oneof_elem (172, (message (fun t -> ColumnRef.from_proto t)), fun v -> `Column_ref v); oneof_elem (173, (message (fun t -> ParamRef.from_proto t)), fun v -> `Param_ref v); oneof_elem (174, (message (fun t -> FuncCall.from_proto t)), fun v -> `Func_call v); oneof_elem (175, (message (fun t -> A_Star.from_proto t)), fun v -> `A_star v); oneof_elem (176, (message (fun t -> A_Indices.from_proto t)), fun v -> `A_indices v); oneof_elem (177, (message (fun t -> A_Indirection.from_proto t)), fun v -> `A_indirection v); oneof_elem (178, (message (fun t -> A_ArrayExpr.from_proto t)), fun v -> `A_array_expr v); oneof_elem (179, (message (fun t -> ResTarget.from_proto t)), fun v -> `Res_target v); oneof_elem (180, (message (fun t -> MultiAssignRef.from_proto t)), fun v -> `Multi_assign_ref v); oneof_elem (181, (message (fun t -> TypeCast.from_proto t)), fun v -> `Type_cast v); oneof_elem (182, (message (fun t -> CollateClause.from_proto t)), fun v -> `Collate_clause v); oneof_elem (183, (message (fun t -> SortBy.from_proto t)), fun v -> `Sort_by v); oneof_elem (184, (message (fun t -> WindowDef.from_proto t)), fun v -> `Window_def v); oneof_elem (185, (message (fun t -> RangeSubselect.from_proto t)), fun v -> `Range_subselect v); oneof_elem (186, (message (fun t -> RangeFunction.from_proto t)), fun v -> `Range_function v); oneof_elem (187, (message (fun t -> RangeTableSample.from_proto t)), fun v -> `Range_table_sample v); oneof_elem (188, (message (fun t -> RangeTableFunc.from_proto t)), fun v -> `Range_table_func v); oneof_elem (189, (message (fun t -> RangeTableFuncCol.from_proto t)), fun v -> `Range_table_func_col v); oneof_elem (190, (message (fun t -> TypeName.from_proto t)), fun v -> `Type_name v); oneof_elem (191, (message (fun t -> ColumnDef.from_proto t)), fun v -> `Column_def v); oneof_elem (192, (message (fun t -> IndexElem.from_proto t)), fun v -> `Index_elem v); oneof_elem (193, (message (fun t -> StatsElem.from_proto t)), fun v -> `Stats_elem v); oneof_elem (194, (message (fun t -> Constraint.from_proto t)), fun v -> `Constraint v); oneof_elem (195, (message (fun t -> DefElem.from_proto t)), fun v -> `Def_elem v); oneof_elem (196, (message (fun t -> RangeTblEntry.from_proto t)), fun v -> `Range_tbl_entry v); oneof_elem (197, (message (fun t -> RangeTblFunction.from_proto t)), fun v -> `Range_tbl_function v); oneof_elem (198, (message (fun t -> TableSampleClause.from_proto t)), fun v -> `Table_sample_clause v); oneof_elem (199, (message (fun t -> WithCheckOption.from_proto t)), fun v -> `With_check_option v); oneof_elem (200, (message (fun t -> SortGroupClause.from_proto t)), fun v -> `Sort_group_clause v); oneof_elem (201, (message (fun t -> GroupingSet.from_proto t)), fun v -> `Grouping_set v); oneof_elem (202, (message (fun t -> WindowClause.from_proto t)), fun v -> `Window_clause v); oneof_elem (203, (message (fun t -> ObjectWithArgs.from_proto t)), fun v -> `Object_with_args v); oneof_elem (204, (message (fun t -> AccessPriv.from_proto t)), fun v -> `Access_priv v); oneof_elem (205, (message (fun t -> CreateOpClassItem.from_proto t)), fun v -> `Create_op_class_item v); oneof_elem (206, (message (fun t -> TableLikeClause.from_proto t)), fun v -> `Table_like_clause v); oneof_elem (207, (message (fun t -> FunctionParameter.from_proto t)), fun v -> `Function_parameter v); oneof_elem (208, (message (fun t -> LockingClause.from_proto t)), fun v -> `Locking_clause v); oneof_elem (209, (message (fun t -> RowMarkClause.from_proto t)), fun v -> `Row_mark_clause v); oneof_elem (210, (message (fun t -> XmlSerialize.from_proto t)), fun v -> `Xml_serialize v); oneof_elem (211, (message (fun t -> WithClause.from_proto t)), fun v -> `With_clause v); oneof_elem (212, (message (fun t -> InferClause.from_proto t)), fun v -> `Infer_clause v); oneof_elem (213, (message (fun t -> OnConflictClause.from_proto t)), fun v -> `On_conflict_clause v); oneof_elem (214, (message (fun t -> CTESearchClause.from_proto t)), fun v -> `Ctesearch_clause v); oneof_elem (215, (message (fun t -> CTECycleClause.from_proto t)), fun v -> `Ctecycle_clause v); oneof_elem (216, (message (fun t -> CommonTableExpr.from_proto t)), fun v -> `Common_table_expr v); oneof_elem (217, (message (fun t -> MergeWhenClause.from_proto t)), fun v -> `Merge_when_clause v); oneof_elem (218, (message (fun t -> RoleSpec.from_proto t)), fun v -> `Role_spec v); oneof_elem (219, (message (fun t -> TriggerTransition.from_proto t)), fun v -> `Trigger_transition v); oneof_elem (220, (message (fun t -> PartitionElem.from_proto t)), fun v -> `Partition_elem v); oneof_elem (221, (message (fun t -> PartitionSpec.from_proto t)), fun v -> `Partition_spec v); oneof_elem (222, (message (fun t -> PartitionBoundSpec.from_proto t)), fun v -> `Partition_bound_spec v); oneof_elem (223, (message (fun t -> PartitionRangeDatum.from_proto t)), fun v -> `Partition_range_datum v); oneof_elem (224, (message (fun t -> PartitionCmd.from_proto t)), fun v -> `Partition_cmd v); oneof_elem (225, (message (fun t -> VacuumRelation.from_proto t)), fun v -> `Vacuum_relation v); oneof_elem (226, (message (fun t -> PublicationObjSpec.from_proto t)), fun v -> `Publication_obj_spec v); oneof_elem (227, (message (fun t -> PublicationTable.from_proto t)), fun v -> `Publication_table v); oneof_elem (228, (message (fun t -> InlineCodeBlock.from_proto t)), fun v -> `Inline_code_block v); oneof_elem (229, (message (fun t -> CallContext.from_proto t)), fun v -> `Call_context v); oneof_elem (230, (message (fun t -> Integer.from_proto t)), fun v -> `Integer v); oneof_elem (231, (message (fun t -> Float.from_proto t)), fun v -> `Float v); oneof_elem (232, (message (fun t -> Boolean.from_proto t)), fun v -> `Boolean v); oneof_elem (233, (message (fun t -> String.from_proto t)), fun v -> `String v); oneof_elem (234, (message (fun t -> BitString.from_proto t)), fun v -> `Bit_string v); oneof_elem (235, (message (fun t -> List.from_proto t)), fun v -> `List v); oneof_elem (236, (message (fun t -> IntList.from_proto t)), fun v -> `Int_list v); oneof_elem (237, (message (fun t -> OidList.from_proto t)), fun v -> `Oid_list v); oneof_elem (238, (message (fun t -> A_Const.from_proto t)), fun v -> `A_const v) ]) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Integer : sig
    val name': unit -> string
    type t = int 
    val make : ?ival:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.Integer"
    type t = int
    let make =
      fun ?ival () -> 
      let ival = match ival with Some v -> v | None -> 0 in
      ival
    
    let to_proto =
      let apply = fun ~f:f' ival -> f' [] ival in
      let spec = Runtime'.Serialize.C.( basic (1, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions ival -> ival in
      let spec = Runtime'.Deserialize.C.( basic (1, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Float : sig
    val name': unit -> string
    type t = string 
    val make : ?fval:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.Float"
    type t = string
    let make =
      fun ?fval () -> 
      let fval = match fval with Some v -> v | None -> {||} in
      fval
    
    let to_proto =
      let apply = fun ~f:f' fval -> f' [] fval in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions fval -> fval in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Boolean : sig
    val name': unit -> string
    type t = bool 
    val make : ?boolval:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.Boolean"
    type t = bool
    let make =
      fun ?boolval () -> 
      let boolval = match boolval with Some v -> v | None -> false in
      boolval
    
    let to_proto =
      let apply = fun ~f:f' boolval -> f' [] boolval in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions boolval -> boolval in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and String : sig
    val name': unit -> string
    type t = string 
    val make : ?sval:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.String"
    type t = string
    let make =
      fun ?sval () -> 
      let sval = match sval with Some v -> v | None -> {||} in
      sval
    
    let to_proto =
      let apply = fun ~f:f' sval -> f' [] sval in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions sval -> sval in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and BitString : sig
    val name': unit -> string
    type t = string 
    val make : ?bsval:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.BitString"
    type t = string
    let make =
      fun ?bsval () -> 
      let bsval = match bsval with Some v -> v | None -> {||} in
      bsval
    
    let to_proto =
      let apply = fun ~f:f' bsval -> f' [] bsval in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions bsval -> bsval in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and List : sig
    val name': unit -> string
    type t = Node.t list 
    val make : ?items:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.List"
    type t = Node.t list
    let make =
      fun ?items () -> 
      let items = match items with Some v -> v | None -> [] in
      items
    
    let to_proto =
      let apply = fun ~f:f' items -> f' [] items in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions items -> items in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and OidList : sig
    val name': unit -> string
    type t = Node.t list 
    val make : ?items:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.OidList"
    type t = Node.t list
    let make =
      fun ?items () -> 
      let items = match items with Some v -> v | None -> [] in
      items
    
    let to_proto =
      let apply = fun ~f:f' items -> f' [] items in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions items -> items in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and IntList : sig
    val name': unit -> string
    type t = Node.t list 
    val make : ?items:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.IntList"
    type t = Node.t list
    let make =
      fun ?items () -> 
      let items = match items with Some v -> v | None -> [] in
      items
    
    let to_proto =
      let apply = fun ~f:f' items -> f' [] items in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions items -> items in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and A_Const : sig
    val name': unit -> string
    type t = { val': [ `not_set | `Ival of Integer.t | `Fval of Float.t | `Boolval of Boolean.t | `Sval of String.t | `Bsval of BitString.t ]; isnull: bool; location: int } 
    val make : ?val':[ `not_set | `Ival of Integer.t | `Fval of Float.t | `Boolval of Boolean.t | `Sval of String.t | `Bsval of BitString.t ] -> ?isnull:bool -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.A_Const"
    type t = { val': [ `not_set | `Ival of Integer.t | `Fval of Float.t | `Boolval of Boolean.t | `Sval of String.t | `Bsval of BitString.t ]; isnull: bool; location: int }
    let make =
      fun ?val' ?isnull ?location () -> 
      let val' = match val' with Some v -> v | None -> `not_set in
      let isnull = match isnull with Some v -> v | None -> false in
      let location = match location with Some v -> v | None -> 0 in
      { val'; isnull; location }
    
    let to_proto =
      let apply = fun ~f:f' { val'; isnull; location } -> f' [] val' isnull location in
      let spec = Runtime'.Serialize.C.( oneof ((function | `not_set -> failwith "This case should never _ever_ happen" | `Ival v -> oneof_elem (1, (message (fun t -> Integer.to_proto t)), v) | `Fval v -> oneof_elem (2, (message (fun t -> Float.to_proto t)), v) | `Boolval v -> oneof_elem (3, (message (fun t -> Boolean.to_proto t)), v) | `Sval v -> oneof_elem (4, (message (fun t -> String.to_proto t)), v) | `Bsval v -> oneof_elem (5, (message (fun t -> BitString.to_proto t)), v))) ^:: basic (10, bool, proto3) ^:: basic (11, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions val' isnull location -> { val'; isnull; location } in
      let spec = Runtime'.Deserialize.C.( oneof ([ oneof_elem (1, (message (fun t -> Integer.from_proto t)), fun v -> `Ival v); oneof_elem (2, (message (fun t -> Float.from_proto t)), fun v -> `Fval v); oneof_elem (3, (message (fun t -> Boolean.from_proto t)), fun v -> `Boolval v); oneof_elem (4, (message (fun t -> String.from_proto t)), fun v -> `Sval v); oneof_elem (5, (message (fun t -> BitString.from_proto t)), fun v -> `Bsval v) ]) ^:: basic (10, bool, proto3) ^:: basic (11, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Alias : sig
    val name': unit -> string
    type t = { aliasname: string; colnames: Node.t list } 
    val make : ?aliasname:string -> ?colnames:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.Alias"
    type t = { aliasname: string; colnames: Node.t list }
    let make =
      fun ?aliasname ?colnames () -> 
      let aliasname = match aliasname with Some v -> v | None -> {||} in
      let colnames = match colnames with Some v -> v | None -> [] in
      { aliasname; colnames }
    
    let to_proto =
      let apply = fun ~f:f' { aliasname; colnames } -> f' [] aliasname colnames in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions aliasname colnames -> { aliasname; colnames } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RangeVar : sig
    val name': unit -> string
    type t = { catalogname: string; schemaname: string; relname: string; inh: bool; relpersistence: string; alias: Alias.t option; location: int } 
    val make : ?catalogname:string -> ?schemaname:string -> ?relname:string -> ?inh:bool -> ?relpersistence:string -> ?alias:Alias.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RangeVar"
    type t = { catalogname: string; schemaname: string; relname: string; inh: bool; relpersistence: string; alias: Alias.t option; location: int }
    let make =
      fun ?catalogname ?schemaname ?relname ?inh ?relpersistence ?alias ?location () -> 
      let catalogname = match catalogname with Some v -> v | None -> {||} in
      let schemaname = match schemaname with Some v -> v | None -> {||} in
      let relname = match relname with Some v -> v | None -> {||} in
      let inh = match inh with Some v -> v | None -> false in
      let relpersistence = match relpersistence with Some v -> v | None -> {||} in
      let location = match location with Some v -> v | None -> 0 in
      { catalogname; schemaname; relname; inh; relpersistence; alias; location }
    
    let to_proto =
      let apply = fun ~f:f' { catalogname; schemaname; relname; inh; relpersistence; alias; location } -> f' [] catalogname schemaname relname inh relpersistence alias location in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: basic (4, bool, proto3) ^:: basic (5, string, proto3) ^:: basic_opt (6, (message (fun t -> Alias.to_proto t))) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions catalogname schemaname relname inh relpersistence alias location -> { catalogname; schemaname; relname; inh; relpersistence; alias; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: basic (4, bool, proto3) ^:: basic (5, string, proto3) ^:: basic_opt (6, (message (fun t -> Alias.from_proto t))) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and TableFunc : sig
    val name': unit -> string
    type t = { ns_uris: Node.t list; ns_names: Node.t list; docexpr: Node.t option; rowexpr: Node.t option; colnames: Node.t list; coltypes: Node.t list; coltypmods: Node.t list; colcollations: Node.t list; colexprs: Node.t list; coldefexprs: Node.t list; notnulls: int list; ordinalitycol: int; location: int } 
    val make : ?ns_uris:Node.t list -> ?ns_names:Node.t list -> ?docexpr:Node.t -> ?rowexpr:Node.t -> ?colnames:Node.t list -> ?coltypes:Node.t list -> ?coltypmods:Node.t list -> ?colcollations:Node.t list -> ?colexprs:Node.t list -> ?coldefexprs:Node.t list -> ?notnulls:int list -> ?ordinalitycol:int -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.TableFunc"
    type t = { ns_uris: Node.t list; ns_names: Node.t list; docexpr: Node.t option; rowexpr: Node.t option; colnames: Node.t list; coltypes: Node.t list; coltypmods: Node.t list; colcollations: Node.t list; colexprs: Node.t list; coldefexprs: Node.t list; notnulls: int list; ordinalitycol: int; location: int }
    let make =
      fun ?ns_uris ?ns_names ?docexpr ?rowexpr ?colnames ?coltypes ?coltypmods ?colcollations ?colexprs ?coldefexprs ?notnulls ?ordinalitycol ?location () -> 
      let ns_uris = match ns_uris with Some v -> v | None -> [] in
      let ns_names = match ns_names with Some v -> v | None -> [] in
      let colnames = match colnames with Some v -> v | None -> [] in
      let coltypes = match coltypes with Some v -> v | None -> [] in
      let coltypmods = match coltypmods with Some v -> v | None -> [] in
      let colcollations = match colcollations with Some v -> v | None -> [] in
      let colexprs = match colexprs with Some v -> v | None -> [] in
      let coldefexprs = match coldefexprs with Some v -> v | None -> [] in
      let notnulls = match notnulls with Some v -> v | None -> [] in
      let ordinalitycol = match ordinalitycol with Some v -> v | None -> 0 in
      let location = match location with Some v -> v | None -> 0 in
      { ns_uris; ns_names; docexpr; rowexpr; colnames; coltypes; coltypmods; colcollations; colexprs; coldefexprs; notnulls; ordinalitycol; location }
    
    let to_proto =
      let apply = fun ~f:f' { ns_uris; ns_names; docexpr; rowexpr; colnames; coltypes; coltypmods; colcollations; colexprs; coldefexprs; notnulls; ordinalitycol; location } -> f' [] ns_uris ns_names docexpr rowexpr colnames coltypes coltypmods colcollations colexprs coldefexprs notnulls ordinalitycol location in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (7, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (8, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (9, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (10, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (11, uint64_int, packed) ^:: basic (12, int32_int, proto3) ^:: basic (13, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions ns_uris ns_names docexpr rowexpr colnames coltypes coltypmods colcollations colexprs coldefexprs notnulls ordinalitycol location -> { ns_uris; ns_names; docexpr; rowexpr; colnames; coltypes; coltypmods; colcollations; colexprs; coldefexprs; notnulls; ordinalitycol; location } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (7, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (8, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (9, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (10, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (11, uint64_int, packed) ^:: basic (12, int32_int, proto3) ^:: basic (13, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Var : sig
    val name': unit -> string
    type t = { xpr: Node.t option; varno: int; varattno: int; vartype: int; vartypmod: int; varcollid: int; varlevelsup: int; varnosyn: int; varattnosyn: int; location: int } 
    val make : ?xpr:Node.t -> ?varno:int -> ?varattno:int -> ?vartype:int -> ?vartypmod:int -> ?varcollid:int -> ?varlevelsup:int -> ?varnosyn:int -> ?varattnosyn:int -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.Var"
    type t = { xpr: Node.t option; varno: int; varattno: int; vartype: int; vartypmod: int; varcollid: int; varlevelsup: int; varnosyn: int; varattnosyn: int; location: int }
    let make =
      fun ?xpr ?varno ?varattno ?vartype ?vartypmod ?varcollid ?varlevelsup ?varnosyn ?varattnosyn ?location () -> 
      let varno = match varno with Some v -> v | None -> 0 in
      let varattno = match varattno with Some v -> v | None -> 0 in
      let vartype = match vartype with Some v -> v | None -> 0 in
      let vartypmod = match vartypmod with Some v -> v | None -> 0 in
      let varcollid = match varcollid with Some v -> v | None -> 0 in
      let varlevelsup = match varlevelsup with Some v -> v | None -> 0 in
      let varnosyn = match varnosyn with Some v -> v | None -> 0 in
      let varattnosyn = match varattnosyn with Some v -> v | None -> 0 in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; varno; varattno; vartype; vartypmod; varcollid; varlevelsup; varnosyn; varattnosyn; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; varno; varattno; vartype; vartypmod; varcollid; varlevelsup; varnosyn; varattnosyn; location } -> f' [] xpr varno varattno vartype vartypmod varcollid varlevelsup varnosyn varattnosyn location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, int32_int, proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, uint32_int, proto3) ^:: basic (7, uint32_int, proto3) ^:: basic (8, uint32_int, proto3) ^:: basic (9, int32_int, proto3) ^:: basic (10, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr varno varattno vartype vartypmod varcollid varlevelsup varnosyn varattnosyn location -> { xpr; varno; varattno; vartype; vartypmod; varcollid; varlevelsup; varnosyn; varattnosyn; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, int32_int, proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, uint32_int, proto3) ^:: basic (7, uint32_int, proto3) ^:: basic (8, uint32_int, proto3) ^:: basic (9, int32_int, proto3) ^:: basic (10, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Param : sig
    val name': unit -> string
    type t = { xpr: Node.t option; paramkind: ParamKind.t; paramid: int; paramtype: int; paramtypmod: int; paramcollid: int; location: int } 
    val make : ?xpr:Node.t -> ?paramkind:ParamKind.t -> ?paramid:int -> ?paramtype:int -> ?paramtypmod:int -> ?paramcollid:int -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.Param"
    type t = { xpr: Node.t option; paramkind: ParamKind.t; paramid: int; paramtype: int; paramtypmod: int; paramcollid: int; location: int }
    let make =
      fun ?xpr ?paramkind ?paramid ?paramtype ?paramtypmod ?paramcollid ?location () -> 
      let paramkind = match paramkind with Some v -> v | None -> (ParamKind.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let paramid = match paramid with Some v -> v | None -> 0 in
      let paramtype = match paramtype with Some v -> v | None -> 0 in
      let paramtypmod = match paramtypmod with Some v -> v | None -> 0 in
      let paramcollid = match paramcollid with Some v -> v | None -> 0 in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; paramkind; paramid; paramtype; paramtypmod; paramcollid; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; paramkind; paramid; paramtype; paramtypmod; paramcollid; location } -> f' [] xpr paramkind paramid paramtype paramtypmod paramcollid location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, (enum ParamKind.to_int), proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, uint32_int, proto3) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr paramkind paramid paramtype paramtypmod paramcollid location -> { xpr; paramkind; paramid; paramtype; paramtypmod; paramcollid; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, (enum ParamKind.from_int), proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, uint32_int, proto3) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Aggref : sig
    val name': unit -> string
    type t = { xpr: Node.t option; aggfnoid: int; aggtype: int; aggcollid: int; inputcollid: int; aggtranstype: int; aggargtypes: Node.t list; aggdirectargs: Node.t list; args: Node.t list; aggorder: Node.t list; aggdistinct: Node.t list; aggfilter: Node.t option; aggstar: bool; aggvariadic: bool; aggkind: string; agglevelsup: int; aggsplit: AggSplit.t; aggno: int; aggtransno: int; location: int } 
    val make : ?xpr:Node.t -> ?aggfnoid:int -> ?aggtype:int -> ?aggcollid:int -> ?inputcollid:int -> ?aggtranstype:int -> ?aggargtypes:Node.t list -> ?aggdirectargs:Node.t list -> ?args:Node.t list -> ?aggorder:Node.t list -> ?aggdistinct:Node.t list -> ?aggfilter:Node.t -> ?aggstar:bool -> ?aggvariadic:bool -> ?aggkind:string -> ?agglevelsup:int -> ?aggsplit:AggSplit.t -> ?aggno:int -> ?aggtransno:int -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.Aggref"
    type t = { xpr: Node.t option; aggfnoid: int; aggtype: int; aggcollid: int; inputcollid: int; aggtranstype: int; aggargtypes: Node.t list; aggdirectargs: Node.t list; args: Node.t list; aggorder: Node.t list; aggdistinct: Node.t list; aggfilter: Node.t option; aggstar: bool; aggvariadic: bool; aggkind: string; agglevelsup: int; aggsplit: AggSplit.t; aggno: int; aggtransno: int; location: int }
    let make =
      fun ?xpr ?aggfnoid ?aggtype ?aggcollid ?inputcollid ?aggtranstype ?aggargtypes ?aggdirectargs ?args ?aggorder ?aggdistinct ?aggfilter ?aggstar ?aggvariadic ?aggkind ?agglevelsup ?aggsplit ?aggno ?aggtransno ?location () -> 
      let aggfnoid = match aggfnoid with Some v -> v | None -> 0 in
      let aggtype = match aggtype with Some v -> v | None -> 0 in
      let aggcollid = match aggcollid with Some v -> v | None -> 0 in
      let inputcollid = match inputcollid with Some v -> v | None -> 0 in
      let aggtranstype = match aggtranstype with Some v -> v | None -> 0 in
      let aggargtypes = match aggargtypes with Some v -> v | None -> [] in
      let aggdirectargs = match aggdirectargs with Some v -> v | None -> [] in
      let args = match args with Some v -> v | None -> [] in
      let aggorder = match aggorder with Some v -> v | None -> [] in
      let aggdistinct = match aggdistinct with Some v -> v | None -> [] in
      let aggstar = match aggstar with Some v -> v | None -> false in
      let aggvariadic = match aggvariadic with Some v -> v | None -> false in
      let aggkind = match aggkind with Some v -> v | None -> {||} in
      let agglevelsup = match agglevelsup with Some v -> v | None -> 0 in
      let aggsplit = match aggsplit with Some v -> v | None -> (AggSplit.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let aggno = match aggno with Some v -> v | None -> 0 in
      let aggtransno = match aggtransno with Some v -> v | None -> 0 in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; aggfnoid; aggtype; aggcollid; inputcollid; aggtranstype; aggargtypes; aggdirectargs; args; aggorder; aggdistinct; aggfilter; aggstar; aggvariadic; aggkind; agglevelsup; aggsplit; aggno; aggtransno; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; aggfnoid; aggtype; aggcollid; inputcollid; aggtranstype; aggargtypes; aggdirectargs; args; aggorder; aggdistinct; aggfilter; aggstar; aggvariadic; aggkind; agglevelsup; aggsplit; aggno; aggtransno; location } -> f' [] xpr aggfnoid aggtype aggcollid inputcollid aggtranstype aggargtypes aggdirectargs args aggorder aggdistinct aggfilter aggstar aggvariadic aggkind agglevelsup aggsplit aggno aggtransno location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, uint32_int, proto3) ^:: basic (6, uint32_int, proto3) ^:: repeated (7, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (8, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (9, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (10, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (11, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (12, (message (fun t -> Node.to_proto t))) ^:: basic (13, bool, proto3) ^:: basic (14, bool, proto3) ^:: basic (15, string, proto3) ^:: basic (16, uint32_int, proto3) ^:: basic (17, (enum AggSplit.to_int), proto3) ^:: basic (18, int32_int, proto3) ^:: basic (19, int32_int, proto3) ^:: basic (20, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr aggfnoid aggtype aggcollid inputcollid aggtranstype aggargtypes aggdirectargs args aggorder aggdistinct aggfilter aggstar aggvariadic aggkind agglevelsup aggsplit aggno aggtransno location -> { xpr; aggfnoid; aggtype; aggcollid; inputcollid; aggtranstype; aggargtypes; aggdirectargs; args; aggorder; aggdistinct; aggfilter; aggstar; aggvariadic; aggkind; agglevelsup; aggsplit; aggno; aggtransno; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, uint32_int, proto3) ^:: basic (6, uint32_int, proto3) ^:: repeated (7, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (8, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (9, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (10, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (11, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (12, (message (fun t -> Node.from_proto t))) ^:: basic (13, bool, proto3) ^:: basic (14, bool, proto3) ^:: basic (15, string, proto3) ^:: basic (16, uint32_int, proto3) ^:: basic (17, (enum AggSplit.from_int), proto3) ^:: basic (18, int32_int, proto3) ^:: basic (19, int32_int, proto3) ^:: basic (20, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and GroupingFunc : sig
    val name': unit -> string
    type t = { xpr: Node.t option; args: Node.t list; refs: Node.t list; cols: Node.t list; agglevelsup: int; location: int } 
    val make : ?xpr:Node.t -> ?args:Node.t list -> ?refs:Node.t list -> ?cols:Node.t list -> ?agglevelsup:int -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.GroupingFunc"
    type t = { xpr: Node.t option; args: Node.t list; refs: Node.t list; cols: Node.t list; agglevelsup: int; location: int }
    let make =
      fun ?xpr ?args ?refs ?cols ?agglevelsup ?location () -> 
      let args = match args with Some v -> v | None -> [] in
      let refs = match refs with Some v -> v | None -> [] in
      let cols = match cols with Some v -> v | None -> [] in
      let agglevelsup = match agglevelsup with Some v -> v | None -> 0 in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; args; refs; cols; agglevelsup; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; args; refs; cols; agglevelsup; location } -> f' [] xpr args refs cols agglevelsup location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (5, uint32_int, proto3) ^:: basic (6, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr args refs cols agglevelsup location -> { xpr; args; refs; cols; agglevelsup; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (5, uint32_int, proto3) ^:: basic (6, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and WindowFunc : sig
    val name': unit -> string
    type t = { xpr: Node.t option; winfnoid: int; wintype: int; wincollid: int; inputcollid: int; args: Node.t list; aggfilter: Node.t option; winref: int; winstar: bool; winagg: bool; location: int } 
    val make : ?xpr:Node.t -> ?winfnoid:int -> ?wintype:int -> ?wincollid:int -> ?inputcollid:int -> ?args:Node.t list -> ?aggfilter:Node.t -> ?winref:int -> ?winstar:bool -> ?winagg:bool -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.WindowFunc"
    type t = { xpr: Node.t option; winfnoid: int; wintype: int; wincollid: int; inputcollid: int; args: Node.t list; aggfilter: Node.t option; winref: int; winstar: bool; winagg: bool; location: int }
    let make =
      fun ?xpr ?winfnoid ?wintype ?wincollid ?inputcollid ?args ?aggfilter ?winref ?winstar ?winagg ?location () -> 
      let winfnoid = match winfnoid with Some v -> v | None -> 0 in
      let wintype = match wintype with Some v -> v | None -> 0 in
      let wincollid = match wincollid with Some v -> v | None -> 0 in
      let inputcollid = match inputcollid with Some v -> v | None -> 0 in
      let args = match args with Some v -> v | None -> [] in
      let winref = match winref with Some v -> v | None -> 0 in
      let winstar = match winstar with Some v -> v | None -> false in
      let winagg = match winagg with Some v -> v | None -> false in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; winfnoid; wintype; wincollid; inputcollid; args; aggfilter; winref; winstar; winagg; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; winfnoid; wintype; wincollid; inputcollid; args; aggfilter; winref; winstar; winagg; location } -> f' [] xpr winfnoid wintype wincollid inputcollid args aggfilter winref winstar winagg location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, uint32_int, proto3) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (7, (message (fun t -> Node.to_proto t))) ^:: basic (8, uint32_int, proto3) ^:: basic (9, bool, proto3) ^:: basic (10, bool, proto3) ^:: basic (11, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr winfnoid wintype wincollid inputcollid args aggfilter winref winstar winagg location -> { xpr; winfnoid; wintype; wincollid; inputcollid; args; aggfilter; winref; winstar; winagg; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, uint32_int, proto3) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (7, (message (fun t -> Node.from_proto t))) ^:: basic (8, uint32_int, proto3) ^:: basic (9, bool, proto3) ^:: basic (10, bool, proto3) ^:: basic (11, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SubscriptingRef : sig
    val name': unit -> string
    type t = { xpr: Node.t option; refcontainertype: int; refelemtype: int; refrestype: int; reftypmod: int; refcollid: int; refupperindexpr: Node.t list; reflowerindexpr: Node.t list; refexpr: Node.t option; refassgnexpr: Node.t option } 
    val make : ?xpr:Node.t -> ?refcontainertype:int -> ?refelemtype:int -> ?refrestype:int -> ?reftypmod:int -> ?refcollid:int -> ?refupperindexpr:Node.t list -> ?reflowerindexpr:Node.t list -> ?refexpr:Node.t -> ?refassgnexpr:Node.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.SubscriptingRef"
    type t = { xpr: Node.t option; refcontainertype: int; refelemtype: int; refrestype: int; reftypmod: int; refcollid: int; refupperindexpr: Node.t list; reflowerindexpr: Node.t list; refexpr: Node.t option; refassgnexpr: Node.t option }
    let make =
      fun ?xpr ?refcontainertype ?refelemtype ?refrestype ?reftypmod ?refcollid ?refupperindexpr ?reflowerindexpr ?refexpr ?refassgnexpr () -> 
      let refcontainertype = match refcontainertype with Some v -> v | None -> 0 in
      let refelemtype = match refelemtype with Some v -> v | None -> 0 in
      let refrestype = match refrestype with Some v -> v | None -> 0 in
      let reftypmod = match reftypmod with Some v -> v | None -> 0 in
      let refcollid = match refcollid with Some v -> v | None -> 0 in
      let refupperindexpr = match refupperindexpr with Some v -> v | None -> [] in
      let reflowerindexpr = match reflowerindexpr with Some v -> v | None -> [] in
      { xpr; refcontainertype; refelemtype; refrestype; reftypmod; refcollid; refupperindexpr; reflowerindexpr; refexpr; refassgnexpr }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; refcontainertype; refelemtype; refrestype; reftypmod; refcollid; refupperindexpr; reflowerindexpr; refexpr; refassgnexpr } -> f' [] xpr refcontainertype refelemtype refrestype reftypmod refcollid refupperindexpr reflowerindexpr refexpr refassgnexpr in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, uint32_int, proto3) ^:: repeated (7, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (8, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (9, (message (fun t -> Node.to_proto t))) ^:: basic_opt (10, (message (fun t -> Node.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr refcontainertype refelemtype refrestype reftypmod refcollid refupperindexpr reflowerindexpr refexpr refassgnexpr -> { xpr; refcontainertype; refelemtype; refrestype; reftypmod; refcollid; refupperindexpr; reflowerindexpr; refexpr; refassgnexpr } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, uint32_int, proto3) ^:: repeated (7, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (8, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (9, (message (fun t -> Node.from_proto t))) ^:: basic_opt (10, (message (fun t -> Node.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and FuncExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; funcid: int; funcresulttype: int; funcretset: bool; funcvariadic: bool; funcformat: CoercionForm.t; funccollid: int; inputcollid: int; args: Node.t list; location: int } 
    val make : ?xpr:Node.t -> ?funcid:int -> ?funcresulttype:int -> ?funcretset:bool -> ?funcvariadic:bool -> ?funcformat:CoercionForm.t -> ?funccollid:int -> ?inputcollid:int -> ?args:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.FuncExpr"
    type t = { xpr: Node.t option; funcid: int; funcresulttype: int; funcretset: bool; funcvariadic: bool; funcformat: CoercionForm.t; funccollid: int; inputcollid: int; args: Node.t list; location: int }
    let make =
      fun ?xpr ?funcid ?funcresulttype ?funcretset ?funcvariadic ?funcformat ?funccollid ?inputcollid ?args ?location () -> 
      let funcid = match funcid with Some v -> v | None -> 0 in
      let funcresulttype = match funcresulttype with Some v -> v | None -> 0 in
      let funcretset = match funcretset with Some v -> v | None -> false in
      let funcvariadic = match funcvariadic with Some v -> v | None -> false in
      let funcformat = match funcformat with Some v -> v | None -> (CoercionForm.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let funccollid = match funccollid with Some v -> v | None -> 0 in
      let inputcollid = match inputcollid with Some v -> v | None -> 0 in
      let args = match args with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; funcid; funcresulttype; funcretset; funcvariadic; funcformat; funccollid; inputcollid; args; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; funcid; funcresulttype; funcretset; funcvariadic; funcformat; funccollid; inputcollid; args; location } -> f' [] xpr funcid funcresulttype funcretset funcvariadic funcformat funccollid inputcollid args location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, bool, proto3) ^:: basic (5, bool, proto3) ^:: basic (6, (enum CoercionForm.to_int), proto3) ^:: basic (7, uint32_int, proto3) ^:: basic (8, uint32_int, proto3) ^:: repeated (9, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (10, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr funcid funcresulttype funcretset funcvariadic funcformat funccollid inputcollid args location -> { xpr; funcid; funcresulttype; funcretset; funcvariadic; funcformat; funccollid; inputcollid; args; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, bool, proto3) ^:: basic (5, bool, proto3) ^:: basic (6, (enum CoercionForm.from_int), proto3) ^:: basic (7, uint32_int, proto3) ^:: basic (8, uint32_int, proto3) ^:: repeated (9, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (10, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and NamedArgExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; arg: Node.t option; name: string; argnumber: int; location: int } 
    val make : ?xpr:Node.t -> ?arg:Node.t -> ?name:string -> ?argnumber:int -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.NamedArgExpr"
    type t = { xpr: Node.t option; arg: Node.t option; name: string; argnumber: int; location: int }
    let make =
      fun ?xpr ?arg ?name ?argnumber ?location () -> 
      let name = match name with Some v -> v | None -> {||} in
      let argnumber = match argnumber with Some v -> v | None -> 0 in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; arg; name; argnumber; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; arg; name; argnumber; location } -> f' [] xpr arg name argnumber location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic (3, string, proto3) ^:: basic (4, int32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr arg name argnumber location -> { xpr; arg; name; argnumber; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic (3, string, proto3) ^:: basic (4, int32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and OpExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; opno: int; opfuncid: int; opresulttype: int; opretset: bool; opcollid: int; inputcollid: int; args: Node.t list; location: int } 
    val make : ?xpr:Node.t -> ?opno:int -> ?opfuncid:int -> ?opresulttype:int -> ?opretset:bool -> ?opcollid:int -> ?inputcollid:int -> ?args:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.OpExpr"
    type t = { xpr: Node.t option; opno: int; opfuncid: int; opresulttype: int; opretset: bool; opcollid: int; inputcollid: int; args: Node.t list; location: int }
    let make =
      fun ?xpr ?opno ?opfuncid ?opresulttype ?opretset ?opcollid ?inputcollid ?args ?location () -> 
      let opno = match opno with Some v -> v | None -> 0 in
      let opfuncid = match opfuncid with Some v -> v | None -> 0 in
      let opresulttype = match opresulttype with Some v -> v | None -> 0 in
      let opretset = match opretset with Some v -> v | None -> false in
      let opcollid = match opcollid with Some v -> v | None -> 0 in
      let inputcollid = match inputcollid with Some v -> v | None -> 0 in
      let args = match args with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; opno; opfuncid; opresulttype; opretset; opcollid; inputcollid; args; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; opno; opfuncid; opresulttype; opretset; opcollid; inputcollid; args; location } -> f' [] xpr opno opfuncid opresulttype opretset opcollid inputcollid args location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, bool, proto3) ^:: basic (6, uint32_int, proto3) ^:: basic (7, uint32_int, proto3) ^:: repeated (8, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (9, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr opno opfuncid opresulttype opretset opcollid inputcollid args location -> { xpr; opno; opfuncid; opresulttype; opretset; opcollid; inputcollid; args; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, bool, proto3) ^:: basic (6, uint32_int, proto3) ^:: basic (7, uint32_int, proto3) ^:: repeated (8, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (9, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DistinctExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; opno: int; opfuncid: int; opresulttype: int; opretset: bool; opcollid: int; inputcollid: int; args: Node.t list; location: int } 
    val make : ?xpr:Node.t -> ?opno:int -> ?opfuncid:int -> ?opresulttype:int -> ?opretset:bool -> ?opcollid:int -> ?inputcollid:int -> ?args:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.DistinctExpr"
    type t = { xpr: Node.t option; opno: int; opfuncid: int; opresulttype: int; opretset: bool; opcollid: int; inputcollid: int; args: Node.t list; location: int }
    let make =
      fun ?xpr ?opno ?opfuncid ?opresulttype ?opretset ?opcollid ?inputcollid ?args ?location () -> 
      let opno = match opno with Some v -> v | None -> 0 in
      let opfuncid = match opfuncid with Some v -> v | None -> 0 in
      let opresulttype = match opresulttype with Some v -> v | None -> 0 in
      let opretset = match opretset with Some v -> v | None -> false in
      let opcollid = match opcollid with Some v -> v | None -> 0 in
      let inputcollid = match inputcollid with Some v -> v | None -> 0 in
      let args = match args with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; opno; opfuncid; opresulttype; opretset; opcollid; inputcollid; args; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; opno; opfuncid; opresulttype; opretset; opcollid; inputcollid; args; location } -> f' [] xpr opno opfuncid opresulttype opretset opcollid inputcollid args location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, bool, proto3) ^:: basic (6, uint32_int, proto3) ^:: basic (7, uint32_int, proto3) ^:: repeated (8, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (9, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr opno opfuncid opresulttype opretset opcollid inputcollid args location -> { xpr; opno; opfuncid; opresulttype; opretset; opcollid; inputcollid; args; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, bool, proto3) ^:: basic (6, uint32_int, proto3) ^:: basic (7, uint32_int, proto3) ^:: repeated (8, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (9, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and NullIfExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; opno: int; opfuncid: int; opresulttype: int; opretset: bool; opcollid: int; inputcollid: int; args: Node.t list; location: int } 
    val make : ?xpr:Node.t -> ?opno:int -> ?opfuncid:int -> ?opresulttype:int -> ?opretset:bool -> ?opcollid:int -> ?inputcollid:int -> ?args:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.NullIfExpr"
    type t = { xpr: Node.t option; opno: int; opfuncid: int; opresulttype: int; opretset: bool; opcollid: int; inputcollid: int; args: Node.t list; location: int }
    let make =
      fun ?xpr ?opno ?opfuncid ?opresulttype ?opretset ?opcollid ?inputcollid ?args ?location () -> 
      let opno = match opno with Some v -> v | None -> 0 in
      let opfuncid = match opfuncid with Some v -> v | None -> 0 in
      let opresulttype = match opresulttype with Some v -> v | None -> 0 in
      let opretset = match opretset with Some v -> v | None -> false in
      let opcollid = match opcollid with Some v -> v | None -> 0 in
      let inputcollid = match inputcollid with Some v -> v | None -> 0 in
      let args = match args with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; opno; opfuncid; opresulttype; opretset; opcollid; inputcollid; args; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; opno; opfuncid; opresulttype; opretset; opcollid; inputcollid; args; location } -> f' [] xpr opno opfuncid opresulttype opretset opcollid inputcollid args location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, bool, proto3) ^:: basic (6, uint32_int, proto3) ^:: basic (7, uint32_int, proto3) ^:: repeated (8, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (9, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr opno opfuncid opresulttype opretset opcollid inputcollid args location -> { xpr; opno; opfuncid; opresulttype; opretset; opcollid; inputcollid; args; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, bool, proto3) ^:: basic (6, uint32_int, proto3) ^:: basic (7, uint32_int, proto3) ^:: repeated (8, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (9, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ScalarArrayOpExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; opno: int; opfuncid: int; hashfuncid: int; negfuncid: int; use_or: bool; inputcollid: int; args: Node.t list; location: int } 
    val make : ?xpr:Node.t -> ?opno:int -> ?opfuncid:int -> ?hashfuncid:int -> ?negfuncid:int -> ?use_or:bool -> ?inputcollid:int -> ?args:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ScalarArrayOpExpr"
    type t = { xpr: Node.t option; opno: int; opfuncid: int; hashfuncid: int; negfuncid: int; use_or: bool; inputcollid: int; args: Node.t list; location: int }
    let make =
      fun ?xpr ?opno ?opfuncid ?hashfuncid ?negfuncid ?use_or ?inputcollid ?args ?location () -> 
      let opno = match opno with Some v -> v | None -> 0 in
      let opfuncid = match opfuncid with Some v -> v | None -> 0 in
      let hashfuncid = match hashfuncid with Some v -> v | None -> 0 in
      let negfuncid = match negfuncid with Some v -> v | None -> 0 in
      let use_or = match use_or with Some v -> v | None -> false in
      let inputcollid = match inputcollid with Some v -> v | None -> 0 in
      let args = match args with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; opno; opfuncid; hashfuncid; negfuncid; use_or; inputcollid; args; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; opno; opfuncid; hashfuncid; negfuncid; use_or; inputcollid; args; location } -> f' [] xpr opno opfuncid hashfuncid negfuncid use_or inputcollid args location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, uint32_int, proto3) ^:: basic (6, bool, proto3) ^:: basic (7, uint32_int, proto3) ^:: repeated (8, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (9, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr opno opfuncid hashfuncid negfuncid use_or inputcollid args location -> { xpr; opno; opfuncid; hashfuncid; negfuncid; use_or; inputcollid; args; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, uint32_int, proto3) ^:: basic (6, bool, proto3) ^:: basic (7, uint32_int, proto3) ^:: repeated (8, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (9, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and BoolExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; boolop: BoolExprType.t; args: Node.t list; location: int } 
    val make : ?xpr:Node.t -> ?boolop:BoolExprType.t -> ?args:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.BoolExpr"
    type t = { xpr: Node.t option; boolop: BoolExprType.t; args: Node.t list; location: int }
    let make =
      fun ?xpr ?boolop ?args ?location () -> 
      let boolop = match boolop with Some v -> v | None -> (BoolExprType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let args = match args with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; boolop; args; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; boolop; args; location } -> f' [] xpr boolop args location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, (enum BoolExprType.to_int), proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr boolop args location -> { xpr; boolop; args; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, (enum BoolExprType.from_int), proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SubLink : sig
    val name': unit -> string
    type t = { xpr: Node.t option; sub_link_type: SubLinkType.t; sub_link_id: int; testexpr: Node.t option; oper_name: Node.t list; subselect: Node.t option; location: int } 
    val make : ?xpr:Node.t -> ?sub_link_type:SubLinkType.t -> ?sub_link_id:int -> ?testexpr:Node.t -> ?oper_name:Node.t list -> ?subselect:Node.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.SubLink"
    type t = { xpr: Node.t option; sub_link_type: SubLinkType.t; sub_link_id: int; testexpr: Node.t option; oper_name: Node.t list; subselect: Node.t option; location: int }
    let make =
      fun ?xpr ?sub_link_type ?sub_link_id ?testexpr ?oper_name ?subselect ?location () -> 
      let sub_link_type = match sub_link_type with Some v -> v | None -> (SubLinkType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let sub_link_id = match sub_link_id with Some v -> v | None -> 0 in
      let oper_name = match oper_name with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; sub_link_type; sub_link_id; testexpr; oper_name; subselect; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; sub_link_type; sub_link_id; testexpr; oper_name; subselect; location } -> f' [] xpr sub_link_type sub_link_id testexpr oper_name subselect location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, (enum SubLinkType.to_int), proto3) ^:: basic (3, int32_int, proto3) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> Node.to_proto t))) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr sub_link_type sub_link_id testexpr oper_name subselect location -> { xpr; sub_link_type; sub_link_id; testexpr; oper_name; subselect; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, (enum SubLinkType.from_int), proto3) ^:: basic (3, int32_int, proto3) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> Node.from_proto t))) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SubPlan : sig
    val name': unit -> string
    type t = { xpr: Node.t option; sub_link_type: SubLinkType.t; testexpr: Node.t option; param_ids: Node.t list; plan_id: int; plan_name: string; first_col_type: int; first_col_typmod: int; first_col_collation: int; use_hash_table: bool; unknown_eq_false: bool; parallel_safe: bool; set_param: Node.t list; par_param: Node.t list; args: Node.t list; startup_cost: float; per_call_cost: float } 
    val make : ?xpr:Node.t -> ?sub_link_type:SubLinkType.t -> ?testexpr:Node.t -> ?param_ids:Node.t list -> ?plan_id:int -> ?plan_name:string -> ?first_col_type:int -> ?first_col_typmod:int -> ?first_col_collation:int -> ?use_hash_table:bool -> ?unknown_eq_false:bool -> ?parallel_safe:bool -> ?set_param:Node.t list -> ?par_param:Node.t list -> ?args:Node.t list -> ?startup_cost:float -> ?per_call_cost:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.SubPlan"
    type t = { xpr: Node.t option; sub_link_type: SubLinkType.t; testexpr: Node.t option; param_ids: Node.t list; plan_id: int; plan_name: string; first_col_type: int; first_col_typmod: int; first_col_collation: int; use_hash_table: bool; unknown_eq_false: bool; parallel_safe: bool; set_param: Node.t list; par_param: Node.t list; args: Node.t list; startup_cost: float; per_call_cost: float }
    let make =
      fun ?xpr ?sub_link_type ?testexpr ?param_ids ?plan_id ?plan_name ?first_col_type ?first_col_typmod ?first_col_collation ?use_hash_table ?unknown_eq_false ?parallel_safe ?set_param ?par_param ?args ?startup_cost ?per_call_cost () -> 
      let sub_link_type = match sub_link_type with Some v -> v | None -> (SubLinkType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let param_ids = match param_ids with Some v -> v | None -> [] in
      let plan_id = match plan_id with Some v -> v | None -> 0 in
      let plan_name = match plan_name with Some v -> v | None -> {||} in
      let first_col_type = match first_col_type with Some v -> v | None -> 0 in
      let first_col_typmod = match first_col_typmod with Some v -> v | None -> 0 in
      let first_col_collation = match first_col_collation with Some v -> v | None -> 0 in
      let use_hash_table = match use_hash_table with Some v -> v | None -> false in
      let unknown_eq_false = match unknown_eq_false with Some v -> v | None -> false in
      let parallel_safe = match parallel_safe with Some v -> v | None -> false in
      let set_param = match set_param with Some v -> v | None -> [] in
      let par_param = match par_param with Some v -> v | None -> [] in
      let args = match args with Some v -> v | None -> [] in
      let startup_cost = match startup_cost with Some v -> v | None -> 0. in
      let per_call_cost = match per_call_cost with Some v -> v | None -> 0. in
      { xpr; sub_link_type; testexpr; param_ids; plan_id; plan_name; first_col_type; first_col_typmod; first_col_collation; use_hash_table; unknown_eq_false; parallel_safe; set_param; par_param; args; startup_cost; per_call_cost }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; sub_link_type; testexpr; param_ids; plan_id; plan_name; first_col_type; first_col_typmod; first_col_collation; use_hash_table; unknown_eq_false; parallel_safe; set_param; par_param; args; startup_cost; per_call_cost } -> f' [] xpr sub_link_type testexpr param_ids plan_id plan_name first_col_type first_col_typmod first_col_collation use_hash_table unknown_eq_false parallel_safe set_param par_param args startup_cost per_call_cost in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, (enum SubLinkType.to_int), proto3) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (5, int32_int, proto3) ^:: basic (6, string, proto3) ^:: basic (7, uint32_int, proto3) ^:: basic (8, int32_int, proto3) ^:: basic (9, uint32_int, proto3) ^:: basic (10, bool, proto3) ^:: basic (11, bool, proto3) ^:: basic (12, bool, proto3) ^:: repeated (13, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (14, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (15, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (16, double, proto3) ^:: basic (17, double, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr sub_link_type testexpr param_ids plan_id plan_name first_col_type first_col_typmod first_col_collation use_hash_table unknown_eq_false parallel_safe set_param par_param args startup_cost per_call_cost -> { xpr; sub_link_type; testexpr; param_ids; plan_id; plan_name; first_col_type; first_col_typmod; first_col_collation; use_hash_table; unknown_eq_false; parallel_safe; set_param; par_param; args; startup_cost; per_call_cost } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, (enum SubLinkType.from_int), proto3) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (5, int32_int, proto3) ^:: basic (6, string, proto3) ^:: basic (7, uint32_int, proto3) ^:: basic (8, int32_int, proto3) ^:: basic (9, uint32_int, proto3) ^:: basic (10, bool, proto3) ^:: basic (11, bool, proto3) ^:: basic (12, bool, proto3) ^:: repeated (13, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (14, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (15, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (16, double, proto3) ^:: basic (17, double, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlternativeSubPlan : sig
    val name': unit -> string
    type t = { xpr: Node.t option; subplans: Node.t list } 
    val make : ?xpr:Node.t -> ?subplans:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlternativeSubPlan"
    type t = { xpr: Node.t option; subplans: Node.t list }
    let make =
      fun ?xpr ?subplans () -> 
      let subplans = match subplans with Some v -> v | None -> [] in
      { xpr; subplans }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; subplans } -> f' [] xpr subplans in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr subplans -> { xpr; subplans } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and FieldSelect : sig
    val name': unit -> string
    type t = { xpr: Node.t option; arg: Node.t option; fieldnum: int; resulttype: int; resulttypmod: int; resultcollid: int } 
    val make : ?xpr:Node.t -> ?arg:Node.t -> ?fieldnum:int -> ?resulttype:int -> ?resulttypmod:int -> ?resultcollid:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.FieldSelect"
    type t = { xpr: Node.t option; arg: Node.t option; fieldnum: int; resulttype: int; resulttypmod: int; resultcollid: int }
    let make =
      fun ?xpr ?arg ?fieldnum ?resulttype ?resulttypmod ?resultcollid () -> 
      let fieldnum = match fieldnum with Some v -> v | None -> 0 in
      let resulttype = match resulttype with Some v -> v | None -> 0 in
      let resulttypmod = match resulttypmod with Some v -> v | None -> 0 in
      let resultcollid = match resultcollid with Some v -> v | None -> 0 in
      { xpr; arg; fieldnum; resulttype; resulttypmod; resultcollid }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; arg; fieldnum; resulttype; resulttypmod; resultcollid } -> f' [] xpr arg fieldnum resulttype resulttypmod resultcollid in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic (3, int32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, uint32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr arg fieldnum resulttype resulttypmod resultcollid -> { xpr; arg; fieldnum; resulttype; resulttypmod; resultcollid } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic (3, int32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, uint32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and FieldStore : sig
    val name': unit -> string
    type t = { xpr: Node.t option; arg: Node.t option; newvals: Node.t list; fieldnums: Node.t list; resulttype: int } 
    val make : ?xpr:Node.t -> ?arg:Node.t -> ?newvals:Node.t list -> ?fieldnums:Node.t list -> ?resulttype:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.FieldStore"
    type t = { xpr: Node.t option; arg: Node.t option; newvals: Node.t list; fieldnums: Node.t list; resulttype: int }
    let make =
      fun ?xpr ?arg ?newvals ?fieldnums ?resulttype () -> 
      let newvals = match newvals with Some v -> v | None -> [] in
      let fieldnums = match fieldnums with Some v -> v | None -> [] in
      let resulttype = match resulttype with Some v -> v | None -> 0 in
      { xpr; arg; newvals; fieldnums; resulttype }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; arg; newvals; fieldnums; resulttype } -> f' [] xpr arg newvals fieldnums resulttype in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (5, uint32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr arg newvals fieldnums resulttype -> { xpr; arg; newvals; fieldnums; resulttype } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (5, uint32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RelabelType : sig
    val name': unit -> string
    type t = { xpr: Node.t option; arg: Node.t option; resulttype: int; resulttypmod: int; resultcollid: int; relabelformat: CoercionForm.t; location: int } 
    val make : ?xpr:Node.t -> ?arg:Node.t -> ?resulttype:int -> ?resulttypmod:int -> ?resultcollid:int -> ?relabelformat:CoercionForm.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RelabelType"
    type t = { xpr: Node.t option; arg: Node.t option; resulttype: int; resulttypmod: int; resultcollid: int; relabelformat: CoercionForm.t; location: int }
    let make =
      fun ?xpr ?arg ?resulttype ?resulttypmod ?resultcollid ?relabelformat ?location () -> 
      let resulttype = match resulttype with Some v -> v | None -> 0 in
      let resulttypmod = match resulttypmod with Some v -> v | None -> 0 in
      let resultcollid = match resultcollid with Some v -> v | None -> 0 in
      let relabelformat = match relabelformat with Some v -> v | None -> (CoercionForm.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; arg; resulttype; resulttypmod; resultcollid; relabelformat; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; arg; resulttype; resulttypmod; resultcollid; relabelformat; location } -> f' [] xpr arg resulttype resulttypmod resultcollid relabelformat location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic (3, uint32_int, proto3) ^:: basic (4, int32_int, proto3) ^:: basic (5, uint32_int, proto3) ^:: basic (6, (enum CoercionForm.to_int), proto3) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr arg resulttype resulttypmod resultcollid relabelformat location -> { xpr; arg; resulttype; resulttypmod; resultcollid; relabelformat; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic (3, uint32_int, proto3) ^:: basic (4, int32_int, proto3) ^:: basic (5, uint32_int, proto3) ^:: basic (6, (enum CoercionForm.from_int), proto3) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CoerceViaIO : sig
    val name': unit -> string
    type t = { xpr: Node.t option; arg: Node.t option; resulttype: int; resultcollid: int; coerceformat: CoercionForm.t; location: int } 
    val make : ?xpr:Node.t -> ?arg:Node.t -> ?resulttype:int -> ?resultcollid:int -> ?coerceformat:CoercionForm.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CoerceViaIO"
    type t = { xpr: Node.t option; arg: Node.t option; resulttype: int; resultcollid: int; coerceformat: CoercionForm.t; location: int }
    let make =
      fun ?xpr ?arg ?resulttype ?resultcollid ?coerceformat ?location () -> 
      let resulttype = match resulttype with Some v -> v | None -> 0 in
      let resultcollid = match resultcollid with Some v -> v | None -> 0 in
      let coerceformat = match coerceformat with Some v -> v | None -> (CoercionForm.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; arg; resulttype; resultcollid; coerceformat; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; arg; resulttype; resultcollid; coerceformat; location } -> f' [] xpr arg resulttype resultcollid coerceformat location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, (enum CoercionForm.to_int), proto3) ^:: basic (6, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr arg resulttype resultcollid coerceformat location -> { xpr; arg; resulttype; resultcollid; coerceformat; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, (enum CoercionForm.from_int), proto3) ^:: basic (6, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ArrayCoerceExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; arg: Node.t option; elemexpr: Node.t option; resulttype: int; resulttypmod: int; resultcollid: int; coerceformat: CoercionForm.t; location: int } 
    val make : ?xpr:Node.t -> ?arg:Node.t -> ?elemexpr:Node.t -> ?resulttype:int -> ?resulttypmod:int -> ?resultcollid:int -> ?coerceformat:CoercionForm.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ArrayCoerceExpr"
    type t = { xpr: Node.t option; arg: Node.t option; elemexpr: Node.t option; resulttype: int; resulttypmod: int; resultcollid: int; coerceformat: CoercionForm.t; location: int }
    let make =
      fun ?xpr ?arg ?elemexpr ?resulttype ?resulttypmod ?resultcollid ?coerceformat ?location () -> 
      let resulttype = match resulttype with Some v -> v | None -> 0 in
      let resulttypmod = match resulttypmod with Some v -> v | None -> 0 in
      let resultcollid = match resultcollid with Some v -> v | None -> 0 in
      let coerceformat = match coerceformat with Some v -> v | None -> (CoercionForm.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; arg; elemexpr; resulttype; resulttypmod; resultcollid; coerceformat; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; arg; elemexpr; resulttype; resulttypmod; resultcollid; coerceformat; location } -> f' [] xpr arg elemexpr resulttype resulttypmod resultcollid coerceformat location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: basic (4, uint32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, uint32_int, proto3) ^:: basic (7, (enum CoercionForm.to_int), proto3) ^:: basic (8, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr arg elemexpr resulttype resulttypmod resultcollid coerceformat location -> { xpr; arg; elemexpr; resulttype; resulttypmod; resultcollid; coerceformat; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: basic (4, uint32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, uint32_int, proto3) ^:: basic (7, (enum CoercionForm.from_int), proto3) ^:: basic (8, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ConvertRowtypeExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; arg: Node.t option; resulttype: int; convertformat: CoercionForm.t; location: int } 
    val make : ?xpr:Node.t -> ?arg:Node.t -> ?resulttype:int -> ?convertformat:CoercionForm.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ConvertRowtypeExpr"
    type t = { xpr: Node.t option; arg: Node.t option; resulttype: int; convertformat: CoercionForm.t; location: int }
    let make =
      fun ?xpr ?arg ?resulttype ?convertformat ?location () -> 
      let resulttype = match resulttype with Some v -> v | None -> 0 in
      let convertformat = match convertformat with Some v -> v | None -> (CoercionForm.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; arg; resulttype; convertformat; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; arg; resulttype; convertformat; location } -> f' [] xpr arg resulttype convertformat location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic (3, uint32_int, proto3) ^:: basic (4, (enum CoercionForm.to_int), proto3) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr arg resulttype convertformat location -> { xpr; arg; resulttype; convertformat; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic (3, uint32_int, proto3) ^:: basic (4, (enum CoercionForm.from_int), proto3) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CollateExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; arg: Node.t option; coll_oid: int; location: int } 
    val make : ?xpr:Node.t -> ?arg:Node.t -> ?coll_oid:int -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CollateExpr"
    type t = { xpr: Node.t option; arg: Node.t option; coll_oid: int; location: int }
    let make =
      fun ?xpr ?arg ?coll_oid ?location () -> 
      let coll_oid = match coll_oid with Some v -> v | None -> 0 in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; arg; coll_oid; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; arg; coll_oid; location } -> f' [] xpr arg coll_oid location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic (3, uint32_int, proto3) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr arg coll_oid location -> { xpr; arg; coll_oid; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic (3, uint32_int, proto3) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CaseExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; casetype: int; casecollid: int; arg: Node.t option; args: Node.t list; defresult: Node.t option; location: int } 
    val make : ?xpr:Node.t -> ?casetype:int -> ?casecollid:int -> ?arg:Node.t -> ?args:Node.t list -> ?defresult:Node.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CaseExpr"
    type t = { xpr: Node.t option; casetype: int; casecollid: int; arg: Node.t option; args: Node.t list; defresult: Node.t option; location: int }
    let make =
      fun ?xpr ?casetype ?casecollid ?arg ?args ?defresult ?location () -> 
      let casetype = match casetype with Some v -> v | None -> 0 in
      let casecollid = match casecollid with Some v -> v | None -> 0 in
      let args = match args with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; casetype; casecollid; arg; args; defresult; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; casetype; casecollid; arg; args; defresult; location } -> f' [] xpr casetype casecollid arg args defresult location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> Node.to_proto t))) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr casetype casecollid arg args defresult location -> { xpr; casetype; casecollid; arg; args; defresult; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> Node.from_proto t))) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CaseWhen : sig
    val name': unit -> string
    type t = { xpr: Node.t option; expr: Node.t option; result: Node.t option; location: int } 
    val make : ?xpr:Node.t -> ?expr:Node.t -> ?result:Node.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CaseWhen"
    type t = { xpr: Node.t option; expr: Node.t option; result: Node.t option; location: int }
    let make =
      fun ?xpr ?expr ?result ?location () -> 
      let location = match location with Some v -> v | None -> 0 in
      { xpr; expr; result; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; expr; result; location } -> f' [] xpr expr result location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr expr result location -> { xpr; expr; result; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CaseTestExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; type_id: int; type_mod: int; collation: int } 
    val make : ?xpr:Node.t -> ?type_id:int -> ?type_mod:int -> ?collation:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CaseTestExpr"
    type t = { xpr: Node.t option; type_id: int; type_mod: int; collation: int }
    let make =
      fun ?xpr ?type_id ?type_mod ?collation () -> 
      let type_id = match type_id with Some v -> v | None -> 0 in
      let type_mod = match type_mod with Some v -> v | None -> 0 in
      let collation = match collation with Some v -> v | None -> 0 in
      { xpr; type_id; type_mod; collation }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; type_id; type_mod; collation } -> f' [] xpr type_id type_mod collation in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr type_id type_mod collation -> { xpr; type_id; type_mod; collation } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ArrayExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; array_typeid: int; array_collid: int; element_typeid: int; elements: Node.t list; multidims: bool; location: int } 
    val make : ?xpr:Node.t -> ?array_typeid:int -> ?array_collid:int -> ?element_typeid:int -> ?elements:Node.t list -> ?multidims:bool -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ArrayExpr"
    type t = { xpr: Node.t option; array_typeid: int; array_collid: int; element_typeid: int; elements: Node.t list; multidims: bool; location: int }
    let make =
      fun ?xpr ?array_typeid ?array_collid ?element_typeid ?elements ?multidims ?location () -> 
      let array_typeid = match array_typeid with Some v -> v | None -> 0 in
      let array_collid = match array_collid with Some v -> v | None -> 0 in
      let element_typeid = match element_typeid with Some v -> v | None -> 0 in
      let elements = match elements with Some v -> v | None -> [] in
      let multidims = match multidims with Some v -> v | None -> false in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; array_typeid; array_collid; element_typeid; elements; multidims; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; array_typeid; array_collid; element_typeid; elements; multidims; location } -> f' [] xpr array_typeid array_collid element_typeid elements multidims location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (6, bool, proto3) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr array_typeid array_collid element_typeid elements multidims location -> { xpr; array_typeid; array_collid; element_typeid; elements; multidims; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (6, bool, proto3) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RowExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; args: Node.t list; row_typeid: int; row_format: CoercionForm.t; colnames: Node.t list; location: int } 
    val make : ?xpr:Node.t -> ?args:Node.t list -> ?row_typeid:int -> ?row_format:CoercionForm.t -> ?colnames:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RowExpr"
    type t = { xpr: Node.t option; args: Node.t list; row_typeid: int; row_format: CoercionForm.t; colnames: Node.t list; location: int }
    let make =
      fun ?xpr ?args ?row_typeid ?row_format ?colnames ?location () -> 
      let args = match args with Some v -> v | None -> [] in
      let row_typeid = match row_typeid with Some v -> v | None -> 0 in
      let row_format = match row_format with Some v -> v | None -> (CoercionForm.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let colnames = match colnames with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; args; row_typeid; row_format; colnames; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; args; row_typeid; row_format; colnames; location } -> f' [] xpr args row_typeid row_format colnames location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, uint32_int, proto3) ^:: basic (4, (enum CoercionForm.to_int), proto3) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (6, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr args row_typeid row_format colnames location -> { xpr; args; row_typeid; row_format; colnames; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, uint32_int, proto3) ^:: basic (4, (enum CoercionForm.from_int), proto3) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (6, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RowCompareExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; rctype: RowCompareType.t; opnos: Node.t list; opfamilies: Node.t list; inputcollids: Node.t list; largs: Node.t list; rargs: Node.t list } 
    val make : ?xpr:Node.t -> ?rctype:RowCompareType.t -> ?opnos:Node.t list -> ?opfamilies:Node.t list -> ?inputcollids:Node.t list -> ?largs:Node.t list -> ?rargs:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RowCompareExpr"
    type t = { xpr: Node.t option; rctype: RowCompareType.t; opnos: Node.t list; opfamilies: Node.t list; inputcollids: Node.t list; largs: Node.t list; rargs: Node.t list }
    let make =
      fun ?xpr ?rctype ?opnos ?opfamilies ?inputcollids ?largs ?rargs () -> 
      let rctype = match rctype with Some v -> v | None -> (RowCompareType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let opnos = match opnos with Some v -> v | None -> [] in
      let opfamilies = match opfamilies with Some v -> v | None -> [] in
      let inputcollids = match inputcollids with Some v -> v | None -> [] in
      let largs = match largs with Some v -> v | None -> [] in
      let rargs = match rargs with Some v -> v | None -> [] in
      { xpr; rctype; opnos; opfamilies; inputcollids; largs; rargs }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; rctype; opnos; opfamilies; inputcollids; largs; rargs } -> f' [] xpr rctype opnos opfamilies inputcollids largs rargs in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, (enum RowCompareType.to_int), proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (7, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr rctype opnos opfamilies inputcollids largs rargs -> { xpr; rctype; opnos; opfamilies; inputcollids; largs; rargs } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, (enum RowCompareType.from_int), proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (7, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CoalesceExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; coalescetype: int; coalescecollid: int; args: Node.t list; location: int } 
    val make : ?xpr:Node.t -> ?coalescetype:int -> ?coalescecollid:int -> ?args:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CoalesceExpr"
    type t = { xpr: Node.t option; coalescetype: int; coalescecollid: int; args: Node.t list; location: int }
    let make =
      fun ?xpr ?coalescetype ?coalescecollid ?args ?location () -> 
      let coalescetype = match coalescetype with Some v -> v | None -> 0 in
      let coalescecollid = match coalescecollid with Some v -> v | None -> 0 in
      let args = match args with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; coalescetype; coalescecollid; args; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; coalescetype; coalescecollid; args; location } -> f' [] xpr coalescetype coalescecollid args location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr coalescetype coalescecollid args location -> { xpr; coalescetype; coalescecollid; args; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and MinMaxExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; minmaxtype: int; minmaxcollid: int; inputcollid: int; op: MinMaxOp.t; args: Node.t list; location: int } 
    val make : ?xpr:Node.t -> ?minmaxtype:int -> ?minmaxcollid:int -> ?inputcollid:int -> ?op:MinMaxOp.t -> ?args:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.MinMaxExpr"
    type t = { xpr: Node.t option; minmaxtype: int; minmaxcollid: int; inputcollid: int; op: MinMaxOp.t; args: Node.t list; location: int }
    let make =
      fun ?xpr ?minmaxtype ?minmaxcollid ?inputcollid ?op ?args ?location () -> 
      let minmaxtype = match minmaxtype with Some v -> v | None -> 0 in
      let minmaxcollid = match minmaxcollid with Some v -> v | None -> 0 in
      let inputcollid = match inputcollid with Some v -> v | None -> 0 in
      let op = match op with Some v -> v | None -> (MinMaxOp.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let args = match args with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; minmaxtype; minmaxcollid; inputcollid; op; args; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; minmaxtype; minmaxcollid; inputcollid; op; args; location } -> f' [] xpr minmaxtype minmaxcollid inputcollid op args location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, (enum MinMaxOp.to_int), proto3) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr minmaxtype minmaxcollid inputcollid op args location -> { xpr; minmaxtype; minmaxcollid; inputcollid; op; args; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, (enum MinMaxOp.from_int), proto3) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SQLValueFunction : sig
    val name': unit -> string
    type t = { xpr: Node.t option; op: SQLValueFunctionOp.t; type': int; typmod: int; location: int } 
    val make : ?xpr:Node.t -> ?op:SQLValueFunctionOp.t -> ?type':int -> ?typmod:int -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.SQLValueFunction"
    type t = { xpr: Node.t option; op: SQLValueFunctionOp.t; type': int; typmod: int; location: int }
    let make =
      fun ?xpr ?op ?type' ?typmod ?location () -> 
      let op = match op with Some v -> v | None -> (SQLValueFunctionOp.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let type' = match type' with Some v -> v | None -> 0 in
      let typmod = match typmod with Some v -> v | None -> 0 in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; op; type'; typmod; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; op; type'; typmod; location } -> f' [] xpr op type' typmod location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, (enum SQLValueFunctionOp.to_int), proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, int32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr op type' typmod location -> { xpr; op; type'; typmod; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, (enum SQLValueFunctionOp.from_int), proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, int32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and XmlExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; op: XmlExprOp.t; name: string; named_args: Node.t list; arg_names: Node.t list; args: Node.t list; xmloption: XmlOptionType.t; type': int; typmod: int; location: int } 
    val make : ?xpr:Node.t -> ?op:XmlExprOp.t -> ?name:string -> ?named_args:Node.t list -> ?arg_names:Node.t list -> ?args:Node.t list -> ?xmloption:XmlOptionType.t -> ?type':int -> ?typmod:int -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.XmlExpr"
    type t = { xpr: Node.t option; op: XmlExprOp.t; name: string; named_args: Node.t list; arg_names: Node.t list; args: Node.t list; xmloption: XmlOptionType.t; type': int; typmod: int; location: int }
    let make =
      fun ?xpr ?op ?name ?named_args ?arg_names ?args ?xmloption ?type' ?typmod ?location () -> 
      let op = match op with Some v -> v | None -> (XmlExprOp.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let name = match name with Some v -> v | None -> {||} in
      let named_args = match named_args with Some v -> v | None -> [] in
      let arg_names = match arg_names with Some v -> v | None -> [] in
      let args = match args with Some v -> v | None -> [] in
      let xmloption = match xmloption with Some v -> v | None -> (XmlOptionType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let type' = match type' with Some v -> v | None -> 0 in
      let typmod = match typmod with Some v -> v | None -> 0 in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; op; name; named_args; arg_names; args; xmloption; type'; typmod; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; op; name; named_args; arg_names; args; xmloption; type'; typmod; location } -> f' [] xpr op name named_args arg_names args xmloption type' typmod location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, (enum XmlExprOp.to_int), proto3) ^:: basic (3, string, proto3) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (7, (enum XmlOptionType.to_int), proto3) ^:: basic (8, uint32_int, proto3) ^:: basic (9, int32_int, proto3) ^:: basic (10, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr op name named_args arg_names args xmloption type' typmod location -> { xpr; op; name; named_args; arg_names; args; xmloption; type'; typmod; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, (enum XmlExprOp.from_int), proto3) ^:: basic (3, string, proto3) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (7, (enum XmlOptionType.from_int), proto3) ^:: basic (8, uint32_int, proto3) ^:: basic (9, int32_int, proto3) ^:: basic (10, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and NullTest : sig
    val name': unit -> string
    type t = { xpr: Node.t option; arg: Node.t option; nulltesttype: NullTestType.t; argisrow: bool; location: int } 
    val make : ?xpr:Node.t -> ?arg:Node.t -> ?nulltesttype:NullTestType.t -> ?argisrow:bool -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.NullTest"
    type t = { xpr: Node.t option; arg: Node.t option; nulltesttype: NullTestType.t; argisrow: bool; location: int }
    let make =
      fun ?xpr ?arg ?nulltesttype ?argisrow ?location () -> 
      let nulltesttype = match nulltesttype with Some v -> v | None -> (NullTestType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let argisrow = match argisrow with Some v -> v | None -> false in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; arg; nulltesttype; argisrow; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; arg; nulltesttype; argisrow; location } -> f' [] xpr arg nulltesttype argisrow location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic (3, (enum NullTestType.to_int), proto3) ^:: basic (4, bool, proto3) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr arg nulltesttype argisrow location -> { xpr; arg; nulltesttype; argisrow; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic (3, (enum NullTestType.from_int), proto3) ^:: basic (4, bool, proto3) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and BooleanTest : sig
    val name': unit -> string
    type t = { xpr: Node.t option; arg: Node.t option; booltesttype: BoolTestType.t; location: int } 
    val make : ?xpr:Node.t -> ?arg:Node.t -> ?booltesttype:BoolTestType.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.BooleanTest"
    type t = { xpr: Node.t option; arg: Node.t option; booltesttype: BoolTestType.t; location: int }
    let make =
      fun ?xpr ?arg ?booltesttype ?location () -> 
      let booltesttype = match booltesttype with Some v -> v | None -> (BoolTestType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; arg; booltesttype; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; arg; booltesttype; location } -> f' [] xpr arg booltesttype location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic (3, (enum BoolTestType.to_int), proto3) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr arg booltesttype location -> { xpr; arg; booltesttype; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic (3, (enum BoolTestType.from_int), proto3) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CoerceToDomain : sig
    val name': unit -> string
    type t = { xpr: Node.t option; arg: Node.t option; resulttype: int; resulttypmod: int; resultcollid: int; coercionformat: CoercionForm.t; location: int } 
    val make : ?xpr:Node.t -> ?arg:Node.t -> ?resulttype:int -> ?resulttypmod:int -> ?resultcollid:int -> ?coercionformat:CoercionForm.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CoerceToDomain"
    type t = { xpr: Node.t option; arg: Node.t option; resulttype: int; resulttypmod: int; resultcollid: int; coercionformat: CoercionForm.t; location: int }
    let make =
      fun ?xpr ?arg ?resulttype ?resulttypmod ?resultcollid ?coercionformat ?location () -> 
      let resulttype = match resulttype with Some v -> v | None -> 0 in
      let resulttypmod = match resulttypmod with Some v -> v | None -> 0 in
      let resultcollid = match resultcollid with Some v -> v | None -> 0 in
      let coercionformat = match coercionformat with Some v -> v | None -> (CoercionForm.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; arg; resulttype; resulttypmod; resultcollid; coercionformat; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; arg; resulttype; resulttypmod; resultcollid; coercionformat; location } -> f' [] xpr arg resulttype resulttypmod resultcollid coercionformat location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic (3, uint32_int, proto3) ^:: basic (4, int32_int, proto3) ^:: basic (5, uint32_int, proto3) ^:: basic (6, (enum CoercionForm.to_int), proto3) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr arg resulttype resulttypmod resultcollid coercionformat location -> { xpr; arg; resulttype; resulttypmod; resultcollid; coercionformat; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic (3, uint32_int, proto3) ^:: basic (4, int32_int, proto3) ^:: basic (5, uint32_int, proto3) ^:: basic (6, (enum CoercionForm.from_int), proto3) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CoerceToDomainValue : sig
    val name': unit -> string
    type t = { xpr: Node.t option; type_id: int; type_mod: int; collation: int; location: int } 
    val make : ?xpr:Node.t -> ?type_id:int -> ?type_mod:int -> ?collation:int -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CoerceToDomainValue"
    type t = { xpr: Node.t option; type_id: int; type_mod: int; collation: int; location: int }
    let make =
      fun ?xpr ?type_id ?type_mod ?collation ?location () -> 
      let type_id = match type_id with Some v -> v | None -> 0 in
      let type_mod = match type_mod with Some v -> v | None -> 0 in
      let collation = match collation with Some v -> v | None -> 0 in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; type_id; type_mod; collation; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; type_id; type_mod; collation; location } -> f' [] xpr type_id type_mod collation location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr type_id type_mod collation location -> { xpr; type_id; type_mod; collation; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SetToDefault : sig
    val name': unit -> string
    type t = { xpr: Node.t option; type_id: int; type_mod: int; collation: int; location: int } 
    val make : ?xpr:Node.t -> ?type_id:int -> ?type_mod:int -> ?collation:int -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.SetToDefault"
    type t = { xpr: Node.t option; type_id: int; type_mod: int; collation: int; location: int }
    let make =
      fun ?xpr ?type_id ?type_mod ?collation ?location () -> 
      let type_id = match type_id with Some v -> v | None -> 0 in
      let type_mod = match type_mod with Some v -> v | None -> 0 in
      let collation = match collation with Some v -> v | None -> 0 in
      let location = match location with Some v -> v | None -> 0 in
      { xpr; type_id; type_mod; collation; location }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; type_id; type_mod; collation; location } -> f' [] xpr type_id type_mod collation location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr type_id type_mod collation location -> { xpr; type_id; type_mod; collation; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CurrentOfExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; cvarno: int; cursor_name: string; cursor_param: int } 
    val make : ?xpr:Node.t -> ?cvarno:int -> ?cursor_name:string -> ?cursor_param:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CurrentOfExpr"
    type t = { xpr: Node.t option; cvarno: int; cursor_name: string; cursor_param: int }
    let make =
      fun ?xpr ?cvarno ?cursor_name ?cursor_param () -> 
      let cvarno = match cvarno with Some v -> v | None -> 0 in
      let cursor_name = match cursor_name with Some v -> v | None -> {||} in
      let cursor_param = match cursor_param with Some v -> v | None -> 0 in
      { xpr; cvarno; cursor_name; cursor_param }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; cvarno; cursor_name; cursor_param } -> f' [] xpr cvarno cursor_name cursor_param in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, string, proto3) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr cvarno cursor_name cursor_param -> { xpr; cvarno; cursor_name; cursor_param } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, string, proto3) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and NextValueExpr : sig
    val name': unit -> string
    type t = { xpr: Node.t option; seqid: int; type_id: int } 
    val make : ?xpr:Node.t -> ?seqid:int -> ?type_id:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.NextValueExpr"
    type t = { xpr: Node.t option; seqid: int; type_id: int }
    let make =
      fun ?xpr ?seqid ?type_id () -> 
      let seqid = match seqid with Some v -> v | None -> 0 in
      let type_id = match type_id with Some v -> v | None -> 0 in
      { xpr; seqid; type_id }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; seqid; type_id } -> f' [] xpr seqid type_id in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr seqid type_id -> { xpr; seqid; type_id } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and InferenceElem : sig
    val name': unit -> string
    type t = { xpr: Node.t option; expr: Node.t option; infercollid: int; inferopclass: int } 
    val make : ?xpr:Node.t -> ?expr:Node.t -> ?infercollid:int -> ?inferopclass:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.InferenceElem"
    type t = { xpr: Node.t option; expr: Node.t option; infercollid: int; inferopclass: int }
    let make =
      fun ?xpr ?expr ?infercollid ?inferopclass () -> 
      let infercollid = match infercollid with Some v -> v | None -> 0 in
      let inferopclass = match inferopclass with Some v -> v | None -> 0 in
      { xpr; expr; infercollid; inferopclass }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; expr; infercollid; inferopclass } -> f' [] xpr expr infercollid inferopclass in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr expr infercollid inferopclass -> { xpr; expr; infercollid; inferopclass } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic (3, uint32_int, proto3) ^:: basic (4, uint32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and TargetEntry : sig
    val name': unit -> string
    type t = { xpr: Node.t option; expr: Node.t option; resno: int; resname: string; ressortgroupref: int; resorigtbl: int; resorigcol: int; resjunk: bool } 
    val make : ?xpr:Node.t -> ?expr:Node.t -> ?resno:int -> ?resname:string -> ?ressortgroupref:int -> ?resorigtbl:int -> ?resorigcol:int -> ?resjunk:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.TargetEntry"
    type t = { xpr: Node.t option; expr: Node.t option; resno: int; resname: string; ressortgroupref: int; resorigtbl: int; resorigcol: int; resjunk: bool }
    let make =
      fun ?xpr ?expr ?resno ?resname ?ressortgroupref ?resorigtbl ?resorigcol ?resjunk () -> 
      let resno = match resno with Some v -> v | None -> 0 in
      let resname = match resname with Some v -> v | None -> {||} in
      let ressortgroupref = match ressortgroupref with Some v -> v | None -> 0 in
      let resorigtbl = match resorigtbl with Some v -> v | None -> 0 in
      let resorigcol = match resorigcol with Some v -> v | None -> 0 in
      let resjunk = match resjunk with Some v -> v | None -> false in
      { xpr; expr; resno; resname; ressortgroupref; resorigtbl; resorigcol; resjunk }
    
    let to_proto =
      let apply = fun ~f:f' { xpr; expr; resno; resname; ressortgroupref; resorigtbl; resorigcol; resjunk } -> f' [] xpr expr resno resname ressortgroupref resorigtbl resorigcol resjunk in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic (3, int32_int, proto3) ^:: basic (4, string, proto3) ^:: basic (5, uint32_int, proto3) ^:: basic (6, uint32_int, proto3) ^:: basic (7, int32_int, proto3) ^:: basic (8, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xpr expr resno resname ressortgroupref resorigtbl resorigcol resjunk -> { xpr; expr; resno; resname; ressortgroupref; resorigtbl; resorigcol; resjunk } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic (3, int32_int, proto3) ^:: basic (4, string, proto3) ^:: basic (5, uint32_int, proto3) ^:: basic (6, uint32_int, proto3) ^:: basic (7, int32_int, proto3) ^:: basic (8, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RangeTblRef : sig
    val name': unit -> string
    type t = int 
    val make : ?rtindex:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RangeTblRef"
    type t = int
    let make =
      fun ?rtindex () -> 
      let rtindex = match rtindex with Some v -> v | None -> 0 in
      rtindex
    
    let to_proto =
      let apply = fun ~f:f' rtindex -> f' [] rtindex in
      let spec = Runtime'.Serialize.C.( basic (1, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions rtindex -> rtindex in
      let spec = Runtime'.Deserialize.C.( basic (1, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and JoinExpr : sig
    val name': unit -> string
    type t = { jointype: JoinType.t; is_natural: bool; larg: Node.t option; rarg: Node.t option; using_clause: Node.t list; join_using_alias: Alias.t option; quals: Node.t option; alias: Alias.t option; rtindex: int } 
    val make : ?jointype:JoinType.t -> ?is_natural:bool -> ?larg:Node.t -> ?rarg:Node.t -> ?using_clause:Node.t list -> ?join_using_alias:Alias.t -> ?quals:Node.t -> ?alias:Alias.t -> ?rtindex:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.JoinExpr"
    type t = { jointype: JoinType.t; is_natural: bool; larg: Node.t option; rarg: Node.t option; using_clause: Node.t list; join_using_alias: Alias.t option; quals: Node.t option; alias: Alias.t option; rtindex: int }
    let make =
      fun ?jointype ?is_natural ?larg ?rarg ?using_clause ?join_using_alias ?quals ?alias ?rtindex () -> 
      let jointype = match jointype with Some v -> v | None -> (JoinType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let is_natural = match is_natural with Some v -> v | None -> false in
      let using_clause = match using_clause with Some v -> v | None -> [] in
      let rtindex = match rtindex with Some v -> v | None -> 0 in
      { jointype; is_natural; larg; rarg; using_clause; join_using_alias; quals; alias; rtindex }
    
    let to_proto =
      let apply = fun ~f:f' { jointype; is_natural; larg; rarg; using_clause; join_using_alias; quals; alias; rtindex } -> f' [] jointype is_natural larg rarg using_clause join_using_alias quals alias rtindex in
      let spec = Runtime'.Serialize.C.( basic (1, (enum JoinType.to_int), proto3) ^:: basic (2, bool, proto3) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> Alias.to_proto t))) ^:: basic_opt (7, (message (fun t -> Node.to_proto t))) ^:: basic_opt (8, (message (fun t -> Alias.to_proto t))) ^:: basic (9, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions jointype is_natural larg rarg using_clause join_using_alias quals alias rtindex -> { jointype; is_natural; larg; rarg; using_clause; join_using_alias; quals; alias; rtindex } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum JoinType.from_int), proto3) ^:: basic (2, bool, proto3) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> Alias.from_proto t))) ^:: basic_opt (7, (message (fun t -> Node.from_proto t))) ^:: basic_opt (8, (message (fun t -> Alias.from_proto t))) ^:: basic (9, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and FromExpr : sig
    val name': unit -> string
    type t = { fromlist: Node.t list; quals: Node.t option } 
    val make : ?fromlist:Node.t list -> ?quals:Node.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.FromExpr"
    type t = { fromlist: Node.t list; quals: Node.t option }
    let make =
      fun ?fromlist ?quals () -> 
      let fromlist = match fromlist with Some v -> v | None -> [] in
      { fromlist; quals }
    
    let to_proto =
      let apply = fun ~f:f' { fromlist; quals } -> f' [] fromlist quals in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions fromlist quals -> { fromlist; quals } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and OnConflictExpr : sig
    val name': unit -> string
    type t = { action: OnConflictAction.t; arbiter_elems: Node.t list; arbiter_where: Node.t option; constraint': int; on_conflict_set: Node.t list; on_conflict_where: Node.t option; excl_rel_index: int; excl_rel_tlist: Node.t list } 
    val make : ?action:OnConflictAction.t -> ?arbiter_elems:Node.t list -> ?arbiter_where:Node.t -> ?constraint':int -> ?on_conflict_set:Node.t list -> ?on_conflict_where:Node.t -> ?excl_rel_index:int -> ?excl_rel_tlist:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.OnConflictExpr"
    type t = { action: OnConflictAction.t; arbiter_elems: Node.t list; arbiter_where: Node.t option; constraint': int; on_conflict_set: Node.t list; on_conflict_where: Node.t option; excl_rel_index: int; excl_rel_tlist: Node.t list }
    let make =
      fun ?action ?arbiter_elems ?arbiter_where ?constraint' ?on_conflict_set ?on_conflict_where ?excl_rel_index ?excl_rel_tlist () -> 
      let action = match action with Some v -> v | None -> (OnConflictAction.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let arbiter_elems = match arbiter_elems with Some v -> v | None -> [] in
      let constraint' = match constraint' with Some v -> v | None -> 0 in
      let on_conflict_set = match on_conflict_set with Some v -> v | None -> [] in
      let excl_rel_index = match excl_rel_index with Some v -> v | None -> 0 in
      let excl_rel_tlist = match excl_rel_tlist with Some v -> v | None -> [] in
      { action; arbiter_elems; arbiter_where; constraint'; on_conflict_set; on_conflict_where; excl_rel_index; excl_rel_tlist }
    
    let to_proto =
      let apply = fun ~f:f' { action; arbiter_elems; arbiter_where; constraint'; on_conflict_set; on_conflict_where; excl_rel_index; excl_rel_tlist } -> f' [] action arbiter_elems arbiter_where constraint' on_conflict_set on_conflict_where excl_rel_index excl_rel_tlist in
      let spec = Runtime'.Serialize.C.( basic (1, (enum OnConflictAction.to_int), proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: basic (4, uint32_int, proto3) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> Node.to_proto t))) ^:: basic (7, int32_int, proto3) ^:: repeated (8, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions action arbiter_elems arbiter_where constraint' on_conflict_set on_conflict_where excl_rel_index excl_rel_tlist -> { action; arbiter_elems; arbiter_where; constraint'; on_conflict_set; on_conflict_where; excl_rel_index; excl_rel_tlist } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum OnConflictAction.from_int), proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: basic (4, uint32_int, proto3) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> Node.from_proto t))) ^:: basic (7, int32_int, proto3) ^:: repeated (8, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and IntoClause : sig
    val name': unit -> string
    type t = { rel: RangeVar.t option; col_names: Node.t list; access_method: string; options: Node.t list; on_commit: OnCommitAction.t; table_space_name: string; view_query: Node.t option; skip_data: bool } 
    val make : ?rel:RangeVar.t -> ?col_names:Node.t list -> ?access_method:string -> ?options:Node.t list -> ?on_commit:OnCommitAction.t -> ?table_space_name:string -> ?view_query:Node.t -> ?skip_data:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.IntoClause"
    type t = { rel: RangeVar.t option; col_names: Node.t list; access_method: string; options: Node.t list; on_commit: OnCommitAction.t; table_space_name: string; view_query: Node.t option; skip_data: bool }
    let make =
      fun ?rel ?col_names ?access_method ?options ?on_commit ?table_space_name ?view_query ?skip_data () -> 
      let col_names = match col_names with Some v -> v | None -> [] in
      let access_method = match access_method with Some v -> v | None -> {||} in
      let options = match options with Some v -> v | None -> [] in
      let on_commit = match on_commit with Some v -> v | None -> (OnCommitAction.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let table_space_name = match table_space_name with Some v -> v | None -> {||} in
      let skip_data = match skip_data with Some v -> v | None -> false in
      { rel; col_names; access_method; options; on_commit; table_space_name; view_query; skip_data }
    
    let to_proto =
      let apply = fun ~f:f' { rel; col_names; access_method; options; on_commit; table_space_name; view_query; skip_data } -> f' [] rel col_names access_method options on_commit table_space_name view_query skip_data in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, string, proto3) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (5, (enum OnCommitAction.to_int), proto3) ^:: basic (6, string, proto3) ^:: basic_opt (7, (message (fun t -> Node.to_proto t))) ^:: basic (8, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions rel col_names access_method options on_commit table_space_name view_query skip_data -> { rel; col_names; access_method; options; on_commit; table_space_name; view_query; skip_data } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, string, proto3) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (5, (enum OnCommitAction.from_int), proto3) ^:: basic (6, string, proto3) ^:: basic_opt (7, (message (fun t -> Node.from_proto t))) ^:: basic (8, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and MergeAction : sig
    val name': unit -> string
    type t = { matched: bool; command_type: CmdType.t; override: OverridingKind.t; qual: Node.t option; target_list: Node.t list; update_colnos: Node.t list } 
    val make : ?matched:bool -> ?command_type:CmdType.t -> ?override:OverridingKind.t -> ?qual:Node.t -> ?target_list:Node.t list -> ?update_colnos:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.MergeAction"
    type t = { matched: bool; command_type: CmdType.t; override: OverridingKind.t; qual: Node.t option; target_list: Node.t list; update_colnos: Node.t list }
    let make =
      fun ?matched ?command_type ?override ?qual ?target_list ?update_colnos () -> 
      let matched = match matched with Some v -> v | None -> false in
      let command_type = match command_type with Some v -> v | None -> (CmdType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let override = match override with Some v -> v | None -> (OverridingKind.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let target_list = match target_list with Some v -> v | None -> [] in
      let update_colnos = match update_colnos with Some v -> v | None -> [] in
      { matched; command_type; override; qual; target_list; update_colnos }
    
    let to_proto =
      let apply = fun ~f:f' { matched; command_type; override; qual; target_list; update_colnos } -> f' [] matched command_type override qual target_list update_colnos in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic (2, (enum CmdType.to_int), proto3) ^:: basic (3, (enum OverridingKind.to_int), proto3) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions matched command_type override qual target_list update_colnos -> { matched; command_type; override; qual; target_list; update_colnos } in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic (2, (enum CmdType.from_int), proto3) ^:: basic (3, (enum OverridingKind.from_int), proto3) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RawStmt : sig
    val name': unit -> string
    type t = { stmt: Node.t option; stmt_location: int; stmt_len: int } 
    val make : ?stmt:Node.t -> ?stmt_location:int -> ?stmt_len:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RawStmt"
    type t = { stmt: Node.t option; stmt_location: int; stmt_len: int }
    let make =
      fun ?stmt ?stmt_location ?stmt_len () -> 
      let stmt_location = match stmt_location with Some v -> v | None -> 0 in
      let stmt_len = match stmt_len with Some v -> v | None -> 0 in
      { stmt; stmt_location; stmt_len }
    
    let to_proto =
      let apply = fun ~f:f' { stmt; stmt_location; stmt_len } -> f' [] stmt stmt_location stmt_len in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, int32_int, proto3) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions stmt stmt_location stmt_len -> { stmt; stmt_location; stmt_len } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, int32_int, proto3) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Query : sig
    val name': unit -> string
    type t = { command_type: CmdType.t; query_source: QuerySource.t; can_set_tag: bool; utility_stmt: Node.t option; result_relation: int; has_aggs: bool; has_window_funcs: bool; has_target_srfs: bool; has_sub_links: bool; has_distinct_on: bool; has_recursive: bool; has_modifying_cte: bool; has_for_update: bool; has_row_security: bool; is_return: bool; cte_list: Node.t list; rtable: Node.t list; jointree: FromExpr.t option; merge_action_list: Node.t list; merge_use_outer_join: bool; target_list: Node.t list; override: OverridingKind.t; on_conflict: OnConflictExpr.t option; returning_list: Node.t list; group_clause: Node.t list; group_distinct: bool; grouping_sets: Node.t list; having_qual: Node.t option; window_clause: Node.t list; distinct_clause: Node.t list; sort_clause: Node.t list; limit_offset: Node.t option; limit_count: Node.t option; limit_option: LimitOption.t; row_marks: Node.t list; set_operations: Node.t option; constraint_deps: Node.t list; with_check_options: Node.t list; stmt_location: int; stmt_len: int } 
    val make : ?command_type:CmdType.t -> ?query_source:QuerySource.t -> ?can_set_tag:bool -> ?utility_stmt:Node.t -> ?result_relation:int -> ?has_aggs:bool -> ?has_window_funcs:bool -> ?has_target_srfs:bool -> ?has_sub_links:bool -> ?has_distinct_on:bool -> ?has_recursive:bool -> ?has_modifying_cte:bool -> ?has_for_update:bool -> ?has_row_security:bool -> ?is_return:bool -> ?cte_list:Node.t list -> ?rtable:Node.t list -> ?jointree:FromExpr.t -> ?merge_action_list:Node.t list -> ?merge_use_outer_join:bool -> ?target_list:Node.t list -> ?override:OverridingKind.t -> ?on_conflict:OnConflictExpr.t -> ?returning_list:Node.t list -> ?group_clause:Node.t list -> ?group_distinct:bool -> ?grouping_sets:Node.t list -> ?having_qual:Node.t -> ?window_clause:Node.t list -> ?distinct_clause:Node.t list -> ?sort_clause:Node.t list -> ?limit_offset:Node.t -> ?limit_count:Node.t -> ?limit_option:LimitOption.t -> ?row_marks:Node.t list -> ?set_operations:Node.t -> ?constraint_deps:Node.t list -> ?with_check_options:Node.t list -> ?stmt_location:int -> ?stmt_len:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.Query"
    type t = { command_type: CmdType.t; query_source: QuerySource.t; can_set_tag: bool; utility_stmt: Node.t option; result_relation: int; has_aggs: bool; has_window_funcs: bool; has_target_srfs: bool; has_sub_links: bool; has_distinct_on: bool; has_recursive: bool; has_modifying_cte: bool; has_for_update: bool; has_row_security: bool; is_return: bool; cte_list: Node.t list; rtable: Node.t list; jointree: FromExpr.t option; merge_action_list: Node.t list; merge_use_outer_join: bool; target_list: Node.t list; override: OverridingKind.t; on_conflict: OnConflictExpr.t option; returning_list: Node.t list; group_clause: Node.t list; group_distinct: bool; grouping_sets: Node.t list; having_qual: Node.t option; window_clause: Node.t list; distinct_clause: Node.t list; sort_clause: Node.t list; limit_offset: Node.t option; limit_count: Node.t option; limit_option: LimitOption.t; row_marks: Node.t list; set_operations: Node.t option; constraint_deps: Node.t list; with_check_options: Node.t list; stmt_location: int; stmt_len: int }
    let make =
      fun ?command_type ?query_source ?can_set_tag ?utility_stmt ?result_relation ?has_aggs ?has_window_funcs ?has_target_srfs ?has_sub_links ?has_distinct_on ?has_recursive ?has_modifying_cte ?has_for_update ?has_row_security ?is_return ?cte_list ?rtable ?jointree ?merge_action_list ?merge_use_outer_join ?target_list ?override ?on_conflict ?returning_list ?group_clause ?group_distinct ?grouping_sets ?having_qual ?window_clause ?distinct_clause ?sort_clause ?limit_offset ?limit_count ?limit_option ?row_marks ?set_operations ?constraint_deps ?with_check_options ?stmt_location ?stmt_len () -> 
      let command_type = match command_type with Some v -> v | None -> (CmdType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let query_source = match query_source with Some v -> v | None -> (QuerySource.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let can_set_tag = match can_set_tag with Some v -> v | None -> false in
      let result_relation = match result_relation with Some v -> v | None -> 0 in
      let has_aggs = match has_aggs with Some v -> v | None -> false in
      let has_window_funcs = match has_window_funcs with Some v -> v | None -> false in
      let has_target_srfs = match has_target_srfs with Some v -> v | None -> false in
      let has_sub_links = match has_sub_links with Some v -> v | None -> false in
      let has_distinct_on = match has_distinct_on with Some v -> v | None -> false in
      let has_recursive = match has_recursive with Some v -> v | None -> false in
      let has_modifying_cte = match has_modifying_cte with Some v -> v | None -> false in
      let has_for_update = match has_for_update with Some v -> v | None -> false in
      let has_row_security = match has_row_security with Some v -> v | None -> false in
      let is_return = match is_return with Some v -> v | None -> false in
      let cte_list = match cte_list with Some v -> v | None -> [] in
      let rtable = match rtable with Some v -> v | None -> [] in
      let merge_action_list = match merge_action_list with Some v -> v | None -> [] in
      let merge_use_outer_join = match merge_use_outer_join with Some v -> v | None -> false in
      let target_list = match target_list with Some v -> v | None -> [] in
      let override = match override with Some v -> v | None -> (OverridingKind.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let returning_list = match returning_list with Some v -> v | None -> [] in
      let group_clause = match group_clause with Some v -> v | None -> [] in
      let group_distinct = match group_distinct with Some v -> v | None -> false in
      let grouping_sets = match grouping_sets with Some v -> v | None -> [] in
      let window_clause = match window_clause with Some v -> v | None -> [] in
      let distinct_clause = match distinct_clause with Some v -> v | None -> [] in
      let sort_clause = match sort_clause with Some v -> v | None -> [] in
      let limit_option = match limit_option with Some v -> v | None -> (LimitOption.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let row_marks = match row_marks with Some v -> v | None -> [] in
      let constraint_deps = match constraint_deps with Some v -> v | None -> [] in
      let with_check_options = match with_check_options with Some v -> v | None -> [] in
      let stmt_location = match stmt_location with Some v -> v | None -> 0 in
      let stmt_len = match stmt_len with Some v -> v | None -> 0 in
      { command_type; query_source; can_set_tag; utility_stmt; result_relation; has_aggs; has_window_funcs; has_target_srfs; has_sub_links; has_distinct_on; has_recursive; has_modifying_cte; has_for_update; has_row_security; is_return; cte_list; rtable; jointree; merge_action_list; merge_use_outer_join; target_list; override; on_conflict; returning_list; group_clause; group_distinct; grouping_sets; having_qual; window_clause; distinct_clause; sort_clause; limit_offset; limit_count; limit_option; row_marks; set_operations; constraint_deps; with_check_options; stmt_location; stmt_len }
    
    let to_proto =
      let apply = fun ~f:f' { command_type; query_source; can_set_tag; utility_stmt; result_relation; has_aggs; has_window_funcs; has_target_srfs; has_sub_links; has_distinct_on; has_recursive; has_modifying_cte; has_for_update; has_row_security; is_return; cte_list; rtable; jointree; merge_action_list; merge_use_outer_join; target_list; override; on_conflict; returning_list; group_clause; group_distinct; grouping_sets; having_qual; window_clause; distinct_clause; sort_clause; limit_offset; limit_count; limit_option; row_marks; set_operations; constraint_deps; with_check_options; stmt_location; stmt_len } -> f' [] command_type query_source can_set_tag utility_stmt result_relation has_aggs has_window_funcs has_target_srfs has_sub_links has_distinct_on has_recursive has_modifying_cte has_for_update has_row_security is_return cte_list rtable jointree merge_action_list merge_use_outer_join target_list override on_conflict returning_list group_clause group_distinct grouping_sets having_qual window_clause distinct_clause sort_clause limit_offset limit_count limit_option row_marks set_operations constraint_deps with_check_options stmt_location stmt_len in
      let spec = Runtime'.Serialize.C.( basic (1, (enum CmdType.to_int), proto3) ^:: basic (2, (enum QuerySource.to_int), proto3) ^:: basic (3, bool, proto3) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: basic (5, int32_int, proto3) ^:: basic (6, bool, proto3) ^:: basic (7, bool, proto3) ^:: basic (8, bool, proto3) ^:: basic (9, bool, proto3) ^:: basic (10, bool, proto3) ^:: basic (11, bool, proto3) ^:: basic (12, bool, proto3) ^:: basic (13, bool, proto3) ^:: basic (14, bool, proto3) ^:: basic (15, bool, proto3) ^:: repeated (16, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (17, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (18, (message (fun t -> FromExpr.to_proto t))) ^:: repeated (19, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (20, bool, proto3) ^:: repeated (21, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (22, (enum OverridingKind.to_int), proto3) ^:: basic_opt (23, (message (fun t -> OnConflictExpr.to_proto t))) ^:: repeated (24, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (25, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (26, bool, proto3) ^:: repeated (27, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (28, (message (fun t -> Node.to_proto t))) ^:: repeated (29, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (30, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (31, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (32, (message (fun t -> Node.to_proto t))) ^:: basic_opt (33, (message (fun t -> Node.to_proto t))) ^:: basic (34, (enum LimitOption.to_int), proto3) ^:: repeated (35, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (36, (message (fun t -> Node.to_proto t))) ^:: repeated (37, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (38, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (39, int32_int, proto3) ^:: basic (40, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions command_type query_source can_set_tag utility_stmt result_relation has_aggs has_window_funcs has_target_srfs has_sub_links has_distinct_on has_recursive has_modifying_cte has_for_update has_row_security is_return cte_list rtable jointree merge_action_list merge_use_outer_join target_list override on_conflict returning_list group_clause group_distinct grouping_sets having_qual window_clause distinct_clause sort_clause limit_offset limit_count limit_option row_marks set_operations constraint_deps with_check_options stmt_location stmt_len -> { command_type; query_source; can_set_tag; utility_stmt; result_relation; has_aggs; has_window_funcs; has_target_srfs; has_sub_links; has_distinct_on; has_recursive; has_modifying_cte; has_for_update; has_row_security; is_return; cte_list; rtable; jointree; merge_action_list; merge_use_outer_join; target_list; override; on_conflict; returning_list; group_clause; group_distinct; grouping_sets; having_qual; window_clause; distinct_clause; sort_clause; limit_offset; limit_count; limit_option; row_marks; set_operations; constraint_deps; with_check_options; stmt_location; stmt_len } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum CmdType.from_int), proto3) ^:: basic (2, (enum QuerySource.from_int), proto3) ^:: basic (3, bool, proto3) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: basic (5, int32_int, proto3) ^:: basic (6, bool, proto3) ^:: basic (7, bool, proto3) ^:: basic (8, bool, proto3) ^:: basic (9, bool, proto3) ^:: basic (10, bool, proto3) ^:: basic (11, bool, proto3) ^:: basic (12, bool, proto3) ^:: basic (13, bool, proto3) ^:: basic (14, bool, proto3) ^:: basic (15, bool, proto3) ^:: repeated (16, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (17, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (18, (message (fun t -> FromExpr.from_proto t))) ^:: repeated (19, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (20, bool, proto3) ^:: repeated (21, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (22, (enum OverridingKind.from_int), proto3) ^:: basic_opt (23, (message (fun t -> OnConflictExpr.from_proto t))) ^:: repeated (24, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (25, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (26, bool, proto3) ^:: repeated (27, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (28, (message (fun t -> Node.from_proto t))) ^:: repeated (29, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (30, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (31, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (32, (message (fun t -> Node.from_proto t))) ^:: basic_opt (33, (message (fun t -> Node.from_proto t))) ^:: basic (34, (enum LimitOption.from_int), proto3) ^:: repeated (35, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (36, (message (fun t -> Node.from_proto t))) ^:: repeated (37, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (38, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (39, int32_int, proto3) ^:: basic (40, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and InsertStmt : sig
    val name': unit -> string
    type t = { relation: RangeVar.t option; cols: Node.t list; select_stmt: Node.t option; on_conflict_clause: OnConflictClause.t option; returning_list: Node.t list; with_clause: WithClause.t option; override: OverridingKind.t } 
    val make : ?relation:RangeVar.t -> ?cols:Node.t list -> ?select_stmt:Node.t -> ?on_conflict_clause:OnConflictClause.t -> ?returning_list:Node.t list -> ?with_clause:WithClause.t -> ?override:OverridingKind.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.InsertStmt"
    type t = { relation: RangeVar.t option; cols: Node.t list; select_stmt: Node.t option; on_conflict_clause: OnConflictClause.t option; returning_list: Node.t list; with_clause: WithClause.t option; override: OverridingKind.t }
    let make =
      fun ?relation ?cols ?select_stmt ?on_conflict_clause ?returning_list ?with_clause ?override () -> 
      let cols = match cols with Some v -> v | None -> [] in
      let returning_list = match returning_list with Some v -> v | None -> [] in
      let override = match override with Some v -> v | None -> (OverridingKind.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { relation; cols; select_stmt; on_conflict_clause; returning_list; with_clause; override }
    
    let to_proto =
      let apply = fun ~f:f' { relation; cols; select_stmt; on_conflict_clause; returning_list; with_clause; override } -> f' [] relation cols select_stmt on_conflict_clause returning_list with_clause override in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: basic_opt (4, (message (fun t -> OnConflictClause.to_proto t))) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> WithClause.to_proto t))) ^:: basic (7, (enum OverridingKind.to_int), proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions relation cols select_stmt on_conflict_clause returning_list with_clause override -> { relation; cols; select_stmt; on_conflict_clause; returning_list; with_clause; override } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: basic_opt (4, (message (fun t -> OnConflictClause.from_proto t))) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> WithClause.from_proto t))) ^:: basic (7, (enum OverridingKind.from_int), proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DeleteStmt : sig
    val name': unit -> string
    type t = { relation: RangeVar.t option; using_clause: Node.t list; where_clause: Node.t option; returning_list: Node.t list; with_clause: WithClause.t option } 
    val make : ?relation:RangeVar.t -> ?using_clause:Node.t list -> ?where_clause:Node.t -> ?returning_list:Node.t list -> ?with_clause:WithClause.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.DeleteStmt"
    type t = { relation: RangeVar.t option; using_clause: Node.t list; where_clause: Node.t option; returning_list: Node.t list; with_clause: WithClause.t option }
    let make =
      fun ?relation ?using_clause ?where_clause ?returning_list ?with_clause () -> 
      let using_clause = match using_clause with Some v -> v | None -> [] in
      let returning_list = match returning_list with Some v -> v | None -> [] in
      { relation; using_clause; where_clause; returning_list; with_clause }
    
    let to_proto =
      let apply = fun ~f:f' { relation; using_clause; where_clause; returning_list; with_clause } -> f' [] relation using_clause where_clause returning_list with_clause in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (5, (message (fun t -> WithClause.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions relation using_clause where_clause returning_list with_clause -> { relation; using_clause; where_clause; returning_list; with_clause } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (5, (message (fun t -> WithClause.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and UpdateStmt : sig
    val name': unit -> string
    type t = { relation: RangeVar.t option; target_list: Node.t list; where_clause: Node.t option; from_clause: Node.t list; returning_list: Node.t list; with_clause: WithClause.t option } 
    val make : ?relation:RangeVar.t -> ?target_list:Node.t list -> ?where_clause:Node.t -> ?from_clause:Node.t list -> ?returning_list:Node.t list -> ?with_clause:WithClause.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.UpdateStmt"
    type t = { relation: RangeVar.t option; target_list: Node.t list; where_clause: Node.t option; from_clause: Node.t list; returning_list: Node.t list; with_clause: WithClause.t option }
    let make =
      fun ?relation ?target_list ?where_clause ?from_clause ?returning_list ?with_clause () -> 
      let target_list = match target_list with Some v -> v | None -> [] in
      let from_clause = match from_clause with Some v -> v | None -> [] in
      let returning_list = match returning_list with Some v -> v | None -> [] in
      { relation; target_list; where_clause; from_clause; returning_list; with_clause }
    
    let to_proto =
      let apply = fun ~f:f' { relation; target_list; where_clause; from_clause; returning_list; with_clause } -> f' [] relation target_list where_clause from_clause returning_list with_clause in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> WithClause.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions relation target_list where_clause from_clause returning_list with_clause -> { relation; target_list; where_clause; from_clause; returning_list; with_clause } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> WithClause.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and MergeStmt : sig
    val name': unit -> string
    type t = { relation: RangeVar.t option; source_relation: Node.t option; join_condition: Node.t option; merge_when_clauses: Node.t list; with_clause: WithClause.t option } 
    val make : ?relation:RangeVar.t -> ?source_relation:Node.t -> ?join_condition:Node.t -> ?merge_when_clauses:Node.t list -> ?with_clause:WithClause.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.MergeStmt"
    type t = { relation: RangeVar.t option; source_relation: Node.t option; join_condition: Node.t option; merge_when_clauses: Node.t list; with_clause: WithClause.t option }
    let make =
      fun ?relation ?source_relation ?join_condition ?merge_when_clauses ?with_clause () -> 
      let merge_when_clauses = match merge_when_clauses with Some v -> v | None -> [] in
      { relation; source_relation; join_condition; merge_when_clauses; with_clause }
    
    let to_proto =
      let apply = fun ~f:f' { relation; source_relation; join_condition; merge_when_clauses; with_clause } -> f' [] relation source_relation join_condition merge_when_clauses with_clause in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (5, (message (fun t -> WithClause.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions relation source_relation join_condition merge_when_clauses with_clause -> { relation; source_relation; join_condition; merge_when_clauses; with_clause } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (5, (message (fun t -> WithClause.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SelectStmt : sig
    val name': unit -> string
    type t = { distinct_clause: Node.t list; into_clause: IntoClause.t option; target_list: Node.t list; from_clause: Node.t list; where_clause: Node.t option; group_clause: Node.t list; group_distinct: bool; having_clause: Node.t option; window_clause: Node.t list; values_lists: Node.t list; sort_clause: Node.t list; limit_offset: Node.t option; limit_count: Node.t option; limit_option: LimitOption.t; locking_clause: Node.t list; with_clause: WithClause.t option; op: SetOperation.t; all: bool; larg: SelectStmt.t option; rarg: SelectStmt.t option } 
    val make : ?distinct_clause:Node.t list -> ?into_clause:IntoClause.t -> ?target_list:Node.t list -> ?from_clause:Node.t list -> ?where_clause:Node.t -> ?group_clause:Node.t list -> ?group_distinct:bool -> ?having_clause:Node.t -> ?window_clause:Node.t list -> ?values_lists:Node.t list -> ?sort_clause:Node.t list -> ?limit_offset:Node.t -> ?limit_count:Node.t -> ?limit_option:LimitOption.t -> ?locking_clause:Node.t list -> ?with_clause:WithClause.t -> ?op:SetOperation.t -> ?all:bool -> ?larg:SelectStmt.t -> ?rarg:SelectStmt.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.SelectStmt"
    type t = { distinct_clause: Node.t list; into_clause: IntoClause.t option; target_list: Node.t list; from_clause: Node.t list; where_clause: Node.t option; group_clause: Node.t list; group_distinct: bool; having_clause: Node.t option; window_clause: Node.t list; values_lists: Node.t list; sort_clause: Node.t list; limit_offset: Node.t option; limit_count: Node.t option; limit_option: LimitOption.t; locking_clause: Node.t list; with_clause: WithClause.t option; op: SetOperation.t; all: bool; larg: SelectStmt.t option; rarg: SelectStmt.t option }
    let make =
      fun ?distinct_clause ?into_clause ?target_list ?from_clause ?where_clause ?group_clause ?group_distinct ?having_clause ?window_clause ?values_lists ?sort_clause ?limit_offset ?limit_count ?limit_option ?locking_clause ?with_clause ?op ?all ?larg ?rarg () -> 
      let distinct_clause = match distinct_clause with Some v -> v | None -> [] in
      let target_list = match target_list with Some v -> v | None -> [] in
      let from_clause = match from_clause with Some v -> v | None -> [] in
      let group_clause = match group_clause with Some v -> v | None -> [] in
      let group_distinct = match group_distinct with Some v -> v | None -> false in
      let window_clause = match window_clause with Some v -> v | None -> [] in
      let values_lists = match values_lists with Some v -> v | None -> [] in
      let sort_clause = match sort_clause with Some v -> v | None -> [] in
      let limit_option = match limit_option with Some v -> v | None -> (LimitOption.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let locking_clause = match locking_clause with Some v -> v | None -> [] in
      let op = match op with Some v -> v | None -> (SetOperation.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let all = match all with Some v -> v | None -> false in
      { distinct_clause; into_clause; target_list; from_clause; where_clause; group_clause; group_distinct; having_clause; window_clause; values_lists; sort_clause; limit_offset; limit_count; limit_option; locking_clause; with_clause; op; all; larg; rarg }
    
    let to_proto =
      let apply = fun ~f:f' { distinct_clause; into_clause; target_list; from_clause; where_clause; group_clause; group_distinct; having_clause; window_clause; values_lists; sort_clause; limit_offset; limit_count; limit_option; locking_clause; with_clause; op; all; larg; rarg } -> f' [] distinct_clause into_clause target_list from_clause where_clause group_clause group_distinct having_clause window_clause values_lists sort_clause limit_offset limit_count limit_option locking_clause with_clause op all larg rarg in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (2, (message (fun t -> IntoClause.to_proto t))) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (5, (message (fun t -> Node.to_proto t))) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (7, bool, proto3) ^:: basic_opt (8, (message (fun t -> Node.to_proto t))) ^:: repeated (9, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (10, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (11, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (12, (message (fun t -> Node.to_proto t))) ^:: basic_opt (13, (message (fun t -> Node.to_proto t))) ^:: basic (14, (enum LimitOption.to_int), proto3) ^:: repeated (15, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (16, (message (fun t -> WithClause.to_proto t))) ^:: basic (17, (enum SetOperation.to_int), proto3) ^:: basic (18, bool, proto3) ^:: basic_opt (19, (message (fun t -> SelectStmt.to_proto t))) ^:: basic_opt (20, (message (fun t -> SelectStmt.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions distinct_clause into_clause target_list from_clause where_clause group_clause group_distinct having_clause window_clause values_lists sort_clause limit_offset limit_count limit_option locking_clause with_clause op all larg rarg -> { distinct_clause; into_clause; target_list; from_clause; where_clause; group_clause; group_distinct; having_clause; window_clause; values_lists; sort_clause; limit_offset; limit_count; limit_option; locking_clause; with_clause; op; all; larg; rarg } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (2, (message (fun t -> IntoClause.from_proto t))) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (5, (message (fun t -> Node.from_proto t))) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (7, bool, proto3) ^:: basic_opt (8, (message (fun t -> Node.from_proto t))) ^:: repeated (9, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (10, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (11, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (12, (message (fun t -> Node.from_proto t))) ^:: basic_opt (13, (message (fun t -> Node.from_proto t))) ^:: basic (14, (enum LimitOption.from_int), proto3) ^:: repeated (15, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (16, (message (fun t -> WithClause.from_proto t))) ^:: basic (17, (enum SetOperation.from_int), proto3) ^:: basic (18, bool, proto3) ^:: basic_opt (19, (message (fun t -> SelectStmt.from_proto t))) ^:: basic_opt (20, (message (fun t -> SelectStmt.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ReturnStmt : sig
    val name': unit -> string
    type t = Node.t option 
    val make : ?returnval:Node.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ReturnStmt"
    type t = Node.t option
    let make =
      fun ?returnval () -> 
      
      returnval
    
    let to_proto =
      let apply = fun ~f:f' returnval -> f' [] returnval in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions returnval -> returnval in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PLAssignStmt : sig
    val name': unit -> string
    type t = { name: string; indirection: Node.t list; nnames: int; val': SelectStmt.t option; location: int } 
    val make : ?name:string -> ?indirection:Node.t list -> ?nnames:int -> ?val':SelectStmt.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.PLAssignStmt"
    type t = { name: string; indirection: Node.t list; nnames: int; val': SelectStmt.t option; location: int }
    let make =
      fun ?name ?indirection ?nnames ?val' ?location () -> 
      let name = match name with Some v -> v | None -> {||} in
      let indirection = match indirection with Some v -> v | None -> [] in
      let nnames = match nnames with Some v -> v | None -> 0 in
      let location = match location with Some v -> v | None -> 0 in
      { name; indirection; nnames; val'; location }
    
    let to_proto =
      let apply = fun ~f:f' { name; indirection; nnames; val'; location } -> f' [] name indirection nnames val' location in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, int32_int, proto3) ^:: basic_opt (4, (message (fun t -> SelectStmt.to_proto t))) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name indirection nnames val' location -> { name; indirection; nnames; val'; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, int32_int, proto3) ^:: basic_opt (4, (message (fun t -> SelectStmt.from_proto t))) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterTableStmt : sig
    val name': unit -> string
    type t = { relation: RangeVar.t option; cmds: Node.t list; objtype: ObjectType.t; missing_ok: bool } 
    val make : ?relation:RangeVar.t -> ?cmds:Node.t list -> ?objtype:ObjectType.t -> ?missing_ok:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterTableStmt"
    type t = { relation: RangeVar.t option; cmds: Node.t list; objtype: ObjectType.t; missing_ok: bool }
    let make =
      fun ?relation ?cmds ?objtype ?missing_ok () -> 
      let cmds = match cmds with Some v -> v | None -> [] in
      let objtype = match objtype with Some v -> v | None -> (ObjectType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let missing_ok = match missing_ok with Some v -> v | None -> false in
      { relation; cmds; objtype; missing_ok }
    
    let to_proto =
      let apply = fun ~f:f' { relation; cmds; objtype; missing_ok } -> f' [] relation cmds objtype missing_ok in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, (enum ObjectType.to_int), proto3) ^:: basic (4, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions relation cmds objtype missing_ok -> { relation; cmds; objtype; missing_ok } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, (enum ObjectType.from_int), proto3) ^:: basic (4, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterTableCmd : sig
    val name': unit -> string
    type t = { subtype: AlterTableType.t; name: string; num: int; newowner: RoleSpec.t option; def: Node.t option; behavior: DropBehavior.t; missing_ok: bool; recurse: bool } 
    val make : ?subtype:AlterTableType.t -> ?name:string -> ?num:int -> ?newowner:RoleSpec.t -> ?def:Node.t -> ?behavior:DropBehavior.t -> ?missing_ok:bool -> ?recurse:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterTableCmd"
    type t = { subtype: AlterTableType.t; name: string; num: int; newowner: RoleSpec.t option; def: Node.t option; behavior: DropBehavior.t; missing_ok: bool; recurse: bool }
    let make =
      fun ?subtype ?name ?num ?newowner ?def ?behavior ?missing_ok ?recurse () -> 
      let subtype = match subtype with Some v -> v | None -> (AlterTableType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let name = match name with Some v -> v | None -> {||} in
      let num = match num with Some v -> v | None -> 0 in
      let behavior = match behavior with Some v -> v | None -> (DropBehavior.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let missing_ok = match missing_ok with Some v -> v | None -> false in
      let recurse = match recurse with Some v -> v | None -> false in
      { subtype; name; num; newowner; def; behavior; missing_ok; recurse }
    
    let to_proto =
      let apply = fun ~f:f' { subtype; name; num; newowner; def; behavior; missing_ok; recurse } -> f' [] subtype name num newowner def behavior missing_ok recurse in
      let spec = Runtime'.Serialize.C.( basic (1, (enum AlterTableType.to_int), proto3) ^:: basic (2, string, proto3) ^:: basic (3, int32_int, proto3) ^:: basic_opt (4, (message (fun t -> RoleSpec.to_proto t))) ^:: basic_opt (5, (message (fun t -> Node.to_proto t))) ^:: basic (6, (enum DropBehavior.to_int), proto3) ^:: basic (7, bool, proto3) ^:: basic (8, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions subtype name num newowner def behavior missing_ok recurse -> { subtype; name; num; newowner; def; behavior; missing_ok; recurse } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum AlterTableType.from_int), proto3) ^:: basic (2, string, proto3) ^:: basic (3, int32_int, proto3) ^:: basic_opt (4, (message (fun t -> RoleSpec.from_proto t))) ^:: basic_opt (5, (message (fun t -> Node.from_proto t))) ^:: basic (6, (enum DropBehavior.from_int), proto3) ^:: basic (7, bool, proto3) ^:: basic (8, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterDomainStmt : sig
    val name': unit -> string
    type t = { subtype: string; type_name: Node.t list; name: string; def: Node.t option; behavior: DropBehavior.t; missing_ok: bool } 
    val make : ?subtype:string -> ?type_name:Node.t list -> ?name:string -> ?def:Node.t -> ?behavior:DropBehavior.t -> ?missing_ok:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterDomainStmt"
    type t = { subtype: string; type_name: Node.t list; name: string; def: Node.t option; behavior: DropBehavior.t; missing_ok: bool }
    let make =
      fun ?subtype ?type_name ?name ?def ?behavior ?missing_ok () -> 
      let subtype = match subtype with Some v -> v | None -> {||} in
      let type_name = match type_name with Some v -> v | None -> [] in
      let name = match name with Some v -> v | None -> {||} in
      let behavior = match behavior with Some v -> v | None -> (DropBehavior.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let missing_ok = match missing_ok with Some v -> v | None -> false in
      { subtype; type_name; name; def; behavior; missing_ok }
    
    let to_proto =
      let apply = fun ~f:f' { subtype; type_name; name; def; behavior; missing_ok } -> f' [] subtype type_name name def behavior missing_ok in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, string, proto3) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: basic (5, (enum DropBehavior.to_int), proto3) ^:: basic (6, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions subtype type_name name def behavior missing_ok -> { subtype; type_name; name; def; behavior; missing_ok } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, string, proto3) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: basic (5, (enum DropBehavior.from_int), proto3) ^:: basic (6, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SetOperationStmt : sig
    val name': unit -> string
    type t = { op: SetOperation.t; all: bool; larg: Node.t option; rarg: Node.t option; col_types: Node.t list; col_typmods: Node.t list; col_collations: Node.t list; group_clauses: Node.t list } 
    val make : ?op:SetOperation.t -> ?all:bool -> ?larg:Node.t -> ?rarg:Node.t -> ?col_types:Node.t list -> ?col_typmods:Node.t list -> ?col_collations:Node.t list -> ?group_clauses:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.SetOperationStmt"
    type t = { op: SetOperation.t; all: bool; larg: Node.t option; rarg: Node.t option; col_types: Node.t list; col_typmods: Node.t list; col_collations: Node.t list; group_clauses: Node.t list }
    let make =
      fun ?op ?all ?larg ?rarg ?col_types ?col_typmods ?col_collations ?group_clauses () -> 
      let op = match op with Some v -> v | None -> (SetOperation.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let all = match all with Some v -> v | None -> false in
      let col_types = match col_types with Some v -> v | None -> [] in
      let col_typmods = match col_typmods with Some v -> v | None -> [] in
      let col_collations = match col_collations with Some v -> v | None -> [] in
      let group_clauses = match group_clauses with Some v -> v | None -> [] in
      { op; all; larg; rarg; col_types; col_typmods; col_collations; group_clauses }
    
    let to_proto =
      let apply = fun ~f:f' { op; all; larg; rarg; col_types; col_typmods; col_collations; group_clauses } -> f' [] op all larg rarg col_types col_typmods col_collations group_clauses in
      let spec = Runtime'.Serialize.C.( basic (1, (enum SetOperation.to_int), proto3) ^:: basic (2, bool, proto3) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (7, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (8, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions op all larg rarg col_types col_typmods col_collations group_clauses -> { op; all; larg; rarg; col_types; col_typmods; col_collations; group_clauses } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum SetOperation.from_int), proto3) ^:: basic (2, bool, proto3) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (7, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (8, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and GrantStmt : sig
    val name': unit -> string
    type t = { is_grant: bool; targtype: GrantTargetType.t; objtype: ObjectType.t; objects: Node.t list; privileges: Node.t list; grantees: Node.t list; grant_option: bool; grantor: RoleSpec.t option; behavior: DropBehavior.t } 
    val make : ?is_grant:bool -> ?targtype:GrantTargetType.t -> ?objtype:ObjectType.t -> ?objects:Node.t list -> ?privileges:Node.t list -> ?grantees:Node.t list -> ?grant_option:bool -> ?grantor:RoleSpec.t -> ?behavior:DropBehavior.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.GrantStmt"
    type t = { is_grant: bool; targtype: GrantTargetType.t; objtype: ObjectType.t; objects: Node.t list; privileges: Node.t list; grantees: Node.t list; grant_option: bool; grantor: RoleSpec.t option; behavior: DropBehavior.t }
    let make =
      fun ?is_grant ?targtype ?objtype ?objects ?privileges ?grantees ?grant_option ?grantor ?behavior () -> 
      let is_grant = match is_grant with Some v -> v | None -> false in
      let targtype = match targtype with Some v -> v | None -> (GrantTargetType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let objtype = match objtype with Some v -> v | None -> (ObjectType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let objects = match objects with Some v -> v | None -> [] in
      let privileges = match privileges with Some v -> v | None -> [] in
      let grantees = match grantees with Some v -> v | None -> [] in
      let grant_option = match grant_option with Some v -> v | None -> false in
      let behavior = match behavior with Some v -> v | None -> (DropBehavior.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { is_grant; targtype; objtype; objects; privileges; grantees; grant_option; grantor; behavior }
    
    let to_proto =
      let apply = fun ~f:f' { is_grant; targtype; objtype; objects; privileges; grantees; grant_option; grantor; behavior } -> f' [] is_grant targtype objtype objects privileges grantees grant_option grantor behavior in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic (2, (enum GrantTargetType.to_int), proto3) ^:: basic (3, (enum ObjectType.to_int), proto3) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (7, bool, proto3) ^:: basic_opt (8, (message (fun t -> RoleSpec.to_proto t))) ^:: basic (9, (enum DropBehavior.to_int), proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions is_grant targtype objtype objects privileges grantees grant_option grantor behavior -> { is_grant; targtype; objtype; objects; privileges; grantees; grant_option; grantor; behavior } in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic (2, (enum GrantTargetType.from_int), proto3) ^:: basic (3, (enum ObjectType.from_int), proto3) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (7, bool, proto3) ^:: basic_opt (8, (message (fun t -> RoleSpec.from_proto t))) ^:: basic (9, (enum DropBehavior.from_int), proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and GrantRoleStmt : sig
    val name': unit -> string
    type t = { granted_roles: Node.t list; grantee_roles: Node.t list; is_grant: bool; admin_opt: bool; grantor: RoleSpec.t option; behavior: DropBehavior.t } 
    val make : ?granted_roles:Node.t list -> ?grantee_roles:Node.t list -> ?is_grant:bool -> ?admin_opt:bool -> ?grantor:RoleSpec.t -> ?behavior:DropBehavior.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.GrantRoleStmt"
    type t = { granted_roles: Node.t list; grantee_roles: Node.t list; is_grant: bool; admin_opt: bool; grantor: RoleSpec.t option; behavior: DropBehavior.t }
    let make =
      fun ?granted_roles ?grantee_roles ?is_grant ?admin_opt ?grantor ?behavior () -> 
      let granted_roles = match granted_roles with Some v -> v | None -> [] in
      let grantee_roles = match grantee_roles with Some v -> v | None -> [] in
      let is_grant = match is_grant with Some v -> v | None -> false in
      let admin_opt = match admin_opt with Some v -> v | None -> false in
      let behavior = match behavior with Some v -> v | None -> (DropBehavior.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { granted_roles; grantee_roles; is_grant; admin_opt; grantor; behavior }
    
    let to_proto =
      let apply = fun ~f:f' { granted_roles; grantee_roles; is_grant; admin_opt; grantor; behavior } -> f' [] granted_roles grantee_roles is_grant admin_opt grantor behavior in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, bool, proto3) ^:: basic (4, bool, proto3) ^:: basic_opt (5, (message (fun t -> RoleSpec.to_proto t))) ^:: basic (6, (enum DropBehavior.to_int), proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions granted_roles grantee_roles is_grant admin_opt grantor behavior -> { granted_roles; grantee_roles; is_grant; admin_opt; grantor; behavior } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, bool, proto3) ^:: basic (4, bool, proto3) ^:: basic_opt (5, (message (fun t -> RoleSpec.from_proto t))) ^:: basic (6, (enum DropBehavior.from_int), proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterDefaultPrivilegesStmt : sig
    val name': unit -> string
    type t = { options: Node.t list; action: GrantStmt.t option } 
    val make : ?options:Node.t list -> ?action:GrantStmt.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterDefaultPrivilegesStmt"
    type t = { options: Node.t list; action: GrantStmt.t option }
    let make =
      fun ?options ?action () -> 
      let options = match options with Some v -> v | None -> [] in
      { options; action }
    
    let to_proto =
      let apply = fun ~f:f' { options; action } -> f' [] options action in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (2, (message (fun t -> GrantStmt.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions options action -> { options; action } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (2, (message (fun t -> GrantStmt.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ClosePortalStmt : sig
    val name': unit -> string
    type t = string 
    val make : ?portalname:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ClosePortalStmt"
    type t = string
    let make =
      fun ?portalname () -> 
      let portalname = match portalname with Some v -> v | None -> {||} in
      portalname
    
    let to_proto =
      let apply = fun ~f:f' portalname -> f' [] portalname in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions portalname -> portalname in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ClusterStmt : sig
    val name': unit -> string
    type t = { relation: RangeVar.t option; indexname: string; params: Node.t list } 
    val make : ?relation:RangeVar.t -> ?indexname:string -> ?params:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ClusterStmt"
    type t = { relation: RangeVar.t option; indexname: string; params: Node.t list }
    let make =
      fun ?relation ?indexname ?params () -> 
      let indexname = match indexname with Some v -> v | None -> {||} in
      let params = match params with Some v -> v | None -> [] in
      { relation; indexname; params }
    
    let to_proto =
      let apply = fun ~f:f' { relation; indexname; params } -> f' [] relation indexname params in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions relation indexname params -> { relation; indexname; params } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CopyStmt : sig
    val name': unit -> string
    type t = { relation: RangeVar.t option; query: Node.t option; attlist: Node.t list; is_from: bool; is_program: bool; filename: string; options: Node.t list; where_clause: Node.t option } 
    val make : ?relation:RangeVar.t -> ?query:Node.t -> ?attlist:Node.t list -> ?is_from:bool -> ?is_program:bool -> ?filename:string -> ?options:Node.t list -> ?where_clause:Node.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CopyStmt"
    type t = { relation: RangeVar.t option; query: Node.t option; attlist: Node.t list; is_from: bool; is_program: bool; filename: string; options: Node.t list; where_clause: Node.t option }
    let make =
      fun ?relation ?query ?attlist ?is_from ?is_program ?filename ?options ?where_clause () -> 
      let attlist = match attlist with Some v -> v | None -> [] in
      let is_from = match is_from with Some v -> v | None -> false in
      let is_program = match is_program with Some v -> v | None -> false in
      let filename = match filename with Some v -> v | None -> {||} in
      let options = match options with Some v -> v | None -> [] in
      { relation; query; attlist; is_from; is_program; filename; options; where_clause }
    
    let to_proto =
      let apply = fun ~f:f' { relation; query; attlist; is_from; is_program; filename; options; where_clause } -> f' [] relation query attlist is_from is_program filename options where_clause in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (4, bool, proto3) ^:: basic (5, bool, proto3) ^:: basic (6, string, proto3) ^:: repeated (7, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (8, (message (fun t -> Node.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions relation query attlist is_from is_program filename options where_clause -> { relation; query; attlist; is_from; is_program; filename; options; where_clause } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (4, bool, proto3) ^:: basic (5, bool, proto3) ^:: basic (6, string, proto3) ^:: repeated (7, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (8, (message (fun t -> Node.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateStmt : sig
    val name': unit -> string
    type t = { relation: RangeVar.t option; table_elts: Node.t list; inh_relations: Node.t list; partbound: PartitionBoundSpec.t option; partspec: PartitionSpec.t option; of_typename: TypeName.t option; constraints: Node.t list; options: Node.t list; oncommit: OnCommitAction.t; tablespacename: string; access_method: string; if_not_exists: bool } 
    val make : ?relation:RangeVar.t -> ?table_elts:Node.t list -> ?inh_relations:Node.t list -> ?partbound:PartitionBoundSpec.t -> ?partspec:PartitionSpec.t -> ?of_typename:TypeName.t -> ?constraints:Node.t list -> ?options:Node.t list -> ?oncommit:OnCommitAction.t -> ?tablespacename:string -> ?access_method:string -> ?if_not_exists:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateStmt"
    type t = { relation: RangeVar.t option; table_elts: Node.t list; inh_relations: Node.t list; partbound: PartitionBoundSpec.t option; partspec: PartitionSpec.t option; of_typename: TypeName.t option; constraints: Node.t list; options: Node.t list; oncommit: OnCommitAction.t; tablespacename: string; access_method: string; if_not_exists: bool }
    let make =
      fun ?relation ?table_elts ?inh_relations ?partbound ?partspec ?of_typename ?constraints ?options ?oncommit ?tablespacename ?access_method ?if_not_exists () -> 
      let table_elts = match table_elts with Some v -> v | None -> [] in
      let inh_relations = match inh_relations with Some v -> v | None -> [] in
      let constraints = match constraints with Some v -> v | None -> [] in
      let options = match options with Some v -> v | None -> [] in
      let oncommit = match oncommit with Some v -> v | None -> (OnCommitAction.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let tablespacename = match tablespacename with Some v -> v | None -> {||} in
      let access_method = match access_method with Some v -> v | None -> {||} in
      let if_not_exists = match if_not_exists with Some v -> v | None -> false in
      { relation; table_elts; inh_relations; partbound; partspec; of_typename; constraints; options; oncommit; tablespacename; access_method; if_not_exists }
    
    let to_proto =
      let apply = fun ~f:f' { relation; table_elts; inh_relations; partbound; partspec; of_typename; constraints; options; oncommit; tablespacename; access_method; if_not_exists } -> f' [] relation table_elts inh_relations partbound partspec of_typename constraints options oncommit tablespacename access_method if_not_exists in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> PartitionBoundSpec.to_proto t))) ^:: basic_opt (5, (message (fun t -> PartitionSpec.to_proto t))) ^:: basic_opt (6, (message (fun t -> TypeName.to_proto t))) ^:: repeated (7, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (8, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (9, (enum OnCommitAction.to_int), proto3) ^:: basic (10, string, proto3) ^:: basic (11, string, proto3) ^:: basic (12, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions relation table_elts inh_relations partbound partspec of_typename constraints options oncommit tablespacename access_method if_not_exists -> { relation; table_elts; inh_relations; partbound; partspec; of_typename; constraints; options; oncommit; tablespacename; access_method; if_not_exists } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> PartitionBoundSpec.from_proto t))) ^:: basic_opt (5, (message (fun t -> PartitionSpec.from_proto t))) ^:: basic_opt (6, (message (fun t -> TypeName.from_proto t))) ^:: repeated (7, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (8, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (9, (enum OnCommitAction.from_int), proto3) ^:: basic (10, string, proto3) ^:: basic (11, string, proto3) ^:: basic (12, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DefineStmt : sig
    val name': unit -> string
    type t = { kind: ObjectType.t; oldstyle: bool; defnames: Node.t list; args: Node.t list; definition: Node.t list; if_not_exists: bool; replace: bool } 
    val make : ?kind:ObjectType.t -> ?oldstyle:bool -> ?defnames:Node.t list -> ?args:Node.t list -> ?definition:Node.t list -> ?if_not_exists:bool -> ?replace:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.DefineStmt"
    type t = { kind: ObjectType.t; oldstyle: bool; defnames: Node.t list; args: Node.t list; definition: Node.t list; if_not_exists: bool; replace: bool }
    let make =
      fun ?kind ?oldstyle ?defnames ?args ?definition ?if_not_exists ?replace () -> 
      let kind = match kind with Some v -> v | None -> (ObjectType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let oldstyle = match oldstyle with Some v -> v | None -> false in
      let defnames = match defnames with Some v -> v | None -> [] in
      let args = match args with Some v -> v | None -> [] in
      let definition = match definition with Some v -> v | None -> [] in
      let if_not_exists = match if_not_exists with Some v -> v | None -> false in
      let replace = match replace with Some v -> v | None -> false in
      { kind; oldstyle; defnames; args; definition; if_not_exists; replace }
    
    let to_proto =
      let apply = fun ~f:f' { kind; oldstyle; defnames; args; definition; if_not_exists; replace } -> f' [] kind oldstyle defnames args definition if_not_exists replace in
      let spec = Runtime'.Serialize.C.( basic (1, (enum ObjectType.to_int), proto3) ^:: basic (2, bool, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (6, bool, proto3) ^:: basic (7, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions kind oldstyle defnames args definition if_not_exists replace -> { kind; oldstyle; defnames; args; definition; if_not_exists; replace } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum ObjectType.from_int), proto3) ^:: basic (2, bool, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (6, bool, proto3) ^:: basic (7, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DropStmt : sig
    val name': unit -> string
    type t = { objects: Node.t list; remove_type: ObjectType.t; behavior: DropBehavior.t; missing_ok: bool; concurrent: bool } 
    val make : ?objects:Node.t list -> ?remove_type:ObjectType.t -> ?behavior:DropBehavior.t -> ?missing_ok:bool -> ?concurrent:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.DropStmt"
    type t = { objects: Node.t list; remove_type: ObjectType.t; behavior: DropBehavior.t; missing_ok: bool; concurrent: bool }
    let make =
      fun ?objects ?remove_type ?behavior ?missing_ok ?concurrent () -> 
      let objects = match objects with Some v -> v | None -> [] in
      let remove_type = match remove_type with Some v -> v | None -> (ObjectType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let behavior = match behavior with Some v -> v | None -> (DropBehavior.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let missing_ok = match missing_ok with Some v -> v | None -> false in
      let concurrent = match concurrent with Some v -> v | None -> false in
      { objects; remove_type; behavior; missing_ok; concurrent }
    
    let to_proto =
      let apply = fun ~f:f' { objects; remove_type; behavior; missing_ok; concurrent } -> f' [] objects remove_type behavior missing_ok concurrent in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, (enum ObjectType.to_int), proto3) ^:: basic (3, (enum DropBehavior.to_int), proto3) ^:: basic (4, bool, proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions objects remove_type behavior missing_ok concurrent -> { objects; remove_type; behavior; missing_ok; concurrent } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, (enum ObjectType.from_int), proto3) ^:: basic (3, (enum DropBehavior.from_int), proto3) ^:: basic (4, bool, proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and TruncateStmt : sig
    val name': unit -> string
    type t = { relations: Node.t list; restart_seqs: bool; behavior: DropBehavior.t } 
    val make : ?relations:Node.t list -> ?restart_seqs:bool -> ?behavior:DropBehavior.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.TruncateStmt"
    type t = { relations: Node.t list; restart_seqs: bool; behavior: DropBehavior.t }
    let make =
      fun ?relations ?restart_seqs ?behavior () -> 
      let relations = match relations with Some v -> v | None -> [] in
      let restart_seqs = match restart_seqs with Some v -> v | None -> false in
      let behavior = match behavior with Some v -> v | None -> (DropBehavior.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { relations; restart_seqs; behavior }
    
    let to_proto =
      let apply = fun ~f:f' { relations; restart_seqs; behavior } -> f' [] relations restart_seqs behavior in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, bool, proto3) ^:: basic (3, (enum DropBehavior.to_int), proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions relations restart_seqs behavior -> { relations; restart_seqs; behavior } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, bool, proto3) ^:: basic (3, (enum DropBehavior.from_int), proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CommentStmt : sig
    val name': unit -> string
    type t = { objtype: ObjectType.t; object': Node.t option; comment: string } 
    val make : ?objtype:ObjectType.t -> ?object':Node.t -> ?comment:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CommentStmt"
    type t = { objtype: ObjectType.t; object': Node.t option; comment: string }
    let make =
      fun ?objtype ?object' ?comment () -> 
      let objtype = match objtype with Some v -> v | None -> (ObjectType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let comment = match comment with Some v -> v | None -> {||} in
      { objtype; object'; comment }
    
    let to_proto =
      let apply = fun ~f:f' { objtype; object'; comment } -> f' [] objtype object' comment in
      let spec = Runtime'.Serialize.C.( basic (1, (enum ObjectType.to_int), proto3) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic (3, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions objtype object' comment -> { objtype; object'; comment } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum ObjectType.from_int), proto3) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic (3, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and FetchStmt : sig
    val name': unit -> string
    type t = { direction: FetchDirection.t; how_many: int; portalname: string; ismove: bool } 
    val make : ?direction:FetchDirection.t -> ?how_many:int -> ?portalname:string -> ?ismove:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.FetchStmt"
    type t = { direction: FetchDirection.t; how_many: int; portalname: string; ismove: bool }
    let make =
      fun ?direction ?how_many ?portalname ?ismove () -> 
      let direction = match direction with Some v -> v | None -> (FetchDirection.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let how_many = match how_many with Some v -> v | None -> 0 in
      let portalname = match portalname with Some v -> v | None -> {||} in
      let ismove = match ismove with Some v -> v | None -> false in
      { direction; how_many; portalname; ismove }
    
    let to_proto =
      let apply = fun ~f:f' { direction; how_many; portalname; ismove } -> f' [] direction how_many portalname ismove in
      let spec = Runtime'.Serialize.C.( basic (1, (enum FetchDirection.to_int), proto3) ^:: basic (2, int64_int, proto3) ^:: basic (3, string, proto3) ^:: basic (4, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions direction how_many portalname ismove -> { direction; how_many; portalname; ismove } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum FetchDirection.from_int), proto3) ^:: basic (2, int64_int, proto3) ^:: basic (3, string, proto3) ^:: basic (4, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and IndexStmt : sig
    val name': unit -> string
    type t = { idxname: string; relation: RangeVar.t option; access_method: string; table_space: string; index_params: Node.t list; index_including_params: Node.t list; options: Node.t list; where_clause: Node.t option; exclude_op_names: Node.t list; idxcomment: string; index_oid: int; old_node: int; old_create_subid: int; old_first_relfilenode_subid: int; unique: bool; nulls_not_distinct: bool; primary: bool; isconstraint: bool; deferrable: bool; initdeferred: bool; transformed: bool; concurrent: bool; if_not_exists: bool; reset_default_tblspc: bool } 
    val make : ?idxname:string -> ?relation:RangeVar.t -> ?access_method:string -> ?table_space:string -> ?index_params:Node.t list -> ?index_including_params:Node.t list -> ?options:Node.t list -> ?where_clause:Node.t -> ?exclude_op_names:Node.t list -> ?idxcomment:string -> ?index_oid:int -> ?old_node:int -> ?old_create_subid:int -> ?old_first_relfilenode_subid:int -> ?unique:bool -> ?nulls_not_distinct:bool -> ?primary:bool -> ?isconstraint:bool -> ?deferrable:bool -> ?initdeferred:bool -> ?transformed:bool -> ?concurrent:bool -> ?if_not_exists:bool -> ?reset_default_tblspc:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.IndexStmt"
    type t = { idxname: string; relation: RangeVar.t option; access_method: string; table_space: string; index_params: Node.t list; index_including_params: Node.t list; options: Node.t list; where_clause: Node.t option; exclude_op_names: Node.t list; idxcomment: string; index_oid: int; old_node: int; old_create_subid: int; old_first_relfilenode_subid: int; unique: bool; nulls_not_distinct: bool; primary: bool; isconstraint: bool; deferrable: bool; initdeferred: bool; transformed: bool; concurrent: bool; if_not_exists: bool; reset_default_tblspc: bool }
    let make =
      fun ?idxname ?relation ?access_method ?table_space ?index_params ?index_including_params ?options ?where_clause ?exclude_op_names ?idxcomment ?index_oid ?old_node ?old_create_subid ?old_first_relfilenode_subid ?unique ?nulls_not_distinct ?primary ?isconstraint ?deferrable ?initdeferred ?transformed ?concurrent ?if_not_exists ?reset_default_tblspc () -> 
      let idxname = match idxname with Some v -> v | None -> {||} in
      let access_method = match access_method with Some v -> v | None -> {||} in
      let table_space = match table_space with Some v -> v | None -> {||} in
      let index_params = match index_params with Some v -> v | None -> [] in
      let index_including_params = match index_including_params with Some v -> v | None -> [] in
      let options = match options with Some v -> v | None -> [] in
      let exclude_op_names = match exclude_op_names with Some v -> v | None -> [] in
      let idxcomment = match idxcomment with Some v -> v | None -> {||} in
      let index_oid = match index_oid with Some v -> v | None -> 0 in
      let old_node = match old_node with Some v -> v | None -> 0 in
      let old_create_subid = match old_create_subid with Some v -> v | None -> 0 in
      let old_first_relfilenode_subid = match old_first_relfilenode_subid with Some v -> v | None -> 0 in
      let unique = match unique with Some v -> v | None -> false in
      let nulls_not_distinct = match nulls_not_distinct with Some v -> v | None -> false in
      let primary = match primary with Some v -> v | None -> false in
      let isconstraint = match isconstraint with Some v -> v | None -> false in
      let deferrable = match deferrable with Some v -> v | None -> false in
      let initdeferred = match initdeferred with Some v -> v | None -> false in
      let transformed = match transformed with Some v -> v | None -> false in
      let concurrent = match concurrent with Some v -> v | None -> false in
      let if_not_exists = match if_not_exists with Some v -> v | None -> false in
      let reset_default_tblspc = match reset_default_tblspc with Some v -> v | None -> false in
      { idxname; relation; access_method; table_space; index_params; index_including_params; options; where_clause; exclude_op_names; idxcomment; index_oid; old_node; old_create_subid; old_first_relfilenode_subid; unique; nulls_not_distinct; primary; isconstraint; deferrable; initdeferred; transformed; concurrent; if_not_exists; reset_default_tblspc }
    
    let to_proto =
      let apply = fun ~f:f' { idxname; relation; access_method; table_space; index_params; index_including_params; options; where_clause; exclude_op_names; idxcomment; index_oid; old_node; old_create_subid; old_first_relfilenode_subid; unique; nulls_not_distinct; primary; isconstraint; deferrable; initdeferred; transformed; concurrent; if_not_exists; reset_default_tblspc } -> f' [] idxname relation access_method table_space index_params index_including_params options where_clause exclude_op_names idxcomment index_oid old_node old_create_subid old_first_relfilenode_subid unique nulls_not_distinct primary isconstraint deferrable initdeferred transformed concurrent if_not_exists reset_default_tblspc in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> RangeVar.to_proto t))) ^:: basic (3, string, proto3) ^:: basic (4, string, proto3) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (7, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (8, (message (fun t -> Node.to_proto t))) ^:: repeated (9, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (10, string, proto3) ^:: basic (11, uint32_int, proto3) ^:: basic (12, uint32_int, proto3) ^:: basic (13, uint32_int, proto3) ^:: basic (14, uint32_int, proto3) ^:: basic (15, bool, proto3) ^:: basic (16, bool, proto3) ^:: basic (17, bool, proto3) ^:: basic (18, bool, proto3) ^:: basic (19, bool, proto3) ^:: basic (20, bool, proto3) ^:: basic (21, bool, proto3) ^:: basic (22, bool, proto3) ^:: basic (23, bool, proto3) ^:: basic (24, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions idxname relation access_method table_space index_params index_including_params options where_clause exclude_op_names idxcomment index_oid old_node old_create_subid old_first_relfilenode_subid unique nulls_not_distinct primary isconstraint deferrable initdeferred transformed concurrent if_not_exists reset_default_tblspc -> { idxname; relation; access_method; table_space; index_params; index_including_params; options; where_clause; exclude_op_names; idxcomment; index_oid; old_node; old_create_subid; old_first_relfilenode_subid; unique; nulls_not_distinct; primary; isconstraint; deferrable; initdeferred; transformed; concurrent; if_not_exists; reset_default_tblspc } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> RangeVar.from_proto t))) ^:: basic (3, string, proto3) ^:: basic (4, string, proto3) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (7, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (8, (message (fun t -> Node.from_proto t))) ^:: repeated (9, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (10, string, proto3) ^:: basic (11, uint32_int, proto3) ^:: basic (12, uint32_int, proto3) ^:: basic (13, uint32_int, proto3) ^:: basic (14, uint32_int, proto3) ^:: basic (15, bool, proto3) ^:: basic (16, bool, proto3) ^:: basic (17, bool, proto3) ^:: basic (18, bool, proto3) ^:: basic (19, bool, proto3) ^:: basic (20, bool, proto3) ^:: basic (21, bool, proto3) ^:: basic (22, bool, proto3) ^:: basic (23, bool, proto3) ^:: basic (24, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateFunctionStmt : sig
    val name': unit -> string
    type t = { is_procedure: bool; replace: bool; funcname: Node.t list; parameters: Node.t list; return_type: TypeName.t option; options: Node.t list; sql_body: Node.t option } 
    val make : ?is_procedure:bool -> ?replace:bool -> ?funcname:Node.t list -> ?parameters:Node.t list -> ?return_type:TypeName.t -> ?options:Node.t list -> ?sql_body:Node.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateFunctionStmt"
    type t = { is_procedure: bool; replace: bool; funcname: Node.t list; parameters: Node.t list; return_type: TypeName.t option; options: Node.t list; sql_body: Node.t option }
    let make =
      fun ?is_procedure ?replace ?funcname ?parameters ?return_type ?options ?sql_body () -> 
      let is_procedure = match is_procedure with Some v -> v | None -> false in
      let replace = match replace with Some v -> v | None -> false in
      let funcname = match funcname with Some v -> v | None -> [] in
      let parameters = match parameters with Some v -> v | None -> [] in
      let options = match options with Some v -> v | None -> [] in
      { is_procedure; replace; funcname; parameters; return_type; options; sql_body }
    
    let to_proto =
      let apply = fun ~f:f' { is_procedure; replace; funcname; parameters; return_type; options; sql_body } -> f' [] is_procedure replace funcname parameters return_type options sql_body in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic (2, bool, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (5, (message (fun t -> TypeName.to_proto t))) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (7, (message (fun t -> Node.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions is_procedure replace funcname parameters return_type options sql_body -> { is_procedure; replace; funcname; parameters; return_type; options; sql_body } in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic (2, bool, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (5, (message (fun t -> TypeName.from_proto t))) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (7, (message (fun t -> Node.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterFunctionStmt : sig
    val name': unit -> string
    type t = { objtype: ObjectType.t; func: ObjectWithArgs.t option; actions: Node.t list } 
    val make : ?objtype:ObjectType.t -> ?func:ObjectWithArgs.t -> ?actions:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterFunctionStmt"
    type t = { objtype: ObjectType.t; func: ObjectWithArgs.t option; actions: Node.t list }
    let make =
      fun ?objtype ?func ?actions () -> 
      let objtype = match objtype with Some v -> v | None -> (ObjectType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let actions = match actions with Some v -> v | None -> [] in
      { objtype; func; actions }
    
    let to_proto =
      let apply = fun ~f:f' { objtype; func; actions } -> f' [] objtype func actions in
      let spec = Runtime'.Serialize.C.( basic (1, (enum ObjectType.to_int), proto3) ^:: basic_opt (2, (message (fun t -> ObjectWithArgs.to_proto t))) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions objtype func actions -> { objtype; func; actions } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum ObjectType.from_int), proto3) ^:: basic_opt (2, (message (fun t -> ObjectWithArgs.from_proto t))) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DoStmt : sig
    val name': unit -> string
    type t = Node.t list 
    val make : ?args:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.DoStmt"
    type t = Node.t list
    let make =
      fun ?args () -> 
      let args = match args with Some v -> v | None -> [] in
      args
    
    let to_proto =
      let apply = fun ~f:f' args -> f' [] args in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions args -> args in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RenameStmt : sig
    val name': unit -> string
    type t = { rename_type: ObjectType.t; relation_type: ObjectType.t; relation: RangeVar.t option; object': Node.t option; subname: string; newname: string; behavior: DropBehavior.t; missing_ok: bool } 
    val make : ?rename_type:ObjectType.t -> ?relation_type:ObjectType.t -> ?relation:RangeVar.t -> ?object':Node.t -> ?subname:string -> ?newname:string -> ?behavior:DropBehavior.t -> ?missing_ok:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RenameStmt"
    type t = { rename_type: ObjectType.t; relation_type: ObjectType.t; relation: RangeVar.t option; object': Node.t option; subname: string; newname: string; behavior: DropBehavior.t; missing_ok: bool }
    let make =
      fun ?rename_type ?relation_type ?relation ?object' ?subname ?newname ?behavior ?missing_ok () -> 
      let rename_type = match rename_type with Some v -> v | None -> (ObjectType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let relation_type = match relation_type with Some v -> v | None -> (ObjectType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let subname = match subname with Some v -> v | None -> {||} in
      let newname = match newname with Some v -> v | None -> {||} in
      let behavior = match behavior with Some v -> v | None -> (DropBehavior.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let missing_ok = match missing_ok with Some v -> v | None -> false in
      { rename_type; relation_type; relation; object'; subname; newname; behavior; missing_ok }
    
    let to_proto =
      let apply = fun ~f:f' { rename_type; relation_type; relation; object'; subname; newname; behavior; missing_ok } -> f' [] rename_type relation_type relation object' subname newname behavior missing_ok in
      let spec = Runtime'.Serialize.C.( basic (1, (enum ObjectType.to_int), proto3) ^:: basic (2, (enum ObjectType.to_int), proto3) ^:: basic_opt (3, (message (fun t -> RangeVar.to_proto t))) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: basic (5, string, proto3) ^:: basic (6, string, proto3) ^:: basic (7, (enum DropBehavior.to_int), proto3) ^:: basic (8, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions rename_type relation_type relation object' subname newname behavior missing_ok -> { rename_type; relation_type; relation; object'; subname; newname; behavior; missing_ok } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum ObjectType.from_int), proto3) ^:: basic (2, (enum ObjectType.from_int), proto3) ^:: basic_opt (3, (message (fun t -> RangeVar.from_proto t))) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: basic (5, string, proto3) ^:: basic (6, string, proto3) ^:: basic (7, (enum DropBehavior.from_int), proto3) ^:: basic (8, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RuleStmt : sig
    val name': unit -> string
    type t = { relation: RangeVar.t option; rulename: string; where_clause: Node.t option; event: CmdType.t; instead: bool; actions: Node.t list; replace: bool } 
    val make : ?relation:RangeVar.t -> ?rulename:string -> ?where_clause:Node.t -> ?event:CmdType.t -> ?instead:bool -> ?actions:Node.t list -> ?replace:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RuleStmt"
    type t = { relation: RangeVar.t option; rulename: string; where_clause: Node.t option; event: CmdType.t; instead: bool; actions: Node.t list; replace: bool }
    let make =
      fun ?relation ?rulename ?where_clause ?event ?instead ?actions ?replace () -> 
      let rulename = match rulename with Some v -> v | None -> {||} in
      let event = match event with Some v -> v | None -> (CmdType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let instead = match instead with Some v -> v | None -> false in
      let actions = match actions with Some v -> v | None -> [] in
      let replace = match replace with Some v -> v | None -> false in
      { relation; rulename; where_clause; event; instead; actions; replace }
    
    let to_proto =
      let apply = fun ~f:f' { relation; rulename; where_clause; event; instead; actions; replace } -> f' [] relation rulename where_clause event instead actions replace in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: basic (2, string, proto3) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: basic (4, (enum CmdType.to_int), proto3) ^:: basic (5, bool, proto3) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (7, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions relation rulename where_clause event instead actions replace -> { relation; rulename; where_clause; event; instead; actions; replace } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: basic (2, string, proto3) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: basic (4, (enum CmdType.from_int), proto3) ^:: basic (5, bool, proto3) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (7, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and NotifyStmt : sig
    val name': unit -> string
    type t = { conditionname: string; payload: string } 
    val make : ?conditionname:string -> ?payload:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.NotifyStmt"
    type t = { conditionname: string; payload: string }
    let make =
      fun ?conditionname ?payload () -> 
      let conditionname = match conditionname with Some v -> v | None -> {||} in
      let payload = match payload with Some v -> v | None -> {||} in
      { conditionname; payload }
    
    let to_proto =
      let apply = fun ~f:f' { conditionname; payload } -> f' [] conditionname payload in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions conditionname payload -> { conditionname; payload } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ListenStmt : sig
    val name': unit -> string
    type t = string 
    val make : ?conditionname:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ListenStmt"
    type t = string
    let make =
      fun ?conditionname () -> 
      let conditionname = match conditionname with Some v -> v | None -> {||} in
      conditionname
    
    let to_proto =
      let apply = fun ~f:f' conditionname -> f' [] conditionname in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions conditionname -> conditionname in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and UnlistenStmt : sig
    val name': unit -> string
    type t = string 
    val make : ?conditionname:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.UnlistenStmt"
    type t = string
    let make =
      fun ?conditionname () -> 
      let conditionname = match conditionname with Some v -> v | None -> {||} in
      conditionname
    
    let to_proto =
      let apply = fun ~f:f' conditionname -> f' [] conditionname in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions conditionname -> conditionname in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and TransactionStmt : sig
    val name': unit -> string
    type t = { kind: TransactionStmtKind.t; options: Node.t list; savepoint_name: string; gid: string; chain: bool } 
    val make : ?kind:TransactionStmtKind.t -> ?options:Node.t list -> ?savepoint_name:string -> ?gid:string -> ?chain:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.TransactionStmt"
    type t = { kind: TransactionStmtKind.t; options: Node.t list; savepoint_name: string; gid: string; chain: bool }
    let make =
      fun ?kind ?options ?savepoint_name ?gid ?chain () -> 
      let kind = match kind with Some v -> v | None -> (TransactionStmtKind.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let options = match options with Some v -> v | None -> [] in
      let savepoint_name = match savepoint_name with Some v -> v | None -> {||} in
      let gid = match gid with Some v -> v | None -> {||} in
      let chain = match chain with Some v -> v | None -> false in
      { kind; options; savepoint_name; gid; chain }
    
    let to_proto =
      let apply = fun ~f:f' { kind; options; savepoint_name; gid; chain } -> f' [] kind options savepoint_name gid chain in
      let spec = Runtime'.Serialize.C.( basic (1, (enum TransactionStmtKind.to_int), proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, string, proto3) ^:: basic (4, string, proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions kind options savepoint_name gid chain -> { kind; options; savepoint_name; gid; chain } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum TransactionStmtKind.from_int), proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, string, proto3) ^:: basic (4, string, proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ViewStmt : sig
    val name': unit -> string
    type t = { view: RangeVar.t option; aliases: Node.t list; query: Node.t option; replace: bool; options: Node.t list; with_check_option: ViewCheckOption.t } 
    val make : ?view:RangeVar.t -> ?aliases:Node.t list -> ?query:Node.t -> ?replace:bool -> ?options:Node.t list -> ?with_check_option:ViewCheckOption.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ViewStmt"
    type t = { view: RangeVar.t option; aliases: Node.t list; query: Node.t option; replace: bool; options: Node.t list; with_check_option: ViewCheckOption.t }
    let make =
      fun ?view ?aliases ?query ?replace ?options ?with_check_option () -> 
      let aliases = match aliases with Some v -> v | None -> [] in
      let replace = match replace with Some v -> v | None -> false in
      let options = match options with Some v -> v | None -> [] in
      let with_check_option = match with_check_option with Some v -> v | None -> (ViewCheckOption.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { view; aliases; query; replace; options; with_check_option }
    
    let to_proto =
      let apply = fun ~f:f' { view; aliases; query; replace; options; with_check_option } -> f' [] view aliases query replace options with_check_option in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: basic (4, bool, proto3) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (6, (enum ViewCheckOption.to_int), proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions view aliases query replace options with_check_option -> { view; aliases; query; replace; options; with_check_option } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: basic (4, bool, proto3) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (6, (enum ViewCheckOption.from_int), proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and LoadStmt : sig
    val name': unit -> string
    type t = string 
    val make : ?filename:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.LoadStmt"
    type t = string
    let make =
      fun ?filename () -> 
      let filename = match filename with Some v -> v | None -> {||} in
      filename
    
    let to_proto =
      let apply = fun ~f:f' filename -> f' [] filename in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions filename -> filename in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateDomainStmt : sig
    val name': unit -> string
    type t = { domainname: Node.t list; type_name: TypeName.t option; coll_clause: CollateClause.t option; constraints: Node.t list } 
    val make : ?domainname:Node.t list -> ?type_name:TypeName.t -> ?coll_clause:CollateClause.t -> ?constraints:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateDomainStmt"
    type t = { domainname: Node.t list; type_name: TypeName.t option; coll_clause: CollateClause.t option; constraints: Node.t list }
    let make =
      fun ?domainname ?type_name ?coll_clause ?constraints () -> 
      let domainname = match domainname with Some v -> v | None -> [] in
      let constraints = match constraints with Some v -> v | None -> [] in
      { domainname; type_name; coll_clause; constraints }
    
    let to_proto =
      let apply = fun ~f:f' { domainname; type_name; coll_clause; constraints } -> f' [] domainname type_name coll_clause constraints in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (2, (message (fun t -> TypeName.to_proto t))) ^:: basic_opt (3, (message (fun t -> CollateClause.to_proto t))) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions domainname type_name coll_clause constraints -> { domainname; type_name; coll_clause; constraints } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (2, (message (fun t -> TypeName.from_proto t))) ^:: basic_opt (3, (message (fun t -> CollateClause.from_proto t))) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreatedbStmt : sig
    val name': unit -> string
    type t = { dbname: string; options: Node.t list } 
    val make : ?dbname:string -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreatedbStmt"
    type t = { dbname: string; options: Node.t list }
    let make =
      fun ?dbname ?options () -> 
      let dbname = match dbname with Some v -> v | None -> {||} in
      let options = match options with Some v -> v | None -> [] in
      { dbname; options }
    
    let to_proto =
      let apply = fun ~f:f' { dbname; options } -> f' [] dbname options in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions dbname options -> { dbname; options } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DropdbStmt : sig
    val name': unit -> string
    type t = { dbname: string; missing_ok: bool; options: Node.t list } 
    val make : ?dbname:string -> ?missing_ok:bool -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.DropdbStmt"
    type t = { dbname: string; missing_ok: bool; options: Node.t list }
    let make =
      fun ?dbname ?missing_ok ?options () -> 
      let dbname = match dbname with Some v -> v | None -> {||} in
      let missing_ok = match missing_ok with Some v -> v | None -> false in
      let options = match options with Some v -> v | None -> [] in
      { dbname; missing_ok; options }
    
    let to_proto =
      let apply = fun ~f:f' { dbname; missing_ok; options } -> f' [] dbname missing_ok options in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions dbname missing_ok options -> { dbname; missing_ok; options } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and VacuumStmt : sig
    val name': unit -> string
    type t = { options: Node.t list; rels: Node.t list; is_vacuumcmd: bool } 
    val make : ?options:Node.t list -> ?rels:Node.t list -> ?is_vacuumcmd:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.VacuumStmt"
    type t = { options: Node.t list; rels: Node.t list; is_vacuumcmd: bool }
    let make =
      fun ?options ?rels ?is_vacuumcmd () -> 
      let options = match options with Some v -> v | None -> [] in
      let rels = match rels with Some v -> v | None -> [] in
      let is_vacuumcmd = match is_vacuumcmd with Some v -> v | None -> false in
      { options; rels; is_vacuumcmd }
    
    let to_proto =
      let apply = fun ~f:f' { options; rels; is_vacuumcmd } -> f' [] options rels is_vacuumcmd in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions options rels is_vacuumcmd -> { options; rels; is_vacuumcmd } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ExplainStmt : sig
    val name': unit -> string
    type t = { query: Node.t option; options: Node.t list } 
    val make : ?query:Node.t -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ExplainStmt"
    type t = { query: Node.t option; options: Node.t list }
    let make =
      fun ?query ?options () -> 
      let options = match options with Some v -> v | None -> [] in
      { query; options }
    
    let to_proto =
      let apply = fun ~f:f' { query; options } -> f' [] query options in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions query options -> { query; options } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateTableAsStmt : sig
    val name': unit -> string
    type t = { query: Node.t option; into: IntoClause.t option; objtype: ObjectType.t; is_select_into: bool; if_not_exists: bool } 
    val make : ?query:Node.t -> ?into:IntoClause.t -> ?objtype:ObjectType.t -> ?is_select_into:bool -> ?if_not_exists:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateTableAsStmt"
    type t = { query: Node.t option; into: IntoClause.t option; objtype: ObjectType.t; is_select_into: bool; if_not_exists: bool }
    let make =
      fun ?query ?into ?objtype ?is_select_into ?if_not_exists () -> 
      let objtype = match objtype with Some v -> v | None -> (ObjectType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let is_select_into = match is_select_into with Some v -> v | None -> false in
      let if_not_exists = match if_not_exists with Some v -> v | None -> false in
      { query; into; objtype; is_select_into; if_not_exists }
    
    let to_proto =
      let apply = fun ~f:f' { query; into; objtype; is_select_into; if_not_exists } -> f' [] query into objtype is_select_into if_not_exists in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic_opt (2, (message (fun t -> IntoClause.to_proto t))) ^:: basic (3, (enum ObjectType.to_int), proto3) ^:: basic (4, bool, proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions query into objtype is_select_into if_not_exists -> { query; into; objtype; is_select_into; if_not_exists } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic_opt (2, (message (fun t -> IntoClause.from_proto t))) ^:: basic (3, (enum ObjectType.from_int), proto3) ^:: basic (4, bool, proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateSeqStmt : sig
    val name': unit -> string
    type t = { sequence: RangeVar.t option; options: Node.t list; owner_id: int; for_identity: bool; if_not_exists: bool } 
    val make : ?sequence:RangeVar.t -> ?options:Node.t list -> ?owner_id:int -> ?for_identity:bool -> ?if_not_exists:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateSeqStmt"
    type t = { sequence: RangeVar.t option; options: Node.t list; owner_id: int; for_identity: bool; if_not_exists: bool }
    let make =
      fun ?sequence ?options ?owner_id ?for_identity ?if_not_exists () -> 
      let options = match options with Some v -> v | None -> [] in
      let owner_id = match owner_id with Some v -> v | None -> 0 in
      let for_identity = match for_identity with Some v -> v | None -> false in
      let if_not_exists = match if_not_exists with Some v -> v | None -> false in
      { sequence; options; owner_id; for_identity; if_not_exists }
    
    let to_proto =
      let apply = fun ~f:f' { sequence; options; owner_id; for_identity; if_not_exists } -> f' [] sequence options owner_id for_identity if_not_exists in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, uint32_int, proto3) ^:: basic (4, bool, proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions sequence options owner_id for_identity if_not_exists -> { sequence; options; owner_id; for_identity; if_not_exists } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, uint32_int, proto3) ^:: basic (4, bool, proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterSeqStmt : sig
    val name': unit -> string
    type t = { sequence: RangeVar.t option; options: Node.t list; for_identity: bool; missing_ok: bool } 
    val make : ?sequence:RangeVar.t -> ?options:Node.t list -> ?for_identity:bool -> ?missing_ok:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterSeqStmt"
    type t = { sequence: RangeVar.t option; options: Node.t list; for_identity: bool; missing_ok: bool }
    let make =
      fun ?sequence ?options ?for_identity ?missing_ok () -> 
      let options = match options with Some v -> v | None -> [] in
      let for_identity = match for_identity with Some v -> v | None -> false in
      let missing_ok = match missing_ok with Some v -> v | None -> false in
      { sequence; options; for_identity; missing_ok }
    
    let to_proto =
      let apply = fun ~f:f' { sequence; options; for_identity; missing_ok } -> f' [] sequence options for_identity missing_ok in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, bool, proto3) ^:: basic (4, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions sequence options for_identity missing_ok -> { sequence; options; for_identity; missing_ok } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, bool, proto3) ^:: basic (4, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and VariableSetStmt : sig
    val name': unit -> string
    type t = { kind: VariableSetKind.t; name: string; args: Node.t list; is_local: bool } 
    val make : ?kind:VariableSetKind.t -> ?name:string -> ?args:Node.t list -> ?is_local:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.VariableSetStmt"
    type t = { kind: VariableSetKind.t; name: string; args: Node.t list; is_local: bool }
    let make =
      fun ?kind ?name ?args ?is_local () -> 
      let kind = match kind with Some v -> v | None -> (VariableSetKind.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let name = match name with Some v -> v | None -> {||} in
      let args = match args with Some v -> v | None -> [] in
      let is_local = match is_local with Some v -> v | None -> false in
      { kind; name; args; is_local }
    
    let to_proto =
      let apply = fun ~f:f' { kind; name; args; is_local } -> f' [] kind name args is_local in
      let spec = Runtime'.Serialize.C.( basic (1, (enum VariableSetKind.to_int), proto3) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (4, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions kind name args is_local -> { kind; name; args; is_local } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum VariableSetKind.from_int), proto3) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (4, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and VariableShowStmt : sig
    val name': unit -> string
    type t = string 
    val make : ?name:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.VariableShowStmt"
    type t = string
    let make =
      fun ?name () -> 
      let name = match name with Some v -> v | None -> {||} in
      name
    
    let to_proto =
      let apply = fun ~f:f' name -> f' [] name in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name -> name in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DiscardStmt : sig
    val name': unit -> string
    type t = DiscardMode.t 
    val make : ?target:DiscardMode.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.DiscardStmt"
    type t = DiscardMode.t
    let make =
      fun ?target () -> 
      let target = match target with Some v -> v | None -> (DiscardMode.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      target
    
    let to_proto =
      let apply = fun ~f:f' target -> f' [] target in
      let spec = Runtime'.Serialize.C.( basic (1, (enum DiscardMode.to_int), proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions target -> target in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum DiscardMode.from_int), proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateTrigStmt : sig
    val name': unit -> string
    type t = { replace: bool; isconstraint: bool; trigname: string; relation: RangeVar.t option; funcname: Node.t list; args: Node.t list; row: bool; timing: int; events: int; columns: Node.t list; when_clause: Node.t option; transition_rels: Node.t list; deferrable: bool; initdeferred: bool; constrrel: RangeVar.t option } 
    val make : ?replace:bool -> ?isconstraint:bool -> ?trigname:string -> ?relation:RangeVar.t -> ?funcname:Node.t list -> ?args:Node.t list -> ?row:bool -> ?timing:int -> ?events:int -> ?columns:Node.t list -> ?when_clause:Node.t -> ?transition_rels:Node.t list -> ?deferrable:bool -> ?initdeferred:bool -> ?constrrel:RangeVar.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateTrigStmt"
    type t = { replace: bool; isconstraint: bool; trigname: string; relation: RangeVar.t option; funcname: Node.t list; args: Node.t list; row: bool; timing: int; events: int; columns: Node.t list; when_clause: Node.t option; transition_rels: Node.t list; deferrable: bool; initdeferred: bool; constrrel: RangeVar.t option }
    let make =
      fun ?replace ?isconstraint ?trigname ?relation ?funcname ?args ?row ?timing ?events ?columns ?when_clause ?transition_rels ?deferrable ?initdeferred ?constrrel () -> 
      let replace = match replace with Some v -> v | None -> false in
      let isconstraint = match isconstraint with Some v -> v | None -> false in
      let trigname = match trigname with Some v -> v | None -> {||} in
      let funcname = match funcname with Some v -> v | None -> [] in
      let args = match args with Some v -> v | None -> [] in
      let row = match row with Some v -> v | None -> false in
      let timing = match timing with Some v -> v | None -> 0 in
      let events = match events with Some v -> v | None -> 0 in
      let columns = match columns with Some v -> v | None -> [] in
      let transition_rels = match transition_rels with Some v -> v | None -> [] in
      let deferrable = match deferrable with Some v -> v | None -> false in
      let initdeferred = match initdeferred with Some v -> v | None -> false in
      { replace; isconstraint; trigname; relation; funcname; args; row; timing; events; columns; when_clause; transition_rels; deferrable; initdeferred; constrrel }
    
    let to_proto =
      let apply = fun ~f:f' { replace; isconstraint; trigname; relation; funcname; args; row; timing; events; columns; when_clause; transition_rels; deferrable; initdeferred; constrrel } -> f' [] replace isconstraint trigname relation funcname args row timing events columns when_clause transition_rels deferrable initdeferred constrrel in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, string, proto3) ^:: basic_opt (4, (message (fun t -> RangeVar.to_proto t))) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (7, bool, proto3) ^:: basic (8, int32_int, proto3) ^:: basic (9, int32_int, proto3) ^:: repeated (10, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (11, (message (fun t -> Node.to_proto t))) ^:: repeated (12, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (13, bool, proto3) ^:: basic (14, bool, proto3) ^:: basic_opt (15, (message (fun t -> RangeVar.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions replace isconstraint trigname relation funcname args row timing events columns when_clause transition_rels deferrable initdeferred constrrel -> { replace; isconstraint; trigname; relation; funcname; args; row; timing; events; columns; when_clause; transition_rels; deferrable; initdeferred; constrrel } in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, string, proto3) ^:: basic_opt (4, (message (fun t -> RangeVar.from_proto t))) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (7, bool, proto3) ^:: basic (8, int32_int, proto3) ^:: basic (9, int32_int, proto3) ^:: repeated (10, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (11, (message (fun t -> Node.from_proto t))) ^:: repeated (12, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (13, bool, proto3) ^:: basic (14, bool, proto3) ^:: basic_opt (15, (message (fun t -> RangeVar.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreatePLangStmt : sig
    val name': unit -> string
    type t = { replace: bool; plname: string; plhandler: Node.t list; plinline: Node.t list; plvalidator: Node.t list; pltrusted: bool } 
    val make : ?replace:bool -> ?plname:string -> ?plhandler:Node.t list -> ?plinline:Node.t list -> ?plvalidator:Node.t list -> ?pltrusted:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreatePLangStmt"
    type t = { replace: bool; plname: string; plhandler: Node.t list; plinline: Node.t list; plvalidator: Node.t list; pltrusted: bool }
    let make =
      fun ?replace ?plname ?plhandler ?plinline ?plvalidator ?pltrusted () -> 
      let replace = match replace with Some v -> v | None -> false in
      let plname = match plname with Some v -> v | None -> {||} in
      let plhandler = match plhandler with Some v -> v | None -> [] in
      let plinline = match plinline with Some v -> v | None -> [] in
      let plvalidator = match plvalidator with Some v -> v | None -> [] in
      let pltrusted = match pltrusted with Some v -> v | None -> false in
      { replace; plname; plhandler; plinline; plvalidator; pltrusted }
    
    let to_proto =
      let apply = fun ~f:f' { replace; plname; plhandler; plinline; plvalidator; pltrusted } -> f' [] replace plname plhandler plinline plvalidator pltrusted in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (6, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions replace plname plhandler plinline plvalidator pltrusted -> { replace; plname; plhandler; plinline; plvalidator; pltrusted } in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (6, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateRoleStmt : sig
    val name': unit -> string
    type t = { stmt_type: RoleStmtType.t; role: string; options: Node.t list } 
    val make : ?stmt_type:RoleStmtType.t -> ?role:string -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateRoleStmt"
    type t = { stmt_type: RoleStmtType.t; role: string; options: Node.t list }
    let make =
      fun ?stmt_type ?role ?options () -> 
      let stmt_type = match stmt_type with Some v -> v | None -> (RoleStmtType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let role = match role with Some v -> v | None -> {||} in
      let options = match options with Some v -> v | None -> [] in
      { stmt_type; role; options }
    
    let to_proto =
      let apply = fun ~f:f' { stmt_type; role; options } -> f' [] stmt_type role options in
      let spec = Runtime'.Serialize.C.( basic (1, (enum RoleStmtType.to_int), proto3) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions stmt_type role options -> { stmt_type; role; options } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum RoleStmtType.from_int), proto3) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterRoleStmt : sig
    val name': unit -> string
    type t = { role: RoleSpec.t option; options: Node.t list; action: int } 
    val make : ?role:RoleSpec.t -> ?options:Node.t list -> ?action:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterRoleStmt"
    type t = { role: RoleSpec.t option; options: Node.t list; action: int }
    let make =
      fun ?role ?options ?action () -> 
      let options = match options with Some v -> v | None -> [] in
      let action = match action with Some v -> v | None -> 0 in
      { role; options; action }
    
    let to_proto =
      let apply = fun ~f:f' { role; options; action } -> f' [] role options action in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RoleSpec.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions role options action -> { role; options; action } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RoleSpec.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DropRoleStmt : sig
    val name': unit -> string
    type t = { roles: Node.t list; missing_ok: bool } 
    val make : ?roles:Node.t list -> ?missing_ok:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.DropRoleStmt"
    type t = { roles: Node.t list; missing_ok: bool }
    let make =
      fun ?roles ?missing_ok () -> 
      let roles = match roles with Some v -> v | None -> [] in
      let missing_ok = match missing_ok with Some v -> v | None -> false in
      { roles; missing_ok }
    
    let to_proto =
      let apply = fun ~f:f' { roles; missing_ok } -> f' [] roles missing_ok in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions roles missing_ok -> { roles; missing_ok } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and LockStmt : sig
    val name': unit -> string
    type t = { relations: Node.t list; mode: int; nowait: bool } 
    val make : ?relations:Node.t list -> ?mode:int -> ?nowait:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.LockStmt"
    type t = { relations: Node.t list; mode: int; nowait: bool }
    let make =
      fun ?relations ?mode ?nowait () -> 
      let relations = match relations with Some v -> v | None -> [] in
      let mode = match mode with Some v -> v | None -> 0 in
      let nowait = match nowait with Some v -> v | None -> false in
      { relations; mode; nowait }
    
    let to_proto =
      let apply = fun ~f:f' { relations; mode; nowait } -> f' [] relations mode nowait in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, int32_int, proto3) ^:: basic (3, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions relations mode nowait -> { relations; mode; nowait } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, int32_int, proto3) ^:: basic (3, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ConstraintsSetStmt : sig
    val name': unit -> string
    type t = { constraints: Node.t list; deferred: bool } 
    val make : ?constraints:Node.t list -> ?deferred:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ConstraintsSetStmt"
    type t = { constraints: Node.t list; deferred: bool }
    let make =
      fun ?constraints ?deferred () -> 
      let constraints = match constraints with Some v -> v | None -> [] in
      let deferred = match deferred with Some v -> v | None -> false in
      { constraints; deferred }
    
    let to_proto =
      let apply = fun ~f:f' { constraints; deferred } -> f' [] constraints deferred in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions constraints deferred -> { constraints; deferred } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ReindexStmt : sig
    val name': unit -> string
    type t = { kind: ReindexObjectType.t; relation: RangeVar.t option; name: string; params: Node.t list } 
    val make : ?kind:ReindexObjectType.t -> ?relation:RangeVar.t -> ?name:string -> ?params:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ReindexStmt"
    type t = { kind: ReindexObjectType.t; relation: RangeVar.t option; name: string; params: Node.t list }
    let make =
      fun ?kind ?relation ?name ?params () -> 
      let kind = match kind with Some v -> v | None -> (ReindexObjectType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let name = match name with Some v -> v | None -> {||} in
      let params = match params with Some v -> v | None -> [] in
      { kind; relation; name; params }
    
    let to_proto =
      let apply = fun ~f:f' { kind; relation; name; params } -> f' [] kind relation name params in
      let spec = Runtime'.Serialize.C.( basic (1, (enum ReindexObjectType.to_int), proto3) ^:: basic_opt (2, (message (fun t -> RangeVar.to_proto t))) ^:: basic (3, string, proto3) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions kind relation name params -> { kind; relation; name; params } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum ReindexObjectType.from_int), proto3) ^:: basic_opt (2, (message (fun t -> RangeVar.from_proto t))) ^:: basic (3, string, proto3) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CheckPointStmt : sig
    val name': unit -> string
    type t = unit 
    val make : unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CheckPointStmt"
    type t = unit
    let make =
      fun  () -> 
      
      ()
    
    let to_proto =
      let apply = fun ~f:f' () -> f' []  in
      let spec = Runtime'.Serialize.C.( nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions  -> () in
      let spec = Runtime'.Deserialize.C.( nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateSchemaStmt : sig
    val name': unit -> string
    type t = { schemaname: string; authrole: RoleSpec.t option; schema_elts: Node.t list; if_not_exists: bool } 
    val make : ?schemaname:string -> ?authrole:RoleSpec.t -> ?schema_elts:Node.t list -> ?if_not_exists:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateSchemaStmt"
    type t = { schemaname: string; authrole: RoleSpec.t option; schema_elts: Node.t list; if_not_exists: bool }
    let make =
      fun ?schemaname ?authrole ?schema_elts ?if_not_exists () -> 
      let schemaname = match schemaname with Some v -> v | None -> {||} in
      let schema_elts = match schema_elts with Some v -> v | None -> [] in
      let if_not_exists = match if_not_exists with Some v -> v | None -> false in
      { schemaname; authrole; schema_elts; if_not_exists }
    
    let to_proto =
      let apply = fun ~f:f' { schemaname; authrole; schema_elts; if_not_exists } -> f' [] schemaname authrole schema_elts if_not_exists in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> RoleSpec.to_proto t))) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (4, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions schemaname authrole schema_elts if_not_exists -> { schemaname; authrole; schema_elts; if_not_exists } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> RoleSpec.from_proto t))) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (4, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterDatabaseStmt : sig
    val name': unit -> string
    type t = { dbname: string; options: Node.t list } 
    val make : ?dbname:string -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterDatabaseStmt"
    type t = { dbname: string; options: Node.t list }
    let make =
      fun ?dbname ?options () -> 
      let dbname = match dbname with Some v -> v | None -> {||} in
      let options = match options with Some v -> v | None -> [] in
      { dbname; options }
    
    let to_proto =
      let apply = fun ~f:f' { dbname; options } -> f' [] dbname options in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions dbname options -> { dbname; options } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterDatabaseRefreshCollStmt : sig
    val name': unit -> string
    type t = string 
    val make : ?dbname:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterDatabaseRefreshCollStmt"
    type t = string
    let make =
      fun ?dbname () -> 
      let dbname = match dbname with Some v -> v | None -> {||} in
      dbname
    
    let to_proto =
      let apply = fun ~f:f' dbname -> f' [] dbname in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions dbname -> dbname in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterDatabaseSetStmt : sig
    val name': unit -> string
    type t = { dbname: string; setstmt: VariableSetStmt.t option } 
    val make : ?dbname:string -> ?setstmt:VariableSetStmt.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterDatabaseSetStmt"
    type t = { dbname: string; setstmt: VariableSetStmt.t option }
    let make =
      fun ?dbname ?setstmt () -> 
      let dbname = match dbname with Some v -> v | None -> {||} in
      { dbname; setstmt }
    
    let to_proto =
      let apply = fun ~f:f' { dbname; setstmt } -> f' [] dbname setstmt in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> VariableSetStmt.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions dbname setstmt -> { dbname; setstmt } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> VariableSetStmt.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterRoleSetStmt : sig
    val name': unit -> string
    type t = { role: RoleSpec.t option; database: string; setstmt: VariableSetStmt.t option } 
    val make : ?role:RoleSpec.t -> ?database:string -> ?setstmt:VariableSetStmt.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterRoleSetStmt"
    type t = { role: RoleSpec.t option; database: string; setstmt: VariableSetStmt.t option }
    let make =
      fun ?role ?database ?setstmt () -> 
      let database = match database with Some v -> v | None -> {||} in
      { role; database; setstmt }
    
    let to_proto =
      let apply = fun ~f:f' { role; database; setstmt } -> f' [] role database setstmt in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RoleSpec.to_proto t))) ^:: basic (2, string, proto3) ^:: basic_opt (3, (message (fun t -> VariableSetStmt.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions role database setstmt -> { role; database; setstmt } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RoleSpec.from_proto t))) ^:: basic (2, string, proto3) ^:: basic_opt (3, (message (fun t -> VariableSetStmt.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateConversionStmt : sig
    val name': unit -> string
    type t = { conversion_name: Node.t list; for_encoding_name: string; to_encoding_name: string; func_name: Node.t list; def: bool } 
    val make : ?conversion_name:Node.t list -> ?for_encoding_name:string -> ?to_encoding_name:string -> ?func_name:Node.t list -> ?def:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateConversionStmt"
    type t = { conversion_name: Node.t list; for_encoding_name: string; to_encoding_name: string; func_name: Node.t list; def: bool }
    let make =
      fun ?conversion_name ?for_encoding_name ?to_encoding_name ?func_name ?def () -> 
      let conversion_name = match conversion_name with Some v -> v | None -> [] in
      let for_encoding_name = match for_encoding_name with Some v -> v | None -> {||} in
      let to_encoding_name = match to_encoding_name with Some v -> v | None -> {||} in
      let func_name = match func_name with Some v -> v | None -> [] in
      let def = match def with Some v -> v | None -> false in
      { conversion_name; for_encoding_name; to_encoding_name; func_name; def }
    
    let to_proto =
      let apply = fun ~f:f' { conversion_name; for_encoding_name; to_encoding_name; func_name; def } -> f' [] conversion_name for_encoding_name to_encoding_name func_name def in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (5, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions conversion_name for_encoding_name to_encoding_name func_name def -> { conversion_name; for_encoding_name; to_encoding_name; func_name; def } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (5, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateCastStmt : sig
    val name': unit -> string
    type t = { sourcetype: TypeName.t option; targettype: TypeName.t option; func: ObjectWithArgs.t option; context: CoercionContext.t; inout: bool } 
    val make : ?sourcetype:TypeName.t -> ?targettype:TypeName.t -> ?func:ObjectWithArgs.t -> ?context:CoercionContext.t -> ?inout:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateCastStmt"
    type t = { sourcetype: TypeName.t option; targettype: TypeName.t option; func: ObjectWithArgs.t option; context: CoercionContext.t; inout: bool }
    let make =
      fun ?sourcetype ?targettype ?func ?context ?inout () -> 
      let context = match context with Some v -> v | None -> (CoercionContext.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let inout = match inout with Some v -> v | None -> false in
      { sourcetype; targettype; func; context; inout }
    
    let to_proto =
      let apply = fun ~f:f' { sourcetype; targettype; func; context; inout } -> f' [] sourcetype targettype func context inout in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> TypeName.to_proto t))) ^:: basic_opt (2, (message (fun t -> TypeName.to_proto t))) ^:: basic_opt (3, (message (fun t -> ObjectWithArgs.to_proto t))) ^:: basic (4, (enum CoercionContext.to_int), proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions sourcetype targettype func context inout -> { sourcetype; targettype; func; context; inout } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> TypeName.from_proto t))) ^:: basic_opt (2, (message (fun t -> TypeName.from_proto t))) ^:: basic_opt (3, (message (fun t -> ObjectWithArgs.from_proto t))) ^:: basic (4, (enum CoercionContext.from_int), proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateOpClassStmt : sig
    val name': unit -> string
    type t = { opclassname: Node.t list; opfamilyname: Node.t list; amname: string; datatype: TypeName.t option; items: Node.t list; is_default: bool } 
    val make : ?opclassname:Node.t list -> ?opfamilyname:Node.t list -> ?amname:string -> ?datatype:TypeName.t -> ?items:Node.t list -> ?is_default:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateOpClassStmt"
    type t = { opclassname: Node.t list; opfamilyname: Node.t list; amname: string; datatype: TypeName.t option; items: Node.t list; is_default: bool }
    let make =
      fun ?opclassname ?opfamilyname ?amname ?datatype ?items ?is_default () -> 
      let opclassname = match opclassname with Some v -> v | None -> [] in
      let opfamilyname = match opfamilyname with Some v -> v | None -> [] in
      let amname = match amname with Some v -> v | None -> {||} in
      let items = match items with Some v -> v | None -> [] in
      let is_default = match is_default with Some v -> v | None -> false in
      { opclassname; opfamilyname; amname; datatype; items; is_default }
    
    let to_proto =
      let apply = fun ~f:f' { opclassname; opfamilyname; amname; datatype; items; is_default } -> f' [] opclassname opfamilyname amname datatype items is_default in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, string, proto3) ^:: basic_opt (4, (message (fun t -> TypeName.to_proto t))) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (6, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions opclassname opfamilyname amname datatype items is_default -> { opclassname; opfamilyname; amname; datatype; items; is_default } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, string, proto3) ^:: basic_opt (4, (message (fun t -> TypeName.from_proto t))) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (6, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateOpFamilyStmt : sig
    val name': unit -> string
    type t = { opfamilyname: Node.t list; amname: string } 
    val make : ?opfamilyname:Node.t list -> ?amname:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateOpFamilyStmt"
    type t = { opfamilyname: Node.t list; amname: string }
    let make =
      fun ?opfamilyname ?amname () -> 
      let opfamilyname = match opfamilyname with Some v -> v | None -> [] in
      let amname = match amname with Some v -> v | None -> {||} in
      { opfamilyname; amname }
    
    let to_proto =
      let apply = fun ~f:f' { opfamilyname; amname } -> f' [] opfamilyname amname in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions opfamilyname amname -> { opfamilyname; amname } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterOpFamilyStmt : sig
    val name': unit -> string
    type t = { opfamilyname: Node.t list; amname: string; is_drop: bool; items: Node.t list } 
    val make : ?opfamilyname:Node.t list -> ?amname:string -> ?is_drop:bool -> ?items:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterOpFamilyStmt"
    type t = { opfamilyname: Node.t list; amname: string; is_drop: bool; items: Node.t list }
    let make =
      fun ?opfamilyname ?amname ?is_drop ?items () -> 
      let opfamilyname = match opfamilyname with Some v -> v | None -> [] in
      let amname = match amname with Some v -> v | None -> {||} in
      let is_drop = match is_drop with Some v -> v | None -> false in
      let items = match items with Some v -> v | None -> [] in
      { opfamilyname; amname; is_drop; items }
    
    let to_proto =
      let apply = fun ~f:f' { opfamilyname; amname; is_drop; items } -> f' [] opfamilyname amname is_drop items in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, string, proto3) ^:: basic (3, bool, proto3) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions opfamilyname amname is_drop items -> { opfamilyname; amname; is_drop; items } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, string, proto3) ^:: basic (3, bool, proto3) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PrepareStmt : sig
    val name': unit -> string
    type t = { name: string; argtypes: Node.t list; query: Node.t option } 
    val make : ?name:string -> ?argtypes:Node.t list -> ?query:Node.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.PrepareStmt"
    type t = { name: string; argtypes: Node.t list; query: Node.t option }
    let make =
      fun ?name ?argtypes ?query () -> 
      let name = match name with Some v -> v | None -> {||} in
      let argtypes = match argtypes with Some v -> v | None -> [] in
      { name; argtypes; query }
    
    let to_proto =
      let apply = fun ~f:f' { name; argtypes; query } -> f' [] name argtypes query in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name argtypes query -> { name; argtypes; query } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ExecuteStmt : sig
    val name': unit -> string
    type t = { name: string; params: Node.t list } 
    val make : ?name:string -> ?params:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ExecuteStmt"
    type t = { name: string; params: Node.t list }
    let make =
      fun ?name ?params () -> 
      let name = match name with Some v -> v | None -> {||} in
      let params = match params with Some v -> v | None -> [] in
      { name; params }
    
    let to_proto =
      let apply = fun ~f:f' { name; params } -> f' [] name params in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name params -> { name; params } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DeallocateStmt : sig
    val name': unit -> string
    type t = string 
    val make : ?name:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.DeallocateStmt"
    type t = string
    let make =
      fun ?name () -> 
      let name = match name with Some v -> v | None -> {||} in
      name
    
    let to_proto =
      let apply = fun ~f:f' name -> f' [] name in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name -> name in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DeclareCursorStmt : sig
    val name': unit -> string
    type t = { portalname: string; options: int; query: Node.t option } 
    val make : ?portalname:string -> ?options:int -> ?query:Node.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.DeclareCursorStmt"
    type t = { portalname: string; options: int; query: Node.t option }
    let make =
      fun ?portalname ?options ?query () -> 
      let portalname = match portalname with Some v -> v | None -> {||} in
      let options = match options with Some v -> v | None -> 0 in
      { portalname; options; query }
    
    let to_proto =
      let apply = fun ~f:f' { portalname; options; query } -> f' [] portalname options query in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, int32_int, proto3) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions portalname options query -> { portalname; options; query } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, int32_int, proto3) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateTableSpaceStmt : sig
    val name': unit -> string
    type t = { tablespacename: string; owner: RoleSpec.t option; location: string; options: Node.t list } 
    val make : ?tablespacename:string -> ?owner:RoleSpec.t -> ?location:string -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateTableSpaceStmt"
    type t = { tablespacename: string; owner: RoleSpec.t option; location: string; options: Node.t list }
    let make =
      fun ?tablespacename ?owner ?location ?options () -> 
      let tablespacename = match tablespacename with Some v -> v | None -> {||} in
      let location = match location with Some v -> v | None -> {||} in
      let options = match options with Some v -> v | None -> [] in
      { tablespacename; owner; location; options }
    
    let to_proto =
      let apply = fun ~f:f' { tablespacename; owner; location; options } -> f' [] tablespacename owner location options in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> RoleSpec.to_proto t))) ^:: basic (3, string, proto3) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions tablespacename owner location options -> { tablespacename; owner; location; options } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> RoleSpec.from_proto t))) ^:: basic (3, string, proto3) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DropTableSpaceStmt : sig
    val name': unit -> string
    type t = { tablespacename: string; missing_ok: bool } 
    val make : ?tablespacename:string -> ?missing_ok:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.DropTableSpaceStmt"
    type t = { tablespacename: string; missing_ok: bool }
    let make =
      fun ?tablespacename ?missing_ok () -> 
      let tablespacename = match tablespacename with Some v -> v | None -> {||} in
      let missing_ok = match missing_ok with Some v -> v | None -> false in
      { tablespacename; missing_ok }
    
    let to_proto =
      let apply = fun ~f:f' { tablespacename; missing_ok } -> f' [] tablespacename missing_ok in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions tablespacename missing_ok -> { tablespacename; missing_ok } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterObjectDependsStmt : sig
    val name': unit -> string
    type t = { object_type: ObjectType.t; relation: RangeVar.t option; object': Node.t option; extname: String.t option; remove: bool } 
    val make : ?object_type:ObjectType.t -> ?relation:RangeVar.t -> ?object':Node.t -> ?extname:String.t -> ?remove:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterObjectDependsStmt"
    type t = { object_type: ObjectType.t; relation: RangeVar.t option; object': Node.t option; extname: String.t option; remove: bool }
    let make =
      fun ?object_type ?relation ?object' ?extname ?remove () -> 
      let object_type = match object_type with Some v -> v | None -> (ObjectType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let remove = match remove with Some v -> v | None -> false in
      { object_type; relation; object'; extname; remove }
    
    let to_proto =
      let apply = fun ~f:f' { object_type; relation; object'; extname; remove } -> f' [] object_type relation object' extname remove in
      let spec = Runtime'.Serialize.C.( basic (1, (enum ObjectType.to_int), proto3) ^:: basic_opt (2, (message (fun t -> RangeVar.to_proto t))) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: basic_opt (4, (message (fun t -> String.to_proto t))) ^:: basic (5, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions object_type relation object' extname remove -> { object_type; relation; object'; extname; remove } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum ObjectType.from_int), proto3) ^:: basic_opt (2, (message (fun t -> RangeVar.from_proto t))) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: basic_opt (4, (message (fun t -> String.from_proto t))) ^:: basic (5, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterObjectSchemaStmt : sig
    val name': unit -> string
    type t = { object_type: ObjectType.t; relation: RangeVar.t option; object': Node.t option; newschema: string; missing_ok: bool } 
    val make : ?object_type:ObjectType.t -> ?relation:RangeVar.t -> ?object':Node.t -> ?newschema:string -> ?missing_ok:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterObjectSchemaStmt"
    type t = { object_type: ObjectType.t; relation: RangeVar.t option; object': Node.t option; newschema: string; missing_ok: bool }
    let make =
      fun ?object_type ?relation ?object' ?newschema ?missing_ok () -> 
      let object_type = match object_type with Some v -> v | None -> (ObjectType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let newschema = match newschema with Some v -> v | None -> {||} in
      let missing_ok = match missing_ok with Some v -> v | None -> false in
      { object_type; relation; object'; newschema; missing_ok }
    
    let to_proto =
      let apply = fun ~f:f' { object_type; relation; object'; newschema; missing_ok } -> f' [] object_type relation object' newschema missing_ok in
      let spec = Runtime'.Serialize.C.( basic (1, (enum ObjectType.to_int), proto3) ^:: basic_opt (2, (message (fun t -> RangeVar.to_proto t))) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: basic (4, string, proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions object_type relation object' newschema missing_ok -> { object_type; relation; object'; newschema; missing_ok } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum ObjectType.from_int), proto3) ^:: basic_opt (2, (message (fun t -> RangeVar.from_proto t))) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: basic (4, string, proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterOwnerStmt : sig
    val name': unit -> string
    type t = { object_type: ObjectType.t; relation: RangeVar.t option; object': Node.t option; newowner: RoleSpec.t option } 
    val make : ?object_type:ObjectType.t -> ?relation:RangeVar.t -> ?object':Node.t -> ?newowner:RoleSpec.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterOwnerStmt"
    type t = { object_type: ObjectType.t; relation: RangeVar.t option; object': Node.t option; newowner: RoleSpec.t option }
    let make =
      fun ?object_type ?relation ?object' ?newowner () -> 
      let object_type = match object_type with Some v -> v | None -> (ObjectType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { object_type; relation; object'; newowner }
    
    let to_proto =
      let apply = fun ~f:f' { object_type; relation; object'; newowner } -> f' [] object_type relation object' newowner in
      let spec = Runtime'.Serialize.C.( basic (1, (enum ObjectType.to_int), proto3) ^:: basic_opt (2, (message (fun t -> RangeVar.to_proto t))) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: basic_opt (4, (message (fun t -> RoleSpec.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions object_type relation object' newowner -> { object_type; relation; object'; newowner } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum ObjectType.from_int), proto3) ^:: basic_opt (2, (message (fun t -> RangeVar.from_proto t))) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: basic_opt (4, (message (fun t -> RoleSpec.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterOperatorStmt : sig
    val name': unit -> string
    type t = { opername: ObjectWithArgs.t option; options: Node.t list } 
    val make : ?opername:ObjectWithArgs.t -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterOperatorStmt"
    type t = { opername: ObjectWithArgs.t option; options: Node.t list }
    let make =
      fun ?opername ?options () -> 
      let options = match options with Some v -> v | None -> [] in
      { opername; options }
    
    let to_proto =
      let apply = fun ~f:f' { opername; options } -> f' [] opername options in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> ObjectWithArgs.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions opername options -> { opername; options } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> ObjectWithArgs.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterTypeStmt : sig
    val name': unit -> string
    type t = { type_name: Node.t list; options: Node.t list } 
    val make : ?type_name:Node.t list -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterTypeStmt"
    type t = { type_name: Node.t list; options: Node.t list }
    let make =
      fun ?type_name ?options () -> 
      let type_name = match type_name with Some v -> v | None -> [] in
      let options = match options with Some v -> v | None -> [] in
      { type_name; options }
    
    let to_proto =
      let apply = fun ~f:f' { type_name; options } -> f' [] type_name options in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions type_name options -> { type_name; options } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DropOwnedStmt : sig
    val name': unit -> string
    type t = { roles: Node.t list; behavior: DropBehavior.t } 
    val make : ?roles:Node.t list -> ?behavior:DropBehavior.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.DropOwnedStmt"
    type t = { roles: Node.t list; behavior: DropBehavior.t }
    let make =
      fun ?roles ?behavior () -> 
      let roles = match roles with Some v -> v | None -> [] in
      let behavior = match behavior with Some v -> v | None -> (DropBehavior.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { roles; behavior }
    
    let to_proto =
      let apply = fun ~f:f' { roles; behavior } -> f' [] roles behavior in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, (enum DropBehavior.to_int), proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions roles behavior -> { roles; behavior } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, (enum DropBehavior.from_int), proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ReassignOwnedStmt : sig
    val name': unit -> string
    type t = { roles: Node.t list; newrole: RoleSpec.t option } 
    val make : ?roles:Node.t list -> ?newrole:RoleSpec.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ReassignOwnedStmt"
    type t = { roles: Node.t list; newrole: RoleSpec.t option }
    let make =
      fun ?roles ?newrole () -> 
      let roles = match roles with Some v -> v | None -> [] in
      { roles; newrole }
    
    let to_proto =
      let apply = fun ~f:f' { roles; newrole } -> f' [] roles newrole in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (2, (message (fun t -> RoleSpec.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions roles newrole -> { roles; newrole } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (2, (message (fun t -> RoleSpec.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CompositeTypeStmt : sig
    val name': unit -> string
    type t = { typevar: RangeVar.t option; coldeflist: Node.t list } 
    val make : ?typevar:RangeVar.t -> ?coldeflist:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CompositeTypeStmt"
    type t = { typevar: RangeVar.t option; coldeflist: Node.t list }
    let make =
      fun ?typevar ?coldeflist () -> 
      let coldeflist = match coldeflist with Some v -> v | None -> [] in
      { typevar; coldeflist }
    
    let to_proto =
      let apply = fun ~f:f' { typevar; coldeflist } -> f' [] typevar coldeflist in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions typevar coldeflist -> { typevar; coldeflist } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateEnumStmt : sig
    val name': unit -> string
    type t = { type_name: Node.t list; vals: Node.t list } 
    val make : ?type_name:Node.t list -> ?vals:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateEnumStmt"
    type t = { type_name: Node.t list; vals: Node.t list }
    let make =
      fun ?type_name ?vals () -> 
      let type_name = match type_name with Some v -> v | None -> [] in
      let vals = match vals with Some v -> v | None -> [] in
      { type_name; vals }
    
    let to_proto =
      let apply = fun ~f:f' { type_name; vals } -> f' [] type_name vals in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions type_name vals -> { type_name; vals } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateRangeStmt : sig
    val name': unit -> string
    type t = { type_name: Node.t list; params: Node.t list } 
    val make : ?type_name:Node.t list -> ?params:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateRangeStmt"
    type t = { type_name: Node.t list; params: Node.t list }
    let make =
      fun ?type_name ?params () -> 
      let type_name = match type_name with Some v -> v | None -> [] in
      let params = match params with Some v -> v | None -> [] in
      { type_name; params }
    
    let to_proto =
      let apply = fun ~f:f' { type_name; params } -> f' [] type_name params in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions type_name params -> { type_name; params } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterEnumStmt : sig
    val name': unit -> string
    type t = { type_name: Node.t list; old_val: string; new_val: string; new_val_neighbor: string; new_val_is_after: bool; skip_if_new_val_exists: bool } 
    val make : ?type_name:Node.t list -> ?old_val:string -> ?new_val:string -> ?new_val_neighbor:string -> ?new_val_is_after:bool -> ?skip_if_new_val_exists:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterEnumStmt"
    type t = { type_name: Node.t list; old_val: string; new_val: string; new_val_neighbor: string; new_val_is_after: bool; skip_if_new_val_exists: bool }
    let make =
      fun ?type_name ?old_val ?new_val ?new_val_neighbor ?new_val_is_after ?skip_if_new_val_exists () -> 
      let type_name = match type_name with Some v -> v | None -> [] in
      let old_val = match old_val with Some v -> v | None -> {||} in
      let new_val = match new_val with Some v -> v | None -> {||} in
      let new_val_neighbor = match new_val_neighbor with Some v -> v | None -> {||} in
      let new_val_is_after = match new_val_is_after with Some v -> v | None -> false in
      let skip_if_new_val_exists = match skip_if_new_val_exists with Some v -> v | None -> false in
      { type_name; old_val; new_val; new_val_neighbor; new_val_is_after; skip_if_new_val_exists }
    
    let to_proto =
      let apply = fun ~f:f' { type_name; old_val; new_val; new_val_neighbor; new_val_is_after; skip_if_new_val_exists } -> f' [] type_name old_val new_val new_val_neighbor new_val_is_after skip_if_new_val_exists in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: basic (4, string, proto3) ^:: basic (5, bool, proto3) ^:: basic (6, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions type_name old_val new_val new_val_neighbor new_val_is_after skip_if_new_val_exists -> { type_name; old_val; new_val; new_val_neighbor; new_val_is_after; skip_if_new_val_exists } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: basic (4, string, proto3) ^:: basic (5, bool, proto3) ^:: basic (6, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterTSDictionaryStmt : sig
    val name': unit -> string
    type t = { dictname: Node.t list; options: Node.t list } 
    val make : ?dictname:Node.t list -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterTSDictionaryStmt"
    type t = { dictname: Node.t list; options: Node.t list }
    let make =
      fun ?dictname ?options () -> 
      let dictname = match dictname with Some v -> v | None -> [] in
      let options = match options with Some v -> v | None -> [] in
      { dictname; options }
    
    let to_proto =
      let apply = fun ~f:f' { dictname; options } -> f' [] dictname options in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions dictname options -> { dictname; options } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterTSConfigurationStmt : sig
    val name': unit -> string
    type t = { kind: AlterTSConfigType.t; cfgname: Node.t list; tokentype: Node.t list; dicts: Node.t list; override: bool; replace: bool; missing_ok: bool } 
    val make : ?kind:AlterTSConfigType.t -> ?cfgname:Node.t list -> ?tokentype:Node.t list -> ?dicts:Node.t list -> ?override:bool -> ?replace:bool -> ?missing_ok:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterTSConfigurationStmt"
    type t = { kind: AlterTSConfigType.t; cfgname: Node.t list; tokentype: Node.t list; dicts: Node.t list; override: bool; replace: bool; missing_ok: bool }
    let make =
      fun ?kind ?cfgname ?tokentype ?dicts ?override ?replace ?missing_ok () -> 
      let kind = match kind with Some v -> v | None -> (AlterTSConfigType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let cfgname = match cfgname with Some v -> v | None -> [] in
      let tokentype = match tokentype with Some v -> v | None -> [] in
      let dicts = match dicts with Some v -> v | None -> [] in
      let override = match override with Some v -> v | None -> false in
      let replace = match replace with Some v -> v | None -> false in
      let missing_ok = match missing_ok with Some v -> v | None -> false in
      { kind; cfgname; tokentype; dicts; override; replace; missing_ok }
    
    let to_proto =
      let apply = fun ~f:f' { kind; cfgname; tokentype; dicts; override; replace; missing_ok } -> f' [] kind cfgname tokentype dicts override replace missing_ok in
      let spec = Runtime'.Serialize.C.( basic (1, (enum AlterTSConfigType.to_int), proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (5, bool, proto3) ^:: basic (6, bool, proto3) ^:: basic (7, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions kind cfgname tokentype dicts override replace missing_ok -> { kind; cfgname; tokentype; dicts; override; replace; missing_ok } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum AlterTSConfigType.from_int), proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (5, bool, proto3) ^:: basic (6, bool, proto3) ^:: basic (7, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateFdwStmt : sig
    val name': unit -> string
    type t = { fdwname: string; func_options: Node.t list; options: Node.t list } 
    val make : ?fdwname:string -> ?func_options:Node.t list -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateFdwStmt"
    type t = { fdwname: string; func_options: Node.t list; options: Node.t list }
    let make =
      fun ?fdwname ?func_options ?options () -> 
      let fdwname = match fdwname with Some v -> v | None -> {||} in
      let func_options = match func_options with Some v -> v | None -> [] in
      let options = match options with Some v -> v | None -> [] in
      { fdwname; func_options; options }
    
    let to_proto =
      let apply = fun ~f:f' { fdwname; func_options; options } -> f' [] fdwname func_options options in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions fdwname func_options options -> { fdwname; func_options; options } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterFdwStmt : sig
    val name': unit -> string
    type t = { fdwname: string; func_options: Node.t list; options: Node.t list } 
    val make : ?fdwname:string -> ?func_options:Node.t list -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterFdwStmt"
    type t = { fdwname: string; func_options: Node.t list; options: Node.t list }
    let make =
      fun ?fdwname ?func_options ?options () -> 
      let fdwname = match fdwname with Some v -> v | None -> {||} in
      let func_options = match func_options with Some v -> v | None -> [] in
      let options = match options with Some v -> v | None -> [] in
      { fdwname; func_options; options }
    
    let to_proto =
      let apply = fun ~f:f' { fdwname; func_options; options } -> f' [] fdwname func_options options in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions fdwname func_options options -> { fdwname; func_options; options } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateForeignServerStmt : sig
    val name': unit -> string
    type t = { servername: string; servertype: string; version: string; fdwname: string; if_not_exists: bool; options: Node.t list } 
    val make : ?servername:string -> ?servertype:string -> ?version:string -> ?fdwname:string -> ?if_not_exists:bool -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateForeignServerStmt"
    type t = { servername: string; servertype: string; version: string; fdwname: string; if_not_exists: bool; options: Node.t list }
    let make =
      fun ?servername ?servertype ?version ?fdwname ?if_not_exists ?options () -> 
      let servername = match servername with Some v -> v | None -> {||} in
      let servertype = match servertype with Some v -> v | None -> {||} in
      let version = match version with Some v -> v | None -> {||} in
      let fdwname = match fdwname with Some v -> v | None -> {||} in
      let if_not_exists = match if_not_exists with Some v -> v | None -> false in
      let options = match options with Some v -> v | None -> [] in
      { servername; servertype; version; fdwname; if_not_exists; options }
    
    let to_proto =
      let apply = fun ~f:f' { servername; servertype; version; fdwname; if_not_exists; options } -> f' [] servername servertype version fdwname if_not_exists options in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: basic (4, string, proto3) ^:: basic (5, bool, proto3) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions servername servertype version fdwname if_not_exists options -> { servername; servertype; version; fdwname; if_not_exists; options } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: basic (4, string, proto3) ^:: basic (5, bool, proto3) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterForeignServerStmt : sig
    val name': unit -> string
    type t = { servername: string; version: string; options: Node.t list; has_version: bool } 
    val make : ?servername:string -> ?version:string -> ?options:Node.t list -> ?has_version:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterForeignServerStmt"
    type t = { servername: string; version: string; options: Node.t list; has_version: bool }
    let make =
      fun ?servername ?version ?options ?has_version () -> 
      let servername = match servername with Some v -> v | None -> {||} in
      let version = match version with Some v -> v | None -> {||} in
      let options = match options with Some v -> v | None -> [] in
      let has_version = match has_version with Some v -> v | None -> false in
      { servername; version; options; has_version }
    
    let to_proto =
      let apply = fun ~f:f' { servername; version; options; has_version } -> f' [] servername version options has_version in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (4, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions servername version options has_version -> { servername; version; options; has_version } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (4, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateUserMappingStmt : sig
    val name': unit -> string
    type t = { user: RoleSpec.t option; servername: string; if_not_exists: bool; options: Node.t list } 
    val make : ?user:RoleSpec.t -> ?servername:string -> ?if_not_exists:bool -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateUserMappingStmt"
    type t = { user: RoleSpec.t option; servername: string; if_not_exists: bool; options: Node.t list }
    let make =
      fun ?user ?servername ?if_not_exists ?options () -> 
      let servername = match servername with Some v -> v | None -> {||} in
      let if_not_exists = match if_not_exists with Some v -> v | None -> false in
      let options = match options with Some v -> v | None -> [] in
      { user; servername; if_not_exists; options }
    
    let to_proto =
      let apply = fun ~f:f' { user; servername; if_not_exists; options } -> f' [] user servername if_not_exists options in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RoleSpec.to_proto t))) ^:: basic (2, string, proto3) ^:: basic (3, bool, proto3) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions user servername if_not_exists options -> { user; servername; if_not_exists; options } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RoleSpec.from_proto t))) ^:: basic (2, string, proto3) ^:: basic (3, bool, proto3) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterUserMappingStmt : sig
    val name': unit -> string
    type t = { user: RoleSpec.t option; servername: string; options: Node.t list } 
    val make : ?user:RoleSpec.t -> ?servername:string -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterUserMappingStmt"
    type t = { user: RoleSpec.t option; servername: string; options: Node.t list }
    let make =
      fun ?user ?servername ?options () -> 
      let servername = match servername with Some v -> v | None -> {||} in
      let options = match options with Some v -> v | None -> [] in
      { user; servername; options }
    
    let to_proto =
      let apply = fun ~f:f' { user; servername; options } -> f' [] user servername options in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RoleSpec.to_proto t))) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions user servername options -> { user; servername; options } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RoleSpec.from_proto t))) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DropUserMappingStmt : sig
    val name': unit -> string
    type t = { user: RoleSpec.t option; servername: string; missing_ok: bool } 
    val make : ?user:RoleSpec.t -> ?servername:string -> ?missing_ok:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.DropUserMappingStmt"
    type t = { user: RoleSpec.t option; servername: string; missing_ok: bool }
    let make =
      fun ?user ?servername ?missing_ok () -> 
      let servername = match servername with Some v -> v | None -> {||} in
      let missing_ok = match missing_ok with Some v -> v | None -> false in
      { user; servername; missing_ok }
    
    let to_proto =
      let apply = fun ~f:f' { user; servername; missing_ok } -> f' [] user servername missing_ok in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RoleSpec.to_proto t))) ^:: basic (2, string, proto3) ^:: basic (3, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions user servername missing_ok -> { user; servername; missing_ok } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RoleSpec.from_proto t))) ^:: basic (2, string, proto3) ^:: basic (3, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterTableSpaceOptionsStmt : sig
    val name': unit -> string
    type t = { tablespacename: string; options: Node.t list; is_reset: bool } 
    val make : ?tablespacename:string -> ?options:Node.t list -> ?is_reset:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterTableSpaceOptionsStmt"
    type t = { tablespacename: string; options: Node.t list; is_reset: bool }
    let make =
      fun ?tablespacename ?options ?is_reset () -> 
      let tablespacename = match tablespacename with Some v -> v | None -> {||} in
      let options = match options with Some v -> v | None -> [] in
      let is_reset = match is_reset with Some v -> v | None -> false in
      { tablespacename; options; is_reset }
    
    let to_proto =
      let apply = fun ~f:f' { tablespacename; options; is_reset } -> f' [] tablespacename options is_reset in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions tablespacename options is_reset -> { tablespacename; options; is_reset } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterTableMoveAllStmt : sig
    val name': unit -> string
    type t = { orig_tablespacename: string; objtype: ObjectType.t; roles: Node.t list; new_tablespacename: string; nowait: bool } 
    val make : ?orig_tablespacename:string -> ?objtype:ObjectType.t -> ?roles:Node.t list -> ?new_tablespacename:string -> ?nowait:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterTableMoveAllStmt"
    type t = { orig_tablespacename: string; objtype: ObjectType.t; roles: Node.t list; new_tablespacename: string; nowait: bool }
    let make =
      fun ?orig_tablespacename ?objtype ?roles ?new_tablespacename ?nowait () -> 
      let orig_tablespacename = match orig_tablespacename with Some v -> v | None -> {||} in
      let objtype = match objtype with Some v -> v | None -> (ObjectType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let roles = match roles with Some v -> v | None -> [] in
      let new_tablespacename = match new_tablespacename with Some v -> v | None -> {||} in
      let nowait = match nowait with Some v -> v | None -> false in
      { orig_tablespacename; objtype; roles; new_tablespacename; nowait }
    
    let to_proto =
      let apply = fun ~f:f' { orig_tablespacename; objtype; roles; new_tablespacename; nowait } -> f' [] orig_tablespacename objtype roles new_tablespacename nowait in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, (enum ObjectType.to_int), proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (4, string, proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions orig_tablespacename objtype roles new_tablespacename nowait -> { orig_tablespacename; objtype; roles; new_tablespacename; nowait } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, (enum ObjectType.from_int), proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (4, string, proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SecLabelStmt : sig
    val name': unit -> string
    type t = { objtype: ObjectType.t; object': Node.t option; provider: string; label: string } 
    val make : ?objtype:ObjectType.t -> ?object':Node.t -> ?provider:string -> ?label:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.SecLabelStmt"
    type t = { objtype: ObjectType.t; object': Node.t option; provider: string; label: string }
    let make =
      fun ?objtype ?object' ?provider ?label () -> 
      let objtype = match objtype with Some v -> v | None -> (ObjectType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let provider = match provider with Some v -> v | None -> {||} in
      let label = match label with Some v -> v | None -> {||} in
      { objtype; object'; provider; label }
    
    let to_proto =
      let apply = fun ~f:f' { objtype; object'; provider; label } -> f' [] objtype object' provider label in
      let spec = Runtime'.Serialize.C.( basic (1, (enum ObjectType.to_int), proto3) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic (3, string, proto3) ^:: basic (4, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions objtype object' provider label -> { objtype; object'; provider; label } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum ObjectType.from_int), proto3) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic (3, string, proto3) ^:: basic (4, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateForeignTableStmt : sig
    val name': unit -> string
    type t = { base_stmt: CreateStmt.t option; servername: string; options: Node.t list } 
    val make : ?base_stmt:CreateStmt.t -> ?servername:string -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateForeignTableStmt"
    type t = { base_stmt: CreateStmt.t option; servername: string; options: Node.t list }
    let make =
      fun ?base_stmt ?servername ?options () -> 
      let servername = match servername with Some v -> v | None -> {||} in
      let options = match options with Some v -> v | None -> [] in
      { base_stmt; servername; options }
    
    let to_proto =
      let apply = fun ~f:f' { base_stmt; servername; options } -> f' [] base_stmt servername options in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> CreateStmt.to_proto t))) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions base_stmt servername options -> { base_stmt; servername; options } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> CreateStmt.from_proto t))) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ImportForeignSchemaStmt : sig
    val name': unit -> string
    type t = { server_name: string; remote_schema: string; local_schema: string; list_type: ImportForeignSchemaType.t; table_list: Node.t list; options: Node.t list } 
    val make : ?server_name:string -> ?remote_schema:string -> ?local_schema:string -> ?list_type:ImportForeignSchemaType.t -> ?table_list:Node.t list -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ImportForeignSchemaStmt"
    type t = { server_name: string; remote_schema: string; local_schema: string; list_type: ImportForeignSchemaType.t; table_list: Node.t list; options: Node.t list }
    let make =
      fun ?server_name ?remote_schema ?local_schema ?list_type ?table_list ?options () -> 
      let server_name = match server_name with Some v -> v | None -> {||} in
      let remote_schema = match remote_schema with Some v -> v | None -> {||} in
      let local_schema = match local_schema with Some v -> v | None -> {||} in
      let list_type = match list_type with Some v -> v | None -> (ImportForeignSchemaType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let table_list = match table_list with Some v -> v | None -> [] in
      let options = match options with Some v -> v | None -> [] in
      { server_name; remote_schema; local_schema; list_type; table_list; options }
    
    let to_proto =
      let apply = fun ~f:f' { server_name; remote_schema; local_schema; list_type; table_list; options } -> f' [] server_name remote_schema local_schema list_type table_list options in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: basic (4, (enum ImportForeignSchemaType.to_int), proto3) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions server_name remote_schema local_schema list_type table_list options -> { server_name; remote_schema; local_schema; list_type; table_list; options } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: basic (4, (enum ImportForeignSchemaType.from_int), proto3) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateExtensionStmt : sig
    val name': unit -> string
    type t = { extname: string; if_not_exists: bool; options: Node.t list } 
    val make : ?extname:string -> ?if_not_exists:bool -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateExtensionStmt"
    type t = { extname: string; if_not_exists: bool; options: Node.t list }
    let make =
      fun ?extname ?if_not_exists ?options () -> 
      let extname = match extname with Some v -> v | None -> {||} in
      let if_not_exists = match if_not_exists with Some v -> v | None -> false in
      let options = match options with Some v -> v | None -> [] in
      { extname; if_not_exists; options }
    
    let to_proto =
      let apply = fun ~f:f' { extname; if_not_exists; options } -> f' [] extname if_not_exists options in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions extname if_not_exists options -> { extname; if_not_exists; options } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterExtensionStmt : sig
    val name': unit -> string
    type t = { extname: string; options: Node.t list } 
    val make : ?extname:string -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterExtensionStmt"
    type t = { extname: string; options: Node.t list }
    let make =
      fun ?extname ?options () -> 
      let extname = match extname with Some v -> v | None -> {||} in
      let options = match options with Some v -> v | None -> [] in
      { extname; options }
    
    let to_proto =
      let apply = fun ~f:f' { extname; options } -> f' [] extname options in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions extname options -> { extname; options } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterExtensionContentsStmt : sig
    val name': unit -> string
    type t = { extname: string; action: int; objtype: ObjectType.t; object': Node.t option } 
    val make : ?extname:string -> ?action:int -> ?objtype:ObjectType.t -> ?object':Node.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterExtensionContentsStmt"
    type t = { extname: string; action: int; objtype: ObjectType.t; object': Node.t option }
    let make =
      fun ?extname ?action ?objtype ?object' () -> 
      let extname = match extname with Some v -> v | None -> {||} in
      let action = match action with Some v -> v | None -> 0 in
      let objtype = match objtype with Some v -> v | None -> (ObjectType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { extname; action; objtype; object' }
    
    let to_proto =
      let apply = fun ~f:f' { extname; action; objtype; object' } -> f' [] extname action objtype object' in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, int32_int, proto3) ^:: basic (3, (enum ObjectType.to_int), proto3) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions extname action objtype object' -> { extname; action; objtype; object' } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, int32_int, proto3) ^:: basic (3, (enum ObjectType.from_int), proto3) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateEventTrigStmt : sig
    val name': unit -> string
    type t = { trigname: string; eventname: string; whenclause: Node.t list; funcname: Node.t list } 
    val make : ?trigname:string -> ?eventname:string -> ?whenclause:Node.t list -> ?funcname:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateEventTrigStmt"
    type t = { trigname: string; eventname: string; whenclause: Node.t list; funcname: Node.t list }
    let make =
      fun ?trigname ?eventname ?whenclause ?funcname () -> 
      let trigname = match trigname with Some v -> v | None -> {||} in
      let eventname = match eventname with Some v -> v | None -> {||} in
      let whenclause = match whenclause with Some v -> v | None -> [] in
      let funcname = match funcname with Some v -> v | None -> [] in
      { trigname; eventname; whenclause; funcname }
    
    let to_proto =
      let apply = fun ~f:f' { trigname; eventname; whenclause; funcname } -> f' [] trigname eventname whenclause funcname in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions trigname eventname whenclause funcname -> { trigname; eventname; whenclause; funcname } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterEventTrigStmt : sig
    val name': unit -> string
    type t = { trigname: string; tgenabled: string } 
    val make : ?trigname:string -> ?tgenabled:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterEventTrigStmt"
    type t = { trigname: string; tgenabled: string }
    let make =
      fun ?trigname ?tgenabled () -> 
      let trigname = match trigname with Some v -> v | None -> {||} in
      let tgenabled = match tgenabled with Some v -> v | None -> {||} in
      { trigname; tgenabled }
    
    let to_proto =
      let apply = fun ~f:f' { trigname; tgenabled } -> f' [] trigname tgenabled in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions trigname tgenabled -> { trigname; tgenabled } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RefreshMatViewStmt : sig
    val name': unit -> string
    type t = { concurrent: bool; skip_data: bool; relation: RangeVar.t option } 
    val make : ?concurrent:bool -> ?skip_data:bool -> ?relation:RangeVar.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RefreshMatViewStmt"
    type t = { concurrent: bool; skip_data: bool; relation: RangeVar.t option }
    let make =
      fun ?concurrent ?skip_data ?relation () -> 
      let concurrent = match concurrent with Some v -> v | None -> false in
      let skip_data = match skip_data with Some v -> v | None -> false in
      { concurrent; skip_data; relation }
    
    let to_proto =
      let apply = fun ~f:f' { concurrent; skip_data; relation } -> f' [] concurrent skip_data relation in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic (2, bool, proto3) ^:: basic_opt (3, (message (fun t -> RangeVar.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions concurrent skip_data relation -> { concurrent; skip_data; relation } in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic (2, bool, proto3) ^:: basic_opt (3, (message (fun t -> RangeVar.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ReplicaIdentityStmt : sig
    val name': unit -> string
    type t = { identity_type: string; name: string } 
    val make : ?identity_type:string -> ?name:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ReplicaIdentityStmt"
    type t = { identity_type: string; name: string }
    let make =
      fun ?identity_type ?name () -> 
      let identity_type = match identity_type with Some v -> v | None -> {||} in
      let name = match name with Some v -> v | None -> {||} in
      { identity_type; name }
    
    let to_proto =
      let apply = fun ~f:f' { identity_type; name } -> f' [] identity_type name in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions identity_type name -> { identity_type; name } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterSystemStmt : sig
    val name': unit -> string
    type t = VariableSetStmt.t option 
    val make : ?setstmt:VariableSetStmt.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterSystemStmt"
    type t = VariableSetStmt.t option
    let make =
      fun ?setstmt () -> 
      
      setstmt
    
    let to_proto =
      let apply = fun ~f:f' setstmt -> f' [] setstmt in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> VariableSetStmt.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions setstmt -> setstmt in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> VariableSetStmt.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreatePolicyStmt : sig
    val name': unit -> string
    type t = { policy_name: string; table: RangeVar.t option; cmd_name: string; permissive: bool; roles: Node.t list; qual: Node.t option; with_check: Node.t option } 
    val make : ?policy_name:string -> ?table:RangeVar.t -> ?cmd_name:string -> ?permissive:bool -> ?roles:Node.t list -> ?qual:Node.t -> ?with_check:Node.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreatePolicyStmt"
    type t = { policy_name: string; table: RangeVar.t option; cmd_name: string; permissive: bool; roles: Node.t list; qual: Node.t option; with_check: Node.t option }
    let make =
      fun ?policy_name ?table ?cmd_name ?permissive ?roles ?qual ?with_check () -> 
      let policy_name = match policy_name with Some v -> v | None -> {||} in
      let cmd_name = match cmd_name with Some v -> v | None -> {||} in
      let permissive = match permissive with Some v -> v | None -> false in
      let roles = match roles with Some v -> v | None -> [] in
      { policy_name; table; cmd_name; permissive; roles; qual; with_check }
    
    let to_proto =
      let apply = fun ~f:f' { policy_name; table; cmd_name; permissive; roles; qual; with_check } -> f' [] policy_name table cmd_name permissive roles qual with_check in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> RangeVar.to_proto t))) ^:: basic (3, string, proto3) ^:: basic (4, bool, proto3) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> Node.to_proto t))) ^:: basic_opt (7, (message (fun t -> Node.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions policy_name table cmd_name permissive roles qual with_check -> { policy_name; table; cmd_name; permissive; roles; qual; with_check } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> RangeVar.from_proto t))) ^:: basic (3, string, proto3) ^:: basic (4, bool, proto3) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> Node.from_proto t))) ^:: basic_opt (7, (message (fun t -> Node.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterPolicyStmt : sig
    val name': unit -> string
    type t = { policy_name: string; table: RangeVar.t option; roles: Node.t list; qual: Node.t option; with_check: Node.t option } 
    val make : ?policy_name:string -> ?table:RangeVar.t -> ?roles:Node.t list -> ?qual:Node.t -> ?with_check:Node.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterPolicyStmt"
    type t = { policy_name: string; table: RangeVar.t option; roles: Node.t list; qual: Node.t option; with_check: Node.t option }
    let make =
      fun ?policy_name ?table ?roles ?qual ?with_check () -> 
      let policy_name = match policy_name with Some v -> v | None -> {||} in
      let roles = match roles with Some v -> v | None -> [] in
      { policy_name; table; roles; qual; with_check }
    
    let to_proto =
      let apply = fun ~f:f' { policy_name; table; roles; qual; with_check } -> f' [] policy_name table roles qual with_check in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> RangeVar.to_proto t))) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: basic_opt (5, (message (fun t -> Node.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions policy_name table roles qual with_check -> { policy_name; table; roles; qual; with_check } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> RangeVar.from_proto t))) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: basic_opt (5, (message (fun t -> Node.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateTransformStmt : sig
    val name': unit -> string
    type t = { replace: bool; type_name: TypeName.t option; lang: string; fromsql: ObjectWithArgs.t option; tosql: ObjectWithArgs.t option } 
    val make : ?replace:bool -> ?type_name:TypeName.t -> ?lang:string -> ?fromsql:ObjectWithArgs.t -> ?tosql:ObjectWithArgs.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateTransformStmt"
    type t = { replace: bool; type_name: TypeName.t option; lang: string; fromsql: ObjectWithArgs.t option; tosql: ObjectWithArgs.t option }
    let make =
      fun ?replace ?type_name ?lang ?fromsql ?tosql () -> 
      let replace = match replace with Some v -> v | None -> false in
      let lang = match lang with Some v -> v | None -> {||} in
      { replace; type_name; lang; fromsql; tosql }
    
    let to_proto =
      let apply = fun ~f:f' { replace; type_name; lang; fromsql; tosql } -> f' [] replace type_name lang fromsql tosql in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic_opt (2, (message (fun t -> TypeName.to_proto t))) ^:: basic (3, string, proto3) ^:: basic_opt (4, (message (fun t -> ObjectWithArgs.to_proto t))) ^:: basic_opt (5, (message (fun t -> ObjectWithArgs.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions replace type_name lang fromsql tosql -> { replace; type_name; lang; fromsql; tosql } in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic_opt (2, (message (fun t -> TypeName.from_proto t))) ^:: basic (3, string, proto3) ^:: basic_opt (4, (message (fun t -> ObjectWithArgs.from_proto t))) ^:: basic_opt (5, (message (fun t -> ObjectWithArgs.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateAmStmt : sig
    val name': unit -> string
    type t = { amname: string; handler_name: Node.t list; amtype: string } 
    val make : ?amname:string -> ?handler_name:Node.t list -> ?amtype:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateAmStmt"
    type t = { amname: string; handler_name: Node.t list; amtype: string }
    let make =
      fun ?amname ?handler_name ?amtype () -> 
      let amname = match amname with Some v -> v | None -> {||} in
      let handler_name = match handler_name with Some v -> v | None -> [] in
      let amtype = match amtype with Some v -> v | None -> {||} in
      { amname; handler_name; amtype }
    
    let to_proto =
      let apply = fun ~f:f' { amname; handler_name; amtype } -> f' [] amname handler_name amtype in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions amname handler_name amtype -> { amname; handler_name; amtype } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreatePublicationStmt : sig
    val name': unit -> string
    type t = { pubname: string; options: Node.t list; pubobjects: Node.t list; for_all_tables: bool } 
    val make : ?pubname:string -> ?options:Node.t list -> ?pubobjects:Node.t list -> ?for_all_tables:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreatePublicationStmt"
    type t = { pubname: string; options: Node.t list; pubobjects: Node.t list; for_all_tables: bool }
    let make =
      fun ?pubname ?options ?pubobjects ?for_all_tables () -> 
      let pubname = match pubname with Some v -> v | None -> {||} in
      let options = match options with Some v -> v | None -> [] in
      let pubobjects = match pubobjects with Some v -> v | None -> [] in
      let for_all_tables = match for_all_tables with Some v -> v | None -> false in
      { pubname; options; pubobjects; for_all_tables }
    
    let to_proto =
      let apply = fun ~f:f' { pubname; options; pubobjects; for_all_tables } -> f' [] pubname options pubobjects for_all_tables in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (4, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions pubname options pubobjects for_all_tables -> { pubname; options; pubobjects; for_all_tables } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (4, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterPublicationStmt : sig
    val name': unit -> string
    type t = { pubname: string; options: Node.t list; pubobjects: Node.t list; for_all_tables: bool; action: AlterPublicationAction.t } 
    val make : ?pubname:string -> ?options:Node.t list -> ?pubobjects:Node.t list -> ?for_all_tables:bool -> ?action:AlterPublicationAction.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterPublicationStmt"
    type t = { pubname: string; options: Node.t list; pubobjects: Node.t list; for_all_tables: bool; action: AlterPublicationAction.t }
    let make =
      fun ?pubname ?options ?pubobjects ?for_all_tables ?action () -> 
      let pubname = match pubname with Some v -> v | None -> {||} in
      let options = match options with Some v -> v | None -> [] in
      let pubobjects = match pubobjects with Some v -> v | None -> [] in
      let for_all_tables = match for_all_tables with Some v -> v | None -> false in
      let action = match action with Some v -> v | None -> (AlterPublicationAction.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { pubname; options; pubobjects; for_all_tables; action }
    
    let to_proto =
      let apply = fun ~f:f' { pubname; options; pubobjects; for_all_tables; action } -> f' [] pubname options pubobjects for_all_tables action in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (4, bool, proto3) ^:: basic (5, (enum AlterPublicationAction.to_int), proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions pubname options pubobjects for_all_tables action -> { pubname; options; pubobjects; for_all_tables; action } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (4, bool, proto3) ^:: basic (5, (enum AlterPublicationAction.from_int), proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateSubscriptionStmt : sig
    val name': unit -> string
    type t = { subname: string; conninfo: string; publication: Node.t list; options: Node.t list } 
    val make : ?subname:string -> ?conninfo:string -> ?publication:Node.t list -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateSubscriptionStmt"
    type t = { subname: string; conninfo: string; publication: Node.t list; options: Node.t list }
    let make =
      fun ?subname ?conninfo ?publication ?options () -> 
      let subname = match subname with Some v -> v | None -> {||} in
      let conninfo = match conninfo with Some v -> v | None -> {||} in
      let publication = match publication with Some v -> v | None -> [] in
      let options = match options with Some v -> v | None -> [] in
      { subname; conninfo; publication; options }
    
    let to_proto =
      let apply = fun ~f:f' { subname; conninfo; publication; options } -> f' [] subname conninfo publication options in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions subname conninfo publication options -> { subname; conninfo; publication; options } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterSubscriptionStmt : sig
    val name': unit -> string
    type t = { kind: AlterSubscriptionType.t; subname: string; conninfo: string; publication: Node.t list; options: Node.t list } 
    val make : ?kind:AlterSubscriptionType.t -> ?subname:string -> ?conninfo:string -> ?publication:Node.t list -> ?options:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterSubscriptionStmt"
    type t = { kind: AlterSubscriptionType.t; subname: string; conninfo: string; publication: Node.t list; options: Node.t list }
    let make =
      fun ?kind ?subname ?conninfo ?publication ?options () -> 
      let kind = match kind with Some v -> v | None -> (AlterSubscriptionType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let subname = match subname with Some v -> v | None -> {||} in
      let conninfo = match conninfo with Some v -> v | None -> {||} in
      let publication = match publication with Some v -> v | None -> [] in
      let options = match options with Some v -> v | None -> [] in
      { kind; subname; conninfo; publication; options }
    
    let to_proto =
      let apply = fun ~f:f' { kind; subname; conninfo; publication; options } -> f' [] kind subname conninfo publication options in
      let spec = Runtime'.Serialize.C.( basic (1, (enum AlterSubscriptionType.to_int), proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions kind subname conninfo publication options -> { kind; subname; conninfo; publication; options } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum AlterSubscriptionType.from_int), proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DropSubscriptionStmt : sig
    val name': unit -> string
    type t = { subname: string; missing_ok: bool; behavior: DropBehavior.t } 
    val make : ?subname:string -> ?missing_ok:bool -> ?behavior:DropBehavior.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.DropSubscriptionStmt"
    type t = { subname: string; missing_ok: bool; behavior: DropBehavior.t }
    let make =
      fun ?subname ?missing_ok ?behavior () -> 
      let subname = match subname with Some v -> v | None -> {||} in
      let missing_ok = match missing_ok with Some v -> v | None -> false in
      let behavior = match behavior with Some v -> v | None -> (DropBehavior.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { subname; missing_ok; behavior }
    
    let to_proto =
      let apply = fun ~f:f' { subname; missing_ok; behavior } -> f' [] subname missing_ok behavior in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, (enum DropBehavior.to_int), proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions subname missing_ok behavior -> { subname; missing_ok; behavior } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, (enum DropBehavior.from_int), proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateStatsStmt : sig
    val name': unit -> string
    type t = { defnames: Node.t list; stat_types: Node.t list; exprs: Node.t list; relations: Node.t list; stxcomment: string; transformed: bool; if_not_exists: bool } 
    val make : ?defnames:Node.t list -> ?stat_types:Node.t list -> ?exprs:Node.t list -> ?relations:Node.t list -> ?stxcomment:string -> ?transformed:bool -> ?if_not_exists:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateStatsStmt"
    type t = { defnames: Node.t list; stat_types: Node.t list; exprs: Node.t list; relations: Node.t list; stxcomment: string; transformed: bool; if_not_exists: bool }
    let make =
      fun ?defnames ?stat_types ?exprs ?relations ?stxcomment ?transformed ?if_not_exists () -> 
      let defnames = match defnames with Some v -> v | None -> [] in
      let stat_types = match stat_types with Some v -> v | None -> [] in
      let exprs = match exprs with Some v -> v | None -> [] in
      let relations = match relations with Some v -> v | None -> [] in
      let stxcomment = match stxcomment with Some v -> v | None -> {||} in
      let transformed = match transformed with Some v -> v | None -> false in
      let if_not_exists = match if_not_exists with Some v -> v | None -> false in
      { defnames; stat_types; exprs; relations; stxcomment; transformed; if_not_exists }
    
    let to_proto =
      let apply = fun ~f:f' { defnames; stat_types; exprs; relations; stxcomment; transformed; if_not_exists } -> f' [] defnames stat_types exprs relations stxcomment transformed if_not_exists in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (5, string, proto3) ^:: basic (6, bool, proto3) ^:: basic (7, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions defnames stat_types exprs relations stxcomment transformed if_not_exists -> { defnames; stat_types; exprs; relations; stxcomment; transformed; if_not_exists } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (5, string, proto3) ^:: basic (6, bool, proto3) ^:: basic (7, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterCollationStmt : sig
    val name': unit -> string
    type t = Node.t list 
    val make : ?collname:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterCollationStmt"
    type t = Node.t list
    let make =
      fun ?collname () -> 
      let collname = match collname with Some v -> v | None -> [] in
      collname
    
    let to_proto =
      let apply = fun ~f:f' collname -> f' [] collname in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions collname -> collname in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CallStmt : sig
    val name': unit -> string
    type t = { funccall: FuncCall.t option; funcexpr: FuncExpr.t option; outargs: Node.t list } 
    val make : ?funccall:FuncCall.t -> ?funcexpr:FuncExpr.t -> ?outargs:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CallStmt"
    type t = { funccall: FuncCall.t option; funcexpr: FuncExpr.t option; outargs: Node.t list }
    let make =
      fun ?funccall ?funcexpr ?outargs () -> 
      let outargs = match outargs with Some v -> v | None -> [] in
      { funccall; funcexpr; outargs }
    
    let to_proto =
      let apply = fun ~f:f' { funccall; funcexpr; outargs } -> f' [] funccall funcexpr outargs in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> FuncCall.to_proto t))) ^:: basic_opt (2, (message (fun t -> FuncExpr.to_proto t))) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions funccall funcexpr outargs -> { funccall; funcexpr; outargs } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> FuncCall.from_proto t))) ^:: basic_opt (2, (message (fun t -> FuncExpr.from_proto t))) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AlterStatsStmt : sig
    val name': unit -> string
    type t = { defnames: Node.t list; stxstattarget: int; missing_ok: bool } 
    val make : ?defnames:Node.t list -> ?stxstattarget:int -> ?missing_ok:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AlterStatsStmt"
    type t = { defnames: Node.t list; stxstattarget: int; missing_ok: bool }
    let make =
      fun ?defnames ?stxstattarget ?missing_ok () -> 
      let defnames = match defnames with Some v -> v | None -> [] in
      let stxstattarget = match stxstattarget with Some v -> v | None -> 0 in
      let missing_ok = match missing_ok with Some v -> v | None -> false in
      { defnames; stxstattarget; missing_ok }
    
    let to_proto =
      let apply = fun ~f:f' { defnames; stxstattarget; missing_ok } -> f' [] defnames stxstattarget missing_ok in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, int32_int, proto3) ^:: basic (3, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions defnames stxstattarget missing_ok -> { defnames; stxstattarget; missing_ok } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, int32_int, proto3) ^:: basic (3, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and A_Expr : sig
    val name': unit -> string
    type t = { kind: A_Expr_Kind.t; name: Node.t list; lexpr: Node.t option; rexpr: Node.t option; location: int } 
    val make : ?kind:A_Expr_Kind.t -> ?name:Node.t list -> ?lexpr:Node.t -> ?rexpr:Node.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.A_Expr"
    type t = { kind: A_Expr_Kind.t; name: Node.t list; lexpr: Node.t option; rexpr: Node.t option; location: int }
    let make =
      fun ?kind ?name ?lexpr ?rexpr ?location () -> 
      let kind = match kind with Some v -> v | None -> (A_Expr_Kind.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let name = match name with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { kind; name; lexpr; rexpr; location }
    
    let to_proto =
      let apply = fun ~f:f' { kind; name; lexpr; rexpr; location } -> f' [] kind name lexpr rexpr location in
      let spec = Runtime'.Serialize.C.( basic (1, (enum A_Expr_Kind.to_int), proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions kind name lexpr rexpr location -> { kind; name; lexpr; rexpr; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum A_Expr_Kind.from_int), proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ColumnRef : sig
    val name': unit -> string
    type t = { fields: Node.t list; location: int } 
    val make : ?fields:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ColumnRef"
    type t = { fields: Node.t list; location: int }
    let make =
      fun ?fields ?location () -> 
      let fields = match fields with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { fields; location }
    
    let to_proto =
      let apply = fun ~f:f' { fields; location } -> f' [] fields location in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions fields location -> { fields; location } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ParamRef : sig
    val name': unit -> string
    type t = { number: int; location: int } 
    val make : ?number:int -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ParamRef"
    type t = { number: int; location: int }
    let make =
      fun ?number ?location () -> 
      let number = match number with Some v -> v | None -> 0 in
      let location = match location with Some v -> v | None -> 0 in
      { number; location }
    
    let to_proto =
      let apply = fun ~f:f' { number; location } -> f' [] number location in
      let spec = Runtime'.Serialize.C.( basic (1, int32_int, proto3) ^:: basic (2, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions number location -> { number; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, int32_int, proto3) ^:: basic (2, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and FuncCall : sig
    val name': unit -> string
    type t = { funcname: Node.t list; args: Node.t list; agg_order: Node.t list; agg_filter: Node.t option; over: WindowDef.t option; agg_within_group: bool; agg_star: bool; agg_distinct: bool; func_variadic: bool; funcformat: CoercionForm.t; location: int } 
    val make : ?funcname:Node.t list -> ?args:Node.t list -> ?agg_order:Node.t list -> ?agg_filter:Node.t -> ?over:WindowDef.t -> ?agg_within_group:bool -> ?agg_star:bool -> ?agg_distinct:bool -> ?func_variadic:bool -> ?funcformat:CoercionForm.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.FuncCall"
    type t = { funcname: Node.t list; args: Node.t list; agg_order: Node.t list; agg_filter: Node.t option; over: WindowDef.t option; agg_within_group: bool; agg_star: bool; agg_distinct: bool; func_variadic: bool; funcformat: CoercionForm.t; location: int }
    let make =
      fun ?funcname ?args ?agg_order ?agg_filter ?over ?agg_within_group ?agg_star ?agg_distinct ?func_variadic ?funcformat ?location () -> 
      let funcname = match funcname with Some v -> v | None -> [] in
      let args = match args with Some v -> v | None -> [] in
      let agg_order = match agg_order with Some v -> v | None -> [] in
      let agg_within_group = match agg_within_group with Some v -> v | None -> false in
      let agg_star = match agg_star with Some v -> v | None -> false in
      let agg_distinct = match agg_distinct with Some v -> v | None -> false in
      let func_variadic = match func_variadic with Some v -> v | None -> false in
      let funcformat = match funcformat with Some v -> v | None -> (CoercionForm.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let location = match location with Some v -> v | None -> 0 in
      { funcname; args; agg_order; agg_filter; over; agg_within_group; agg_star; agg_distinct; func_variadic; funcformat; location }
    
    let to_proto =
      let apply = fun ~f:f' { funcname; args; agg_order; agg_filter; over; agg_within_group; agg_star; agg_distinct; func_variadic; funcformat; location } -> f' [] funcname args agg_order agg_filter over agg_within_group agg_star agg_distinct func_variadic funcformat location in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: basic_opt (5, (message (fun t -> WindowDef.to_proto t))) ^:: basic (6, bool, proto3) ^:: basic (7, bool, proto3) ^:: basic (8, bool, proto3) ^:: basic (9, bool, proto3) ^:: basic (10, (enum CoercionForm.to_int), proto3) ^:: basic (11, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions funcname args agg_order agg_filter over agg_within_group agg_star agg_distinct func_variadic funcformat location -> { funcname; args; agg_order; agg_filter; over; agg_within_group; agg_star; agg_distinct; func_variadic; funcformat; location } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: basic_opt (5, (message (fun t -> WindowDef.from_proto t))) ^:: basic (6, bool, proto3) ^:: basic (7, bool, proto3) ^:: basic (8, bool, proto3) ^:: basic (9, bool, proto3) ^:: basic (10, (enum CoercionForm.from_int), proto3) ^:: basic (11, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and A_Star : sig
    val name': unit -> string
    type t = unit 
    val make : unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.A_Star"
    type t = unit
    let make =
      fun  () -> 
      
      ()
    
    let to_proto =
      let apply = fun ~f:f' () -> f' []  in
      let spec = Runtime'.Serialize.C.( nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions  -> () in
      let spec = Runtime'.Deserialize.C.( nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and A_Indices : sig
    val name': unit -> string
    type t = { is_slice: bool; lidx: Node.t option; uidx: Node.t option } 
    val make : ?is_slice:bool -> ?lidx:Node.t -> ?uidx:Node.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.A_Indices"
    type t = { is_slice: bool; lidx: Node.t option; uidx: Node.t option }
    let make =
      fun ?is_slice ?lidx ?uidx () -> 
      let is_slice = match is_slice with Some v -> v | None -> false in
      { is_slice; lidx; uidx }
    
    let to_proto =
      let apply = fun ~f:f' { is_slice; lidx; uidx } -> f' [] is_slice lidx uidx in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions is_slice lidx uidx -> { is_slice; lidx; uidx } in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and A_Indirection : sig
    val name': unit -> string
    type t = { arg: Node.t option; indirection: Node.t list } 
    val make : ?arg:Node.t -> ?indirection:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.A_Indirection"
    type t = { arg: Node.t option; indirection: Node.t list }
    let make =
      fun ?arg ?indirection () -> 
      let indirection = match indirection with Some v -> v | None -> [] in
      { arg; indirection }
    
    let to_proto =
      let apply = fun ~f:f' { arg; indirection } -> f' [] arg indirection in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions arg indirection -> { arg; indirection } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and A_ArrayExpr : sig
    val name': unit -> string
    type t = { elements: Node.t list; location: int } 
    val make : ?elements:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.A_ArrayExpr"
    type t = { elements: Node.t list; location: int }
    let make =
      fun ?elements ?location () -> 
      let elements = match elements with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { elements; location }
    
    let to_proto =
      let apply = fun ~f:f' { elements; location } -> f' [] elements location in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions elements location -> { elements; location } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ResTarget : sig
    val name': unit -> string
    type t = { name: string; indirection: Node.t list; val': Node.t option; location: int } 
    val make : ?name:string -> ?indirection:Node.t list -> ?val':Node.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ResTarget"
    type t = { name: string; indirection: Node.t list; val': Node.t option; location: int }
    let make =
      fun ?name ?indirection ?val' ?location () -> 
      let name = match name with Some v -> v | None -> {||} in
      let indirection = match indirection with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { name; indirection; val'; location }
    
    let to_proto =
      let apply = fun ~f:f' { name; indirection; val'; location } -> f' [] name indirection val' location in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name indirection val' location -> { name; indirection; val'; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and MultiAssignRef : sig
    val name': unit -> string
    type t = { source: Node.t option; colno: int; ncolumns: int } 
    val make : ?source:Node.t -> ?colno:int -> ?ncolumns:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.MultiAssignRef"
    type t = { source: Node.t option; colno: int; ncolumns: int }
    let make =
      fun ?source ?colno ?ncolumns () -> 
      let colno = match colno with Some v -> v | None -> 0 in
      let ncolumns = match ncolumns with Some v -> v | None -> 0 in
      { source; colno; ncolumns }
    
    let to_proto =
      let apply = fun ~f:f' { source; colno; ncolumns } -> f' [] source colno ncolumns in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, int32_int, proto3) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions source colno ncolumns -> { source; colno; ncolumns } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, int32_int, proto3) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and TypeCast : sig
    val name': unit -> string
    type t = { arg: Node.t option; type_name: TypeName.t option; location: int } 
    val make : ?arg:Node.t -> ?type_name:TypeName.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.TypeCast"
    type t = { arg: Node.t option; type_name: TypeName.t option; location: int }
    let make =
      fun ?arg ?type_name ?location () -> 
      let location = match location with Some v -> v | None -> 0 in
      { arg; type_name; location }
    
    let to_proto =
      let apply = fun ~f:f' { arg; type_name; location } -> f' [] arg type_name location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic_opt (2, (message (fun t -> TypeName.to_proto t))) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions arg type_name location -> { arg; type_name; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic_opt (2, (message (fun t -> TypeName.from_proto t))) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CollateClause : sig
    val name': unit -> string
    type t = { arg: Node.t option; collname: Node.t list; location: int } 
    val make : ?arg:Node.t -> ?collname:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CollateClause"
    type t = { arg: Node.t option; collname: Node.t list; location: int }
    let make =
      fun ?arg ?collname ?location () -> 
      let collname = match collname with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { arg; collname; location }
    
    let to_proto =
      let apply = fun ~f:f' { arg; collname; location } -> f' [] arg collname location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions arg collname location -> { arg; collname; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SortBy : sig
    val name': unit -> string
    type t = { node: Node.t option; sortby_dir: SortByDir.t; sortby_nulls: SortByNulls.t; use_op: Node.t list; location: int } 
    val make : ?node:Node.t -> ?sortby_dir:SortByDir.t -> ?sortby_nulls:SortByNulls.t -> ?use_op:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.SortBy"
    type t = { node: Node.t option; sortby_dir: SortByDir.t; sortby_nulls: SortByNulls.t; use_op: Node.t list; location: int }
    let make =
      fun ?node ?sortby_dir ?sortby_nulls ?use_op ?location () -> 
      let sortby_dir = match sortby_dir with Some v -> v | None -> (SortByDir.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let sortby_nulls = match sortby_nulls with Some v -> v | None -> (SortByNulls.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let use_op = match use_op with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { node; sortby_dir; sortby_nulls; use_op; location }
    
    let to_proto =
      let apply = fun ~f:f' { node; sortby_dir; sortby_nulls; use_op; location } -> f' [] node sortby_dir sortby_nulls use_op location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, (enum SortByDir.to_int), proto3) ^:: basic (3, (enum SortByNulls.to_int), proto3) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions node sortby_dir sortby_nulls use_op location -> { node; sortby_dir; sortby_nulls; use_op; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, (enum SortByDir.from_int), proto3) ^:: basic (3, (enum SortByNulls.from_int), proto3) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and WindowDef : sig
    val name': unit -> string
    type t = { name: string; refname: string; partition_clause: Node.t list; order_clause: Node.t list; frame_options: int; start_offset: Node.t option; end_offset: Node.t option; location: int } 
    val make : ?name:string -> ?refname:string -> ?partition_clause:Node.t list -> ?order_clause:Node.t list -> ?frame_options:int -> ?start_offset:Node.t -> ?end_offset:Node.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.WindowDef"
    type t = { name: string; refname: string; partition_clause: Node.t list; order_clause: Node.t list; frame_options: int; start_offset: Node.t option; end_offset: Node.t option; location: int }
    let make =
      fun ?name ?refname ?partition_clause ?order_clause ?frame_options ?start_offset ?end_offset ?location () -> 
      let name = match name with Some v -> v | None -> {||} in
      let refname = match refname with Some v -> v | None -> {||} in
      let partition_clause = match partition_clause with Some v -> v | None -> [] in
      let order_clause = match order_clause with Some v -> v | None -> [] in
      let frame_options = match frame_options with Some v -> v | None -> 0 in
      let location = match location with Some v -> v | None -> 0 in
      { name; refname; partition_clause; order_clause; frame_options; start_offset; end_offset; location }
    
    let to_proto =
      let apply = fun ~f:f' { name; refname; partition_clause; order_clause; frame_options; start_offset; end_offset; location } -> f' [] name refname partition_clause order_clause frame_options start_offset end_offset location in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (5, int32_int, proto3) ^:: basic_opt (6, (message (fun t -> Node.to_proto t))) ^:: basic_opt (7, (message (fun t -> Node.to_proto t))) ^:: basic (8, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name refname partition_clause order_clause frame_options start_offset end_offset location -> { name; refname; partition_clause; order_clause; frame_options; start_offset; end_offset; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (5, int32_int, proto3) ^:: basic_opt (6, (message (fun t -> Node.from_proto t))) ^:: basic_opt (7, (message (fun t -> Node.from_proto t))) ^:: basic (8, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RangeSubselect : sig
    val name': unit -> string
    type t = { lateral: bool; subquery: Node.t option; alias: Alias.t option } 
    val make : ?lateral:bool -> ?subquery:Node.t -> ?alias:Alias.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RangeSubselect"
    type t = { lateral: bool; subquery: Node.t option; alias: Alias.t option }
    let make =
      fun ?lateral ?subquery ?alias () -> 
      let lateral = match lateral with Some v -> v | None -> false in
      { lateral; subquery; alias }
    
    let to_proto =
      let apply = fun ~f:f' { lateral; subquery; alias } -> f' [] lateral subquery alias in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic_opt (3, (message (fun t -> Alias.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions lateral subquery alias -> { lateral; subquery; alias } in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic_opt (3, (message (fun t -> Alias.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RangeFunction : sig
    val name': unit -> string
    type t = { lateral: bool; ordinality: bool; is_rowsfrom: bool; functions: Node.t list; alias: Alias.t option; coldeflist: Node.t list } 
    val make : ?lateral:bool -> ?ordinality:bool -> ?is_rowsfrom:bool -> ?functions:Node.t list -> ?alias:Alias.t -> ?coldeflist:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RangeFunction"
    type t = { lateral: bool; ordinality: bool; is_rowsfrom: bool; functions: Node.t list; alias: Alias.t option; coldeflist: Node.t list }
    let make =
      fun ?lateral ?ordinality ?is_rowsfrom ?functions ?alias ?coldeflist () -> 
      let lateral = match lateral with Some v -> v | None -> false in
      let ordinality = match ordinality with Some v -> v | None -> false in
      let is_rowsfrom = match is_rowsfrom with Some v -> v | None -> false in
      let functions = match functions with Some v -> v | None -> [] in
      let coldeflist = match coldeflist with Some v -> v | None -> [] in
      { lateral; ordinality; is_rowsfrom; functions; alias; coldeflist }
    
    let to_proto =
      let apply = fun ~f:f' { lateral; ordinality; is_rowsfrom; functions; alias; coldeflist } -> f' [] lateral ordinality is_rowsfrom functions alias coldeflist in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, bool, proto3) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (5, (message (fun t -> Alias.to_proto t))) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions lateral ordinality is_rowsfrom functions alias coldeflist -> { lateral; ordinality; is_rowsfrom; functions; alias; coldeflist } in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, bool, proto3) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (5, (message (fun t -> Alias.from_proto t))) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RangeTableSample : sig
    val name': unit -> string
    type t = { relation: Node.t option; method': Node.t list; args: Node.t list; repeatable: Node.t option; location: int } 
    val make : ?relation:Node.t -> ?method':Node.t list -> ?args:Node.t list -> ?repeatable:Node.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RangeTableSample"
    type t = { relation: Node.t option; method': Node.t list; args: Node.t list; repeatable: Node.t option; location: int }
    let make =
      fun ?relation ?method' ?args ?repeatable ?location () -> 
      let method' = match method' with Some v -> v | None -> [] in
      let args = match args with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { relation; method'; args; repeatable; location }
    
    let to_proto =
      let apply = fun ~f:f' { relation; method'; args; repeatable; location } -> f' [] relation method' args repeatable location in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions relation method' args repeatable location -> { relation; method'; args; repeatable; location } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RangeTableFunc : sig
    val name': unit -> string
    type t = { lateral: bool; docexpr: Node.t option; rowexpr: Node.t option; namespaces: Node.t list; columns: Node.t list; alias: Alias.t option; location: int } 
    val make : ?lateral:bool -> ?docexpr:Node.t -> ?rowexpr:Node.t -> ?namespaces:Node.t list -> ?columns:Node.t list -> ?alias:Alias.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RangeTableFunc"
    type t = { lateral: bool; docexpr: Node.t option; rowexpr: Node.t option; namespaces: Node.t list; columns: Node.t list; alias: Alias.t option; location: int }
    let make =
      fun ?lateral ?docexpr ?rowexpr ?namespaces ?columns ?alias ?location () -> 
      let lateral = match lateral with Some v -> v | None -> false in
      let namespaces = match namespaces with Some v -> v | None -> [] in
      let columns = match columns with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { lateral; docexpr; rowexpr; namespaces; columns; alias; location }
    
    let to_proto =
      let apply = fun ~f:f' { lateral; docexpr; rowexpr; namespaces; columns; alias; location } -> f' [] lateral docexpr rowexpr namespaces columns alias location in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> Alias.to_proto t))) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions lateral docexpr rowexpr namespaces columns alias location -> { lateral; docexpr; rowexpr; namespaces; columns; alias; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> Alias.from_proto t))) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RangeTableFuncCol : sig
    val name': unit -> string
    type t = { colname: string; type_name: TypeName.t option; for_ordinality: bool; is_not_null: bool; colexpr: Node.t option; coldefexpr: Node.t option; location: int } 
    val make : ?colname:string -> ?type_name:TypeName.t -> ?for_ordinality:bool -> ?is_not_null:bool -> ?colexpr:Node.t -> ?coldefexpr:Node.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RangeTableFuncCol"
    type t = { colname: string; type_name: TypeName.t option; for_ordinality: bool; is_not_null: bool; colexpr: Node.t option; coldefexpr: Node.t option; location: int }
    let make =
      fun ?colname ?type_name ?for_ordinality ?is_not_null ?colexpr ?coldefexpr ?location () -> 
      let colname = match colname with Some v -> v | None -> {||} in
      let for_ordinality = match for_ordinality with Some v -> v | None -> false in
      let is_not_null = match is_not_null with Some v -> v | None -> false in
      let location = match location with Some v -> v | None -> 0 in
      { colname; type_name; for_ordinality; is_not_null; colexpr; coldefexpr; location }
    
    let to_proto =
      let apply = fun ~f:f' { colname; type_name; for_ordinality; is_not_null; colexpr; coldefexpr; location } -> f' [] colname type_name for_ordinality is_not_null colexpr coldefexpr location in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> TypeName.to_proto t))) ^:: basic (3, bool, proto3) ^:: basic (4, bool, proto3) ^:: basic_opt (5, (message (fun t -> Node.to_proto t))) ^:: basic_opt (6, (message (fun t -> Node.to_proto t))) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions colname type_name for_ordinality is_not_null colexpr coldefexpr location -> { colname; type_name; for_ordinality; is_not_null; colexpr; coldefexpr; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> TypeName.from_proto t))) ^:: basic (3, bool, proto3) ^:: basic (4, bool, proto3) ^:: basic_opt (5, (message (fun t -> Node.from_proto t))) ^:: basic_opt (6, (message (fun t -> Node.from_proto t))) ^:: basic (7, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and TypeName : sig
    val name': unit -> string
    type t = { names: Node.t list; type_oid: int; setof: bool; pct_type: bool; typmods: Node.t list; typemod: int; array_bounds: Node.t list; location: int } 
    val make : ?names:Node.t list -> ?type_oid:int -> ?setof:bool -> ?pct_type:bool -> ?typmods:Node.t list -> ?typemod:int -> ?array_bounds:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.TypeName"
    type t = { names: Node.t list; type_oid: int; setof: bool; pct_type: bool; typmods: Node.t list; typemod: int; array_bounds: Node.t list; location: int }
    let make =
      fun ?names ?type_oid ?setof ?pct_type ?typmods ?typemod ?array_bounds ?location () -> 
      let names = match names with Some v -> v | None -> [] in
      let type_oid = match type_oid with Some v -> v | None -> 0 in
      let setof = match setof with Some v -> v | None -> false in
      let pct_type = match pct_type with Some v -> v | None -> false in
      let typmods = match typmods with Some v -> v | None -> [] in
      let typemod = match typemod with Some v -> v | None -> 0 in
      let array_bounds = match array_bounds with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { names; type_oid; setof; pct_type; typmods; typemod; array_bounds; location }
    
    let to_proto =
      let apply = fun ~f:f' { names; type_oid; setof; pct_type; typmods; typemod; array_bounds; location } -> f' [] names type_oid setof pct_type typmods typemod array_bounds location in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, uint32_int, proto3) ^:: basic (3, bool, proto3) ^:: basic (4, bool, proto3) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (6, int32_int, proto3) ^:: repeated (7, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (8, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions names type_oid setof pct_type typmods typemod array_bounds location -> { names; type_oid; setof; pct_type; typmods; typemod; array_bounds; location } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, uint32_int, proto3) ^:: basic (3, bool, proto3) ^:: basic (4, bool, proto3) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (6, int32_int, proto3) ^:: repeated (7, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (8, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ColumnDef : sig
    val name': unit -> string
    type t = { colname: string; type_name: TypeName.t option; compression: string; inhcount: int; is_local: bool; is_not_null: bool; is_from_type: bool; storage: string; raw_default: Node.t option; cooked_default: Node.t option; identity: string; identity_sequence: RangeVar.t option; generated: string; coll_clause: CollateClause.t option; coll_oid: int; constraints: Node.t list; fdwoptions: Node.t list; location: int } 
    val make : ?colname:string -> ?type_name:TypeName.t -> ?compression:string -> ?inhcount:int -> ?is_local:bool -> ?is_not_null:bool -> ?is_from_type:bool -> ?storage:string -> ?raw_default:Node.t -> ?cooked_default:Node.t -> ?identity:string -> ?identity_sequence:RangeVar.t -> ?generated:string -> ?coll_clause:CollateClause.t -> ?coll_oid:int -> ?constraints:Node.t list -> ?fdwoptions:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ColumnDef"
    type t = { colname: string; type_name: TypeName.t option; compression: string; inhcount: int; is_local: bool; is_not_null: bool; is_from_type: bool; storage: string; raw_default: Node.t option; cooked_default: Node.t option; identity: string; identity_sequence: RangeVar.t option; generated: string; coll_clause: CollateClause.t option; coll_oid: int; constraints: Node.t list; fdwoptions: Node.t list; location: int }
    let make =
      fun ?colname ?type_name ?compression ?inhcount ?is_local ?is_not_null ?is_from_type ?storage ?raw_default ?cooked_default ?identity ?identity_sequence ?generated ?coll_clause ?coll_oid ?constraints ?fdwoptions ?location () -> 
      let colname = match colname with Some v -> v | None -> {||} in
      let compression = match compression with Some v -> v | None -> {||} in
      let inhcount = match inhcount with Some v -> v | None -> 0 in
      let is_local = match is_local with Some v -> v | None -> false in
      let is_not_null = match is_not_null with Some v -> v | None -> false in
      let is_from_type = match is_from_type with Some v -> v | None -> false in
      let storage = match storage with Some v -> v | None -> {||} in
      let identity = match identity with Some v -> v | None -> {||} in
      let generated = match generated with Some v -> v | None -> {||} in
      let coll_oid = match coll_oid with Some v -> v | None -> 0 in
      let constraints = match constraints with Some v -> v | None -> [] in
      let fdwoptions = match fdwoptions with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { colname; type_name; compression; inhcount; is_local; is_not_null; is_from_type; storage; raw_default; cooked_default; identity; identity_sequence; generated; coll_clause; coll_oid; constraints; fdwoptions; location }
    
    let to_proto =
      let apply = fun ~f:f' { colname; type_name; compression; inhcount; is_local; is_not_null; is_from_type; storage; raw_default; cooked_default; identity; identity_sequence; generated; coll_clause; coll_oid; constraints; fdwoptions; location } -> f' [] colname type_name compression inhcount is_local is_not_null is_from_type storage raw_default cooked_default identity identity_sequence generated coll_clause coll_oid constraints fdwoptions location in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> TypeName.to_proto t))) ^:: basic (3, string, proto3) ^:: basic (4, int32_int, proto3) ^:: basic (5, bool, proto3) ^:: basic (6, bool, proto3) ^:: basic (7, bool, proto3) ^:: basic (8, string, proto3) ^:: basic_opt (9, (message (fun t -> Node.to_proto t))) ^:: basic_opt (10, (message (fun t -> Node.to_proto t))) ^:: basic (11, string, proto3) ^:: basic_opt (12, (message (fun t -> RangeVar.to_proto t))) ^:: basic (13, string, proto3) ^:: basic_opt (14, (message (fun t -> CollateClause.to_proto t))) ^:: basic (15, uint32_int, proto3) ^:: repeated (16, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (17, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (18, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions colname type_name compression inhcount is_local is_not_null is_from_type storage raw_default cooked_default identity identity_sequence generated coll_clause coll_oid constraints fdwoptions location -> { colname; type_name; compression; inhcount; is_local; is_not_null; is_from_type; storage; raw_default; cooked_default; identity; identity_sequence; generated; coll_clause; coll_oid; constraints; fdwoptions; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> TypeName.from_proto t))) ^:: basic (3, string, proto3) ^:: basic (4, int32_int, proto3) ^:: basic (5, bool, proto3) ^:: basic (6, bool, proto3) ^:: basic (7, bool, proto3) ^:: basic (8, string, proto3) ^:: basic_opt (9, (message (fun t -> Node.from_proto t))) ^:: basic_opt (10, (message (fun t -> Node.from_proto t))) ^:: basic (11, string, proto3) ^:: basic_opt (12, (message (fun t -> RangeVar.from_proto t))) ^:: basic (13, string, proto3) ^:: basic_opt (14, (message (fun t -> CollateClause.from_proto t))) ^:: basic (15, uint32_int, proto3) ^:: repeated (16, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (17, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (18, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and IndexElem : sig
    val name': unit -> string
    type t = { name: string; expr: Node.t option; indexcolname: string; collation: Node.t list; opclass: Node.t list; opclassopts: Node.t list; ordering: SortByDir.t; nulls_ordering: SortByNulls.t } 
    val make : ?name:string -> ?expr:Node.t -> ?indexcolname:string -> ?collation:Node.t list -> ?opclass:Node.t list -> ?opclassopts:Node.t list -> ?ordering:SortByDir.t -> ?nulls_ordering:SortByNulls.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.IndexElem"
    type t = { name: string; expr: Node.t option; indexcolname: string; collation: Node.t list; opclass: Node.t list; opclassopts: Node.t list; ordering: SortByDir.t; nulls_ordering: SortByNulls.t }
    let make =
      fun ?name ?expr ?indexcolname ?collation ?opclass ?opclassopts ?ordering ?nulls_ordering () -> 
      let name = match name with Some v -> v | None -> {||} in
      let indexcolname = match indexcolname with Some v -> v | None -> {||} in
      let collation = match collation with Some v -> v | None -> [] in
      let opclass = match opclass with Some v -> v | None -> [] in
      let opclassopts = match opclassopts with Some v -> v | None -> [] in
      let ordering = match ordering with Some v -> v | None -> (SortByDir.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let nulls_ordering = match nulls_ordering with Some v -> v | None -> (SortByNulls.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { name; expr; indexcolname; collation; opclass; opclassopts; ordering; nulls_ordering }
    
    let to_proto =
      let apply = fun ~f:f' { name; expr; indexcolname; collation; opclass; opclassopts; ordering; nulls_ordering } -> f' [] name expr indexcolname collation opclass opclassopts ordering nulls_ordering in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic (3, string, proto3) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (7, (enum SortByDir.to_int), proto3) ^:: basic (8, (enum SortByNulls.to_int), proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name expr indexcolname collation opclass opclassopts ordering nulls_ordering -> { name; expr; indexcolname; collation; opclass; opclassopts; ordering; nulls_ordering } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic (3, string, proto3) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (7, (enum SortByDir.from_int), proto3) ^:: basic (8, (enum SortByNulls.from_int), proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and StatsElem : sig
    val name': unit -> string
    type t = { name: string; expr: Node.t option } 
    val make : ?name:string -> ?expr:Node.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.StatsElem"
    type t = { name: string; expr: Node.t option }
    let make =
      fun ?name ?expr () -> 
      let name = match name with Some v -> v | None -> {||} in
      { name; expr }
    
    let to_proto =
      let apply = fun ~f:f' { name; expr } -> f' [] name expr in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name expr -> { name; expr } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and Constraint : sig
    val name': unit -> string
    type t = { contype: ConstrType.t; conname: string; deferrable: bool; initdeferred: bool; location: int; is_no_inherit: bool; raw_expr: Node.t option; cooked_expr: string; generated_when: string; nulls_not_distinct: bool; keys: Node.t list; including: Node.t list; exclusions: Node.t list; options: Node.t list; indexname: string; indexspace: string; reset_default_tblspc: bool; access_method: string; where_clause: Node.t option; pktable: RangeVar.t option; fk_attrs: Node.t list; pk_attrs: Node.t list; fk_matchtype: string; fk_upd_action: string; fk_del_action: string; fk_del_set_cols: Node.t list; old_conpfeqop: Node.t list; old_pktable_oid: int; skip_validation: bool; initially_valid: bool } 
    val make : ?contype:ConstrType.t -> ?conname:string -> ?deferrable:bool -> ?initdeferred:bool -> ?location:int -> ?is_no_inherit:bool -> ?raw_expr:Node.t -> ?cooked_expr:string -> ?generated_when:string -> ?nulls_not_distinct:bool -> ?keys:Node.t list -> ?including:Node.t list -> ?exclusions:Node.t list -> ?options:Node.t list -> ?indexname:string -> ?indexspace:string -> ?reset_default_tblspc:bool -> ?access_method:string -> ?where_clause:Node.t -> ?pktable:RangeVar.t -> ?fk_attrs:Node.t list -> ?pk_attrs:Node.t list -> ?fk_matchtype:string -> ?fk_upd_action:string -> ?fk_del_action:string -> ?fk_del_set_cols:Node.t list -> ?old_conpfeqop:Node.t list -> ?old_pktable_oid:int -> ?skip_validation:bool -> ?initially_valid:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.Constraint"
    type t = { contype: ConstrType.t; conname: string; deferrable: bool; initdeferred: bool; location: int; is_no_inherit: bool; raw_expr: Node.t option; cooked_expr: string; generated_when: string; nulls_not_distinct: bool; keys: Node.t list; including: Node.t list; exclusions: Node.t list; options: Node.t list; indexname: string; indexspace: string; reset_default_tblspc: bool; access_method: string; where_clause: Node.t option; pktable: RangeVar.t option; fk_attrs: Node.t list; pk_attrs: Node.t list; fk_matchtype: string; fk_upd_action: string; fk_del_action: string; fk_del_set_cols: Node.t list; old_conpfeqop: Node.t list; old_pktable_oid: int; skip_validation: bool; initially_valid: bool }
    let make =
      fun ?contype ?conname ?deferrable ?initdeferred ?location ?is_no_inherit ?raw_expr ?cooked_expr ?generated_when ?nulls_not_distinct ?keys ?including ?exclusions ?options ?indexname ?indexspace ?reset_default_tblspc ?access_method ?where_clause ?pktable ?fk_attrs ?pk_attrs ?fk_matchtype ?fk_upd_action ?fk_del_action ?fk_del_set_cols ?old_conpfeqop ?old_pktable_oid ?skip_validation ?initially_valid () -> 
      let contype = match contype with Some v -> v | None -> (ConstrType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let conname = match conname with Some v -> v | None -> {||} in
      let deferrable = match deferrable with Some v -> v | None -> false in
      let initdeferred = match initdeferred with Some v -> v | None -> false in
      let location = match location with Some v -> v | None -> 0 in
      let is_no_inherit = match is_no_inherit with Some v -> v | None -> false in
      let cooked_expr = match cooked_expr with Some v -> v | None -> {||} in
      let generated_when = match generated_when with Some v -> v | None -> {||} in
      let nulls_not_distinct = match nulls_not_distinct with Some v -> v | None -> false in
      let keys = match keys with Some v -> v | None -> [] in
      let including = match including with Some v -> v | None -> [] in
      let exclusions = match exclusions with Some v -> v | None -> [] in
      let options = match options with Some v -> v | None -> [] in
      let indexname = match indexname with Some v -> v | None -> {||} in
      let indexspace = match indexspace with Some v -> v | None -> {||} in
      let reset_default_tblspc = match reset_default_tblspc with Some v -> v | None -> false in
      let access_method = match access_method with Some v -> v | None -> {||} in
      let fk_attrs = match fk_attrs with Some v -> v | None -> [] in
      let pk_attrs = match pk_attrs with Some v -> v | None -> [] in
      let fk_matchtype = match fk_matchtype with Some v -> v | None -> {||} in
      let fk_upd_action = match fk_upd_action with Some v -> v | None -> {||} in
      let fk_del_action = match fk_del_action with Some v -> v | None -> {||} in
      let fk_del_set_cols = match fk_del_set_cols with Some v -> v | None -> [] in
      let old_conpfeqop = match old_conpfeqop with Some v -> v | None -> [] in
      let old_pktable_oid = match old_pktable_oid with Some v -> v | None -> 0 in
      let skip_validation = match skip_validation with Some v -> v | None -> false in
      let initially_valid = match initially_valid with Some v -> v | None -> false in
      { contype; conname; deferrable; initdeferred; location; is_no_inherit; raw_expr; cooked_expr; generated_when; nulls_not_distinct; keys; including; exclusions; options; indexname; indexspace; reset_default_tblspc; access_method; where_clause; pktable; fk_attrs; pk_attrs; fk_matchtype; fk_upd_action; fk_del_action; fk_del_set_cols; old_conpfeqop; old_pktable_oid; skip_validation; initially_valid }
    
    let to_proto =
      let apply = fun ~f:f' { contype; conname; deferrable; initdeferred; location; is_no_inherit; raw_expr; cooked_expr; generated_when; nulls_not_distinct; keys; including; exclusions; options; indexname; indexspace; reset_default_tblspc; access_method; where_clause; pktable; fk_attrs; pk_attrs; fk_matchtype; fk_upd_action; fk_del_action; fk_del_set_cols; old_conpfeqop; old_pktable_oid; skip_validation; initially_valid } -> f' [] contype conname deferrable initdeferred location is_no_inherit raw_expr cooked_expr generated_when nulls_not_distinct keys including exclusions options indexname indexspace reset_default_tblspc access_method where_clause pktable fk_attrs pk_attrs fk_matchtype fk_upd_action fk_del_action fk_del_set_cols old_conpfeqop old_pktable_oid skip_validation initially_valid in
      let spec = Runtime'.Serialize.C.( basic (1, (enum ConstrType.to_int), proto3) ^:: basic (2, string, proto3) ^:: basic (3, bool, proto3) ^:: basic (4, bool, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, bool, proto3) ^:: basic_opt (7, (message (fun t -> Node.to_proto t))) ^:: basic (8, string, proto3) ^:: basic (9, string, proto3) ^:: basic (10, bool, proto3) ^:: repeated (11, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (12, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (13, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (14, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (15, string, proto3) ^:: basic (16, string, proto3) ^:: basic (17, bool, proto3) ^:: basic (18, string, proto3) ^:: basic_opt (19, (message (fun t -> Node.to_proto t))) ^:: basic_opt (20, (message (fun t -> RangeVar.to_proto t))) ^:: repeated (21, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (22, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (23, string, proto3) ^:: basic (24, string, proto3) ^:: basic (25, string, proto3) ^:: repeated (26, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (27, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (28, uint32_int, proto3) ^:: basic (29, bool, proto3) ^:: basic (30, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions contype conname deferrable initdeferred location is_no_inherit raw_expr cooked_expr generated_when nulls_not_distinct keys including exclusions options indexname indexspace reset_default_tblspc access_method where_clause pktable fk_attrs pk_attrs fk_matchtype fk_upd_action fk_del_action fk_del_set_cols old_conpfeqop old_pktable_oid skip_validation initially_valid -> { contype; conname; deferrable; initdeferred; location; is_no_inherit; raw_expr; cooked_expr; generated_when; nulls_not_distinct; keys; including; exclusions; options; indexname; indexspace; reset_default_tblspc; access_method; where_clause; pktable; fk_attrs; pk_attrs; fk_matchtype; fk_upd_action; fk_del_action; fk_del_set_cols; old_conpfeqop; old_pktable_oid; skip_validation; initially_valid } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum ConstrType.from_int), proto3) ^:: basic (2, string, proto3) ^:: basic (3, bool, proto3) ^:: basic (4, bool, proto3) ^:: basic (5, int32_int, proto3) ^:: basic (6, bool, proto3) ^:: basic_opt (7, (message (fun t -> Node.from_proto t))) ^:: basic (8, string, proto3) ^:: basic (9, string, proto3) ^:: basic (10, bool, proto3) ^:: repeated (11, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (12, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (13, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (14, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (15, string, proto3) ^:: basic (16, string, proto3) ^:: basic (17, bool, proto3) ^:: basic (18, string, proto3) ^:: basic_opt (19, (message (fun t -> Node.from_proto t))) ^:: basic_opt (20, (message (fun t -> RangeVar.from_proto t))) ^:: repeated (21, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (22, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (23, string, proto3) ^:: basic (24, string, proto3) ^:: basic (25, string, proto3) ^:: repeated (26, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (27, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (28, uint32_int, proto3) ^:: basic (29, bool, proto3) ^:: basic (30, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and DefElem : sig
    val name': unit -> string
    type t = { defnamespace: string; defname: string; arg: Node.t option; defaction: DefElemAction.t; location: int } 
    val make : ?defnamespace:string -> ?defname:string -> ?arg:Node.t -> ?defaction:DefElemAction.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.DefElem"
    type t = { defnamespace: string; defname: string; arg: Node.t option; defaction: DefElemAction.t; location: int }
    let make =
      fun ?defnamespace ?defname ?arg ?defaction ?location () -> 
      let defnamespace = match defnamespace with Some v -> v | None -> {||} in
      let defname = match defname with Some v -> v | None -> {||} in
      let defaction = match defaction with Some v -> v | None -> (DefElemAction.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let location = match location with Some v -> v | None -> 0 in
      { defnamespace; defname; arg; defaction; location }
    
    let to_proto =
      let apply = fun ~f:f' { defnamespace; defname; arg; defaction; location } -> f' [] defnamespace defname arg defaction location in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: basic (4, (enum DefElemAction.to_int), proto3) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions defnamespace defname arg defaction location -> { defnamespace; defname; arg; defaction; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: basic (4, (enum DefElemAction.from_int), proto3) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RangeTblEntry : sig
    val name': unit -> string
    type t = { rtekind: RTEKind.t; relid: int; relkind: string; rellockmode: int; tablesample: TableSampleClause.t option; subquery: Query.t option; security_barrier: bool; jointype: JoinType.t; joinmergedcols: int; joinaliasvars: Node.t list; joinleftcols: Node.t list; joinrightcols: Node.t list; join_using_alias: Alias.t option; functions: Node.t list; funcordinality: bool; tablefunc: TableFunc.t option; values_lists: Node.t list; ctename: string; ctelevelsup: int; self_reference: bool; coltypes: Node.t list; coltypmods: Node.t list; colcollations: Node.t list; enrname: string; enrtuples: float; alias: Alias.t option; eref: Alias.t option; lateral: bool; inh: bool; in_from_cl: bool; required_perms: int; check_as_user: int; selected_cols: int list; inserted_cols: int list; updated_cols: int list; extra_updated_cols: int list; security_quals: Node.t list } 
    val make : ?rtekind:RTEKind.t -> ?relid:int -> ?relkind:string -> ?rellockmode:int -> ?tablesample:TableSampleClause.t -> ?subquery:Query.t -> ?security_barrier:bool -> ?jointype:JoinType.t -> ?joinmergedcols:int -> ?joinaliasvars:Node.t list -> ?joinleftcols:Node.t list -> ?joinrightcols:Node.t list -> ?join_using_alias:Alias.t -> ?functions:Node.t list -> ?funcordinality:bool -> ?tablefunc:TableFunc.t -> ?values_lists:Node.t list -> ?ctename:string -> ?ctelevelsup:int -> ?self_reference:bool -> ?coltypes:Node.t list -> ?coltypmods:Node.t list -> ?colcollations:Node.t list -> ?enrname:string -> ?enrtuples:float -> ?alias:Alias.t -> ?eref:Alias.t -> ?lateral:bool -> ?inh:bool -> ?in_from_cl:bool -> ?required_perms:int -> ?check_as_user:int -> ?selected_cols:int list -> ?inserted_cols:int list -> ?updated_cols:int list -> ?extra_updated_cols:int list -> ?security_quals:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RangeTblEntry"
    type t = { rtekind: RTEKind.t; relid: int; relkind: string; rellockmode: int; tablesample: TableSampleClause.t option; subquery: Query.t option; security_barrier: bool; jointype: JoinType.t; joinmergedcols: int; joinaliasvars: Node.t list; joinleftcols: Node.t list; joinrightcols: Node.t list; join_using_alias: Alias.t option; functions: Node.t list; funcordinality: bool; tablefunc: TableFunc.t option; values_lists: Node.t list; ctename: string; ctelevelsup: int; self_reference: bool; coltypes: Node.t list; coltypmods: Node.t list; colcollations: Node.t list; enrname: string; enrtuples: float; alias: Alias.t option; eref: Alias.t option; lateral: bool; inh: bool; in_from_cl: bool; required_perms: int; check_as_user: int; selected_cols: int list; inserted_cols: int list; updated_cols: int list; extra_updated_cols: int list; security_quals: Node.t list }
    let make =
      fun ?rtekind ?relid ?relkind ?rellockmode ?tablesample ?subquery ?security_barrier ?jointype ?joinmergedcols ?joinaliasvars ?joinleftcols ?joinrightcols ?join_using_alias ?functions ?funcordinality ?tablefunc ?values_lists ?ctename ?ctelevelsup ?self_reference ?coltypes ?coltypmods ?colcollations ?enrname ?enrtuples ?alias ?eref ?lateral ?inh ?in_from_cl ?required_perms ?check_as_user ?selected_cols ?inserted_cols ?updated_cols ?extra_updated_cols ?security_quals () -> 
      let rtekind = match rtekind with Some v -> v | None -> (RTEKind.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let relid = match relid with Some v -> v | None -> 0 in
      let relkind = match relkind with Some v -> v | None -> {||} in
      let rellockmode = match rellockmode with Some v -> v | None -> 0 in
      let security_barrier = match security_barrier with Some v -> v | None -> false in
      let jointype = match jointype with Some v -> v | None -> (JoinType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let joinmergedcols = match joinmergedcols with Some v -> v | None -> 0 in
      let joinaliasvars = match joinaliasvars with Some v -> v | None -> [] in
      let joinleftcols = match joinleftcols with Some v -> v | None -> [] in
      let joinrightcols = match joinrightcols with Some v -> v | None -> [] in
      let functions = match functions with Some v -> v | None -> [] in
      let funcordinality = match funcordinality with Some v -> v | None -> false in
      let values_lists = match values_lists with Some v -> v | None -> [] in
      let ctename = match ctename with Some v -> v | None -> {||} in
      let ctelevelsup = match ctelevelsup with Some v -> v | None -> 0 in
      let self_reference = match self_reference with Some v -> v | None -> false in
      let coltypes = match coltypes with Some v -> v | None -> [] in
      let coltypmods = match coltypmods with Some v -> v | None -> [] in
      let colcollations = match colcollations with Some v -> v | None -> [] in
      let enrname = match enrname with Some v -> v | None -> {||} in
      let enrtuples = match enrtuples with Some v -> v | None -> 0. in
      let lateral = match lateral with Some v -> v | None -> false in
      let inh = match inh with Some v -> v | None -> false in
      let in_from_cl = match in_from_cl with Some v -> v | None -> false in
      let required_perms = match required_perms with Some v -> v | None -> 0 in
      let check_as_user = match check_as_user with Some v -> v | None -> 0 in
      let selected_cols = match selected_cols with Some v -> v | None -> [] in
      let inserted_cols = match inserted_cols with Some v -> v | None -> [] in
      let updated_cols = match updated_cols with Some v -> v | None -> [] in
      let extra_updated_cols = match extra_updated_cols with Some v -> v | None -> [] in
      let security_quals = match security_quals with Some v -> v | None -> [] in
      { rtekind; relid; relkind; rellockmode; tablesample; subquery; security_barrier; jointype; joinmergedcols; joinaliasvars; joinleftcols; joinrightcols; join_using_alias; functions; funcordinality; tablefunc; values_lists; ctename; ctelevelsup; self_reference; coltypes; coltypmods; colcollations; enrname; enrtuples; alias; eref; lateral; inh; in_from_cl; required_perms; check_as_user; selected_cols; inserted_cols; updated_cols; extra_updated_cols; security_quals }
    
    let to_proto =
      let apply = fun ~f:f' { rtekind; relid; relkind; rellockmode; tablesample; subquery; security_barrier; jointype; joinmergedcols; joinaliasvars; joinleftcols; joinrightcols; join_using_alias; functions; funcordinality; tablefunc; values_lists; ctename; ctelevelsup; self_reference; coltypes; coltypmods; colcollations; enrname; enrtuples; alias; eref; lateral; inh; in_from_cl; required_perms; check_as_user; selected_cols; inserted_cols; updated_cols; extra_updated_cols; security_quals } -> f' [] rtekind relid relkind rellockmode tablesample subquery security_barrier jointype joinmergedcols joinaliasvars joinleftcols joinrightcols join_using_alias functions funcordinality tablefunc values_lists ctename ctelevelsup self_reference coltypes coltypmods colcollations enrname enrtuples alias eref lateral inh in_from_cl required_perms check_as_user selected_cols inserted_cols updated_cols extra_updated_cols security_quals in
      let spec = Runtime'.Serialize.C.( basic (1, (enum RTEKind.to_int), proto3) ^:: basic (2, uint32_int, proto3) ^:: basic (3, string, proto3) ^:: basic (4, int32_int, proto3) ^:: basic_opt (5, (message (fun t -> TableSampleClause.to_proto t))) ^:: basic_opt (6, (message (fun t -> Query.to_proto t))) ^:: basic (7, bool, proto3) ^:: basic (8, (enum JoinType.to_int), proto3) ^:: basic (9, int32_int, proto3) ^:: repeated (10, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (11, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (12, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (13, (message (fun t -> Alias.to_proto t))) ^:: repeated (14, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (15, bool, proto3) ^:: basic_opt (16, (message (fun t -> TableFunc.to_proto t))) ^:: repeated (17, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (18, string, proto3) ^:: basic (19, uint32_int, proto3) ^:: basic (20, bool, proto3) ^:: repeated (21, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (22, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (23, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (24, string, proto3) ^:: basic (25, double, proto3) ^:: basic_opt (26, (message (fun t -> Alias.to_proto t))) ^:: basic_opt (27, (message (fun t -> Alias.to_proto t))) ^:: basic (28, bool, proto3) ^:: basic (29, bool, proto3) ^:: basic (30, bool, proto3) ^:: basic (31, uint32_int, proto3) ^:: basic (32, uint32_int, proto3) ^:: repeated (33, uint64_int, packed) ^:: repeated (34, uint64_int, packed) ^:: repeated (35, uint64_int, packed) ^:: repeated (36, uint64_int, packed) ^:: repeated (37, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions rtekind relid relkind rellockmode tablesample subquery security_barrier jointype joinmergedcols joinaliasvars joinleftcols joinrightcols join_using_alias functions funcordinality tablefunc values_lists ctename ctelevelsup self_reference coltypes coltypmods colcollations enrname enrtuples alias eref lateral inh in_from_cl required_perms check_as_user selected_cols inserted_cols updated_cols extra_updated_cols security_quals -> { rtekind; relid; relkind; rellockmode; tablesample; subquery; security_barrier; jointype; joinmergedcols; joinaliasvars; joinleftcols; joinrightcols; join_using_alias; functions; funcordinality; tablefunc; values_lists; ctename; ctelevelsup; self_reference; coltypes; coltypmods; colcollations; enrname; enrtuples; alias; eref; lateral; inh; in_from_cl; required_perms; check_as_user; selected_cols; inserted_cols; updated_cols; extra_updated_cols; security_quals } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum RTEKind.from_int), proto3) ^:: basic (2, uint32_int, proto3) ^:: basic (3, string, proto3) ^:: basic (4, int32_int, proto3) ^:: basic_opt (5, (message (fun t -> TableSampleClause.from_proto t))) ^:: basic_opt (6, (message (fun t -> Query.from_proto t))) ^:: basic (7, bool, proto3) ^:: basic (8, (enum JoinType.from_int), proto3) ^:: basic (9, int32_int, proto3) ^:: repeated (10, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (11, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (12, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (13, (message (fun t -> Alias.from_proto t))) ^:: repeated (14, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (15, bool, proto3) ^:: basic_opt (16, (message (fun t -> TableFunc.from_proto t))) ^:: repeated (17, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (18, string, proto3) ^:: basic (19, uint32_int, proto3) ^:: basic (20, bool, proto3) ^:: repeated (21, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (22, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (23, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (24, string, proto3) ^:: basic (25, double, proto3) ^:: basic_opt (26, (message (fun t -> Alias.from_proto t))) ^:: basic_opt (27, (message (fun t -> Alias.from_proto t))) ^:: basic (28, bool, proto3) ^:: basic (29, bool, proto3) ^:: basic (30, bool, proto3) ^:: basic (31, uint32_int, proto3) ^:: basic (32, uint32_int, proto3) ^:: repeated (33, uint64_int, packed) ^:: repeated (34, uint64_int, packed) ^:: repeated (35, uint64_int, packed) ^:: repeated (36, uint64_int, packed) ^:: repeated (37, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RangeTblFunction : sig
    val name': unit -> string
    type t = { funcexpr: Node.t option; funccolcount: int; funccolnames: Node.t list; funccoltypes: Node.t list; funccoltypmods: Node.t list; funccolcollations: Node.t list; funcparams: int list } 
    val make : ?funcexpr:Node.t -> ?funccolcount:int -> ?funccolnames:Node.t list -> ?funccoltypes:Node.t list -> ?funccoltypmods:Node.t list -> ?funccolcollations:Node.t list -> ?funcparams:int list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RangeTblFunction"
    type t = { funcexpr: Node.t option; funccolcount: int; funccolnames: Node.t list; funccoltypes: Node.t list; funccoltypmods: Node.t list; funccolcollations: Node.t list; funcparams: int list }
    let make =
      fun ?funcexpr ?funccolcount ?funccolnames ?funccoltypes ?funccoltypmods ?funccolcollations ?funcparams () -> 
      let funccolcount = match funccolcount with Some v -> v | None -> 0 in
      let funccolnames = match funccolnames with Some v -> v | None -> [] in
      let funccoltypes = match funccoltypes with Some v -> v | None -> [] in
      let funccoltypmods = match funccoltypmods with Some v -> v | None -> [] in
      let funccolcollations = match funccolcollations with Some v -> v | None -> [] in
      let funcparams = match funcparams with Some v -> v | None -> [] in
      { funcexpr; funccolcount; funccolnames; funccoltypes; funccoltypmods; funccolcollations; funcparams }
    
    let to_proto =
      let apply = fun ~f:f' { funcexpr; funccolcount; funccolnames; funccoltypes; funccoltypmods; funccolcollations; funcparams } -> f' [] funcexpr funccolcount funccolnames funccoltypes funccoltypmods funccolcollations funcparams in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> Node.to_proto t))) ^:: basic (2, int32_int, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (7, uint64_int, packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions funcexpr funccolcount funccolnames funccoltypes funccoltypmods funccolcollations funcparams -> { funcexpr; funccolcount; funccolnames; funccoltypes; funccoltypmods; funccolcollations; funcparams } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> Node.from_proto t))) ^:: basic (2, int32_int, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (7, uint64_int, packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and TableSampleClause : sig
    val name': unit -> string
    type t = { tsmhandler: int; args: Node.t list; repeatable: Node.t option } 
    val make : ?tsmhandler:int -> ?args:Node.t list -> ?repeatable:Node.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.TableSampleClause"
    type t = { tsmhandler: int; args: Node.t list; repeatable: Node.t option }
    let make =
      fun ?tsmhandler ?args ?repeatable () -> 
      let tsmhandler = match tsmhandler with Some v -> v | None -> 0 in
      let args = match args with Some v -> v | None -> [] in
      { tsmhandler; args; repeatable }
    
    let to_proto =
      let apply = fun ~f:f' { tsmhandler; args; repeatable } -> f' [] tsmhandler args repeatable in
      let spec = Runtime'.Serialize.C.( basic (1, uint32_int, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions tsmhandler args repeatable -> { tsmhandler; args; repeatable } in
      let spec = Runtime'.Deserialize.C.( basic (1, uint32_int, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and WithCheckOption : sig
    val name': unit -> string
    type t = { kind: WCOKind.t; relname: string; polname: string; qual: Node.t option; cascaded: bool } 
    val make : ?kind:WCOKind.t -> ?relname:string -> ?polname:string -> ?qual:Node.t -> ?cascaded:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.WithCheckOption"
    type t = { kind: WCOKind.t; relname: string; polname: string; qual: Node.t option; cascaded: bool }
    let make =
      fun ?kind ?relname ?polname ?qual ?cascaded () -> 
      let kind = match kind with Some v -> v | None -> (WCOKind.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let relname = match relname with Some v -> v | None -> {||} in
      let polname = match polname with Some v -> v | None -> {||} in
      let cascaded = match cascaded with Some v -> v | None -> false in
      { kind; relname; polname; qual; cascaded }
    
    let to_proto =
      let apply = fun ~f:f' { kind; relname; polname; qual; cascaded } -> f' [] kind relname polname qual cascaded in
      let spec = Runtime'.Serialize.C.( basic (1, (enum WCOKind.to_int), proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: basic (5, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions kind relname polname qual cascaded -> { kind; relname; polname; qual; cascaded } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum WCOKind.from_int), proto3) ^:: basic (2, string, proto3) ^:: basic (3, string, proto3) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: basic (5, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and SortGroupClause : sig
    val name': unit -> string
    type t = { tle_sort_group_ref: int; eqop: int; sortop: int; nulls_first: bool; hashable: bool } 
    val make : ?tle_sort_group_ref:int -> ?eqop:int -> ?sortop:int -> ?nulls_first:bool -> ?hashable:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.SortGroupClause"
    type t = { tle_sort_group_ref: int; eqop: int; sortop: int; nulls_first: bool; hashable: bool }
    let make =
      fun ?tle_sort_group_ref ?eqop ?sortop ?nulls_first ?hashable () -> 
      let tle_sort_group_ref = match tle_sort_group_ref with Some v -> v | None -> 0 in
      let eqop = match eqop with Some v -> v | None -> 0 in
      let sortop = match sortop with Some v -> v | None -> 0 in
      let nulls_first = match nulls_first with Some v -> v | None -> false in
      let hashable = match hashable with Some v -> v | None -> false in
      { tle_sort_group_ref; eqop; sortop; nulls_first; hashable }
    
    let to_proto =
      let apply = fun ~f:f' { tle_sort_group_ref; eqop; sortop; nulls_first; hashable } -> f' [] tle_sort_group_ref eqop sortop nulls_first hashable in
      let spec = Runtime'.Serialize.C.( basic (1, uint32_int, proto3) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, bool, proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions tle_sort_group_ref eqop sortop nulls_first hashable -> { tle_sort_group_ref; eqop; sortop; nulls_first; hashable } in
      let spec = Runtime'.Deserialize.C.( basic (1, uint32_int, proto3) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: basic (4, bool, proto3) ^:: basic (5, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and GroupingSet : sig
    val name': unit -> string
    type t = { kind: GroupingSetKind.t; content: Node.t list; location: int } 
    val make : ?kind:GroupingSetKind.t -> ?content:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.GroupingSet"
    type t = { kind: GroupingSetKind.t; content: Node.t list; location: int }
    let make =
      fun ?kind ?content ?location () -> 
      let kind = match kind with Some v -> v | None -> (GroupingSetKind.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let content = match content with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { kind; content; location }
    
    let to_proto =
      let apply = fun ~f:f' { kind; content; location } -> f' [] kind content location in
      let spec = Runtime'.Serialize.C.( basic (1, (enum GroupingSetKind.to_int), proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions kind content location -> { kind; content; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum GroupingSetKind.from_int), proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and WindowClause : sig
    val name': unit -> string
    type t = { name: string; refname: string; partition_clause: Node.t list; order_clause: Node.t list; frame_options: int; start_offset: Node.t option; end_offset: Node.t option; run_condition: Node.t list; start_in_range_func: int; end_in_range_func: int; in_range_coll: int; in_range_asc: bool; in_range_nulls_first: bool; winref: int; copied_order: bool } 
    val make : ?name:string -> ?refname:string -> ?partition_clause:Node.t list -> ?order_clause:Node.t list -> ?frame_options:int -> ?start_offset:Node.t -> ?end_offset:Node.t -> ?run_condition:Node.t list -> ?start_in_range_func:int -> ?end_in_range_func:int -> ?in_range_coll:int -> ?in_range_asc:bool -> ?in_range_nulls_first:bool -> ?winref:int -> ?copied_order:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.WindowClause"
    type t = { name: string; refname: string; partition_clause: Node.t list; order_clause: Node.t list; frame_options: int; start_offset: Node.t option; end_offset: Node.t option; run_condition: Node.t list; start_in_range_func: int; end_in_range_func: int; in_range_coll: int; in_range_asc: bool; in_range_nulls_first: bool; winref: int; copied_order: bool }
    let make =
      fun ?name ?refname ?partition_clause ?order_clause ?frame_options ?start_offset ?end_offset ?run_condition ?start_in_range_func ?end_in_range_func ?in_range_coll ?in_range_asc ?in_range_nulls_first ?winref ?copied_order () -> 
      let name = match name with Some v -> v | None -> {||} in
      let refname = match refname with Some v -> v | None -> {||} in
      let partition_clause = match partition_clause with Some v -> v | None -> [] in
      let order_clause = match order_clause with Some v -> v | None -> [] in
      let frame_options = match frame_options with Some v -> v | None -> 0 in
      let run_condition = match run_condition with Some v -> v | None -> [] in
      let start_in_range_func = match start_in_range_func with Some v -> v | None -> 0 in
      let end_in_range_func = match end_in_range_func with Some v -> v | None -> 0 in
      let in_range_coll = match in_range_coll with Some v -> v | None -> 0 in
      let in_range_asc = match in_range_asc with Some v -> v | None -> false in
      let in_range_nulls_first = match in_range_nulls_first with Some v -> v | None -> false in
      let winref = match winref with Some v -> v | None -> 0 in
      let copied_order = match copied_order with Some v -> v | None -> false in
      { name; refname; partition_clause; order_clause; frame_options; start_offset; end_offset; run_condition; start_in_range_func; end_in_range_func; in_range_coll; in_range_asc; in_range_nulls_first; winref; copied_order }
    
    let to_proto =
      let apply = fun ~f:f' { name; refname; partition_clause; order_clause; frame_options; start_offset; end_offset; run_condition; start_in_range_func; end_in_range_func; in_range_coll; in_range_asc; in_range_nulls_first; winref; copied_order } -> f' [] name refname partition_clause order_clause frame_options start_offset end_offset run_condition start_in_range_func end_in_range_func in_range_coll in_range_asc in_range_nulls_first winref copied_order in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (5, int32_int, proto3) ^:: basic_opt (6, (message (fun t -> Node.to_proto t))) ^:: basic_opt (7, (message (fun t -> Node.to_proto t))) ^:: repeated (8, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (9, uint32_int, proto3) ^:: basic (10, uint32_int, proto3) ^:: basic (11, uint32_int, proto3) ^:: basic (12, bool, proto3) ^:: basic (13, bool, proto3) ^:: basic (14, uint32_int, proto3) ^:: basic (15, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name refname partition_clause order_clause frame_options start_offset end_offset run_condition start_in_range_func end_in_range_func in_range_coll in_range_asc in_range_nulls_first winref copied_order -> { name; refname; partition_clause; order_clause; frame_options; start_offset; end_offset; run_condition; start_in_range_func; end_in_range_func; in_range_coll; in_range_asc; in_range_nulls_first; winref; copied_order } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (5, int32_int, proto3) ^:: basic_opt (6, (message (fun t -> Node.from_proto t))) ^:: basic_opt (7, (message (fun t -> Node.from_proto t))) ^:: repeated (8, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (9, uint32_int, proto3) ^:: basic (10, uint32_int, proto3) ^:: basic (11, uint32_int, proto3) ^:: basic (12, bool, proto3) ^:: basic (13, bool, proto3) ^:: basic (14, uint32_int, proto3) ^:: basic (15, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ObjectWithArgs : sig
    val name': unit -> string
    type t = { objname: Node.t list; objargs: Node.t list; objfuncargs: Node.t list; args_unspecified: bool } 
    val make : ?objname:Node.t list -> ?objargs:Node.t list -> ?objfuncargs:Node.t list -> ?args_unspecified:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ObjectWithArgs"
    type t = { objname: Node.t list; objargs: Node.t list; objfuncargs: Node.t list; args_unspecified: bool }
    let make =
      fun ?objname ?objargs ?objfuncargs ?args_unspecified () -> 
      let objname = match objname with Some v -> v | None -> [] in
      let objargs = match objargs with Some v -> v | None -> [] in
      let objfuncargs = match objfuncargs with Some v -> v | None -> [] in
      let args_unspecified = match args_unspecified with Some v -> v | None -> false in
      { objname; objargs; objfuncargs; args_unspecified }
    
    let to_proto =
      let apply = fun ~f:f' { objname; objargs; objfuncargs; args_unspecified } -> f' [] objname objargs objfuncargs args_unspecified in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (4, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions objname objargs objfuncargs args_unspecified -> { objname; objargs; objfuncargs; args_unspecified } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (4, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and AccessPriv : sig
    val name': unit -> string
    type t = { priv_name: string; cols: Node.t list } 
    val make : ?priv_name:string -> ?cols:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.AccessPriv"
    type t = { priv_name: string; cols: Node.t list }
    let make =
      fun ?priv_name ?cols () -> 
      let priv_name = match priv_name with Some v -> v | None -> {||} in
      let cols = match cols with Some v -> v | None -> [] in
      { priv_name; cols }
    
    let to_proto =
      let apply = fun ~f:f' { priv_name; cols } -> f' [] priv_name cols in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions priv_name cols -> { priv_name; cols } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CreateOpClassItem : sig
    val name': unit -> string
    type t = { itemtype: int; name: ObjectWithArgs.t option; number: int; order_family: Node.t list; class_args: Node.t list; storedtype: TypeName.t option } 
    val make : ?itemtype:int -> ?name:ObjectWithArgs.t -> ?number:int -> ?order_family:Node.t list -> ?class_args:Node.t list -> ?storedtype:TypeName.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CreateOpClassItem"
    type t = { itemtype: int; name: ObjectWithArgs.t option; number: int; order_family: Node.t list; class_args: Node.t list; storedtype: TypeName.t option }
    let make =
      fun ?itemtype ?name ?number ?order_family ?class_args ?storedtype () -> 
      let itemtype = match itemtype with Some v -> v | None -> 0 in
      let number = match number with Some v -> v | None -> 0 in
      let order_family = match order_family with Some v -> v | None -> [] in
      let class_args = match class_args with Some v -> v | None -> [] in
      { itemtype; name; number; order_family; class_args; storedtype }
    
    let to_proto =
      let apply = fun ~f:f' { itemtype; name; number; order_family; class_args; storedtype } -> f' [] itemtype name number order_family class_args storedtype in
      let spec = Runtime'.Serialize.C.( basic (1, int32_int, proto3) ^:: basic_opt (2, (message (fun t -> ObjectWithArgs.to_proto t))) ^:: basic (3, int32_int, proto3) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> TypeName.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions itemtype name number order_family class_args storedtype -> { itemtype; name; number; order_family; class_args; storedtype } in
      let spec = Runtime'.Deserialize.C.( basic (1, int32_int, proto3) ^:: basic_opt (2, (message (fun t -> ObjectWithArgs.from_proto t))) ^:: basic (3, int32_int, proto3) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (6, (message (fun t -> TypeName.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and TableLikeClause : sig
    val name': unit -> string
    type t = { relation: RangeVar.t option; options: int; relation_oid: int } 
    val make : ?relation:RangeVar.t -> ?options:int -> ?relation_oid:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.TableLikeClause"
    type t = { relation: RangeVar.t option; options: int; relation_oid: int }
    let make =
      fun ?relation ?options ?relation_oid () -> 
      let options = match options with Some v -> v | None -> 0 in
      let relation_oid = match relation_oid with Some v -> v | None -> 0 in
      { relation; options; relation_oid }
    
    let to_proto =
      let apply = fun ~f:f' { relation; options; relation_oid } -> f' [] relation options relation_oid in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions relation options relation_oid -> { relation; options; relation_oid } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: basic (3, uint32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and FunctionParameter : sig
    val name': unit -> string
    type t = { name: string; arg_type: TypeName.t option; mode: FunctionParameterMode.t; defexpr: Node.t option } 
    val make : ?name:string -> ?arg_type:TypeName.t -> ?mode:FunctionParameterMode.t -> ?defexpr:Node.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.FunctionParameter"
    type t = { name: string; arg_type: TypeName.t option; mode: FunctionParameterMode.t; defexpr: Node.t option }
    let make =
      fun ?name ?arg_type ?mode ?defexpr () -> 
      let name = match name with Some v -> v | None -> {||} in
      let mode = match mode with Some v -> v | None -> (FunctionParameterMode.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { name; arg_type; mode; defexpr }
    
    let to_proto =
      let apply = fun ~f:f' { name; arg_type; mode; defexpr } -> f' [] name arg_type mode defexpr in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> TypeName.to_proto t))) ^:: basic (3, (enum FunctionParameterMode.to_int), proto3) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name arg_type mode defexpr -> { name; arg_type; mode; defexpr } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> TypeName.from_proto t))) ^:: basic (3, (enum FunctionParameterMode.from_int), proto3) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and LockingClause : sig
    val name': unit -> string
    type t = { locked_rels: Node.t list; strength: LockClauseStrength.t; wait_policy: LockWaitPolicy.t } 
    val make : ?locked_rels:Node.t list -> ?strength:LockClauseStrength.t -> ?wait_policy:LockWaitPolicy.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.LockingClause"
    type t = { locked_rels: Node.t list; strength: LockClauseStrength.t; wait_policy: LockWaitPolicy.t }
    let make =
      fun ?locked_rels ?strength ?wait_policy () -> 
      let locked_rels = match locked_rels with Some v -> v | None -> [] in
      let strength = match strength with Some v -> v | None -> (LockClauseStrength.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let wait_policy = match wait_policy with Some v -> v | None -> (LockWaitPolicy.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { locked_rels; strength; wait_policy }
    
    let to_proto =
      let apply = fun ~f:f' { locked_rels; strength; wait_policy } -> f' [] locked_rels strength wait_policy in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, (enum LockClauseStrength.to_int), proto3) ^:: basic (3, (enum LockWaitPolicy.to_int), proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions locked_rels strength wait_policy -> { locked_rels; strength; wait_policy } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, (enum LockClauseStrength.from_int), proto3) ^:: basic (3, (enum LockWaitPolicy.from_int), proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RowMarkClause : sig
    val name': unit -> string
    type t = { rti: int; strength: LockClauseStrength.t; wait_policy: LockWaitPolicy.t; pushed_down: bool } 
    val make : ?rti:int -> ?strength:LockClauseStrength.t -> ?wait_policy:LockWaitPolicy.t -> ?pushed_down:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RowMarkClause"
    type t = { rti: int; strength: LockClauseStrength.t; wait_policy: LockWaitPolicy.t; pushed_down: bool }
    let make =
      fun ?rti ?strength ?wait_policy ?pushed_down () -> 
      let rti = match rti with Some v -> v | None -> 0 in
      let strength = match strength with Some v -> v | None -> (LockClauseStrength.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let wait_policy = match wait_policy with Some v -> v | None -> (LockWaitPolicy.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let pushed_down = match pushed_down with Some v -> v | None -> false in
      { rti; strength; wait_policy; pushed_down }
    
    let to_proto =
      let apply = fun ~f:f' { rti; strength; wait_policy; pushed_down } -> f' [] rti strength wait_policy pushed_down in
      let spec = Runtime'.Serialize.C.( basic (1, uint32_int, proto3) ^:: basic (2, (enum LockClauseStrength.to_int), proto3) ^:: basic (3, (enum LockWaitPolicy.to_int), proto3) ^:: basic (4, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions rti strength wait_policy pushed_down -> { rti; strength; wait_policy; pushed_down } in
      let spec = Runtime'.Deserialize.C.( basic (1, uint32_int, proto3) ^:: basic (2, (enum LockClauseStrength.from_int), proto3) ^:: basic (3, (enum LockWaitPolicy.from_int), proto3) ^:: basic (4, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and XmlSerialize : sig
    val name': unit -> string
    type t = { xmloption: XmlOptionType.t; expr: Node.t option; type_name: TypeName.t option; location: int } 
    val make : ?xmloption:XmlOptionType.t -> ?expr:Node.t -> ?type_name:TypeName.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.XmlSerialize"
    type t = { xmloption: XmlOptionType.t; expr: Node.t option; type_name: TypeName.t option; location: int }
    let make =
      fun ?xmloption ?expr ?type_name ?location () -> 
      let xmloption = match xmloption with Some v -> v | None -> (XmlOptionType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let location = match location with Some v -> v | None -> 0 in
      { xmloption; expr; type_name; location }
    
    let to_proto =
      let apply = fun ~f:f' { xmloption; expr; type_name; location } -> f' [] xmloption expr type_name location in
      let spec = Runtime'.Serialize.C.( basic (1, (enum XmlOptionType.to_int), proto3) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic_opt (3, (message (fun t -> TypeName.to_proto t))) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions xmloption expr type_name location -> { xmloption; expr; type_name; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum XmlOptionType.from_int), proto3) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic_opt (3, (message (fun t -> TypeName.from_proto t))) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and WithClause : sig
    val name': unit -> string
    type t = { ctes: Node.t list; recursive: bool; location: int } 
    val make : ?ctes:Node.t list -> ?recursive:bool -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.WithClause"
    type t = { ctes: Node.t list; recursive: bool; location: int }
    let make =
      fun ?ctes ?recursive ?location () -> 
      let ctes = match ctes with Some v -> v | None -> [] in
      let recursive = match recursive with Some v -> v | None -> false in
      let location = match location with Some v -> v | None -> 0 in
      { ctes; recursive; location }
    
    let to_proto =
      let apply = fun ~f:f' { ctes; recursive; location } -> f' [] ctes recursive location in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, bool, proto3) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions ctes recursive location -> { ctes; recursive; location } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, bool, proto3) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and InferClause : sig
    val name': unit -> string
    type t = { index_elems: Node.t list; where_clause: Node.t option; conname: string; location: int } 
    val make : ?index_elems:Node.t list -> ?where_clause:Node.t -> ?conname:string -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.InferClause"
    type t = { index_elems: Node.t list; where_clause: Node.t option; conname: string; location: int }
    let make =
      fun ?index_elems ?where_clause ?conname ?location () -> 
      let index_elems = match index_elems with Some v -> v | None -> [] in
      let conname = match conname with Some v -> v | None -> {||} in
      let location = match location with Some v -> v | None -> 0 in
      { index_elems; where_clause; conname; location }
    
    let to_proto =
      let apply = fun ~f:f' { index_elems; where_clause; conname; location } -> f' [] index_elems where_clause conname location in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic (3, string, proto3) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions index_elems where_clause conname location -> { index_elems; where_clause; conname; location } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic (3, string, proto3) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and OnConflictClause : sig
    val name': unit -> string
    type t = { action: OnConflictAction.t; infer: InferClause.t option; target_list: Node.t list; where_clause: Node.t option; location: int } 
    val make : ?action:OnConflictAction.t -> ?infer:InferClause.t -> ?target_list:Node.t list -> ?where_clause:Node.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.OnConflictClause"
    type t = { action: OnConflictAction.t; infer: InferClause.t option; target_list: Node.t list; where_clause: Node.t option; location: int }
    let make =
      fun ?action ?infer ?target_list ?where_clause ?location () -> 
      let action = match action with Some v -> v | None -> (OnConflictAction.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let target_list = match target_list with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { action; infer; target_list; where_clause; location }
    
    let to_proto =
      let apply = fun ~f:f' { action; infer; target_list; where_clause; location } -> f' [] action infer target_list where_clause location in
      let spec = Runtime'.Serialize.C.( basic (1, (enum OnConflictAction.to_int), proto3) ^:: basic_opt (2, (message (fun t -> InferClause.to_proto t))) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions action infer target_list where_clause location -> { action; infer; target_list; where_clause; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum OnConflictAction.from_int), proto3) ^:: basic_opt (2, (message (fun t -> InferClause.from_proto t))) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CTESearchClause : sig
    val name': unit -> string
    type t = { search_col_list: Node.t list; search_breadth_first: bool; search_seq_column: string; location: int } 
    val make : ?search_col_list:Node.t list -> ?search_breadth_first:bool -> ?search_seq_column:string -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CTESearchClause"
    type t = { search_col_list: Node.t list; search_breadth_first: bool; search_seq_column: string; location: int }
    let make =
      fun ?search_col_list ?search_breadth_first ?search_seq_column ?location () -> 
      let search_col_list = match search_col_list with Some v -> v | None -> [] in
      let search_breadth_first = match search_breadth_first with Some v -> v | None -> false in
      let search_seq_column = match search_seq_column with Some v -> v | None -> {||} in
      let location = match location with Some v -> v | None -> 0 in
      { search_col_list; search_breadth_first; search_seq_column; location }
    
    let to_proto =
      let apply = fun ~f:f' { search_col_list; search_breadth_first; search_seq_column; location } -> f' [] search_col_list search_breadth_first search_seq_column location in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, bool, proto3) ^:: basic (3, string, proto3) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions search_col_list search_breadth_first search_seq_column location -> { search_col_list; search_breadth_first; search_seq_column; location } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, bool, proto3) ^:: basic (3, string, proto3) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CTECycleClause : sig
    val name': unit -> string
    type t = { cycle_col_list: Node.t list; cycle_mark_column: string; cycle_mark_value: Node.t option; cycle_mark_default: Node.t option; cycle_path_column: string; location: int; cycle_mark_type: int; cycle_mark_typmod: int; cycle_mark_collation: int; cycle_mark_neop: int } 
    val make : ?cycle_col_list:Node.t list -> ?cycle_mark_column:string -> ?cycle_mark_value:Node.t -> ?cycle_mark_default:Node.t -> ?cycle_path_column:string -> ?location:int -> ?cycle_mark_type:int -> ?cycle_mark_typmod:int -> ?cycle_mark_collation:int -> ?cycle_mark_neop:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CTECycleClause"
    type t = { cycle_col_list: Node.t list; cycle_mark_column: string; cycle_mark_value: Node.t option; cycle_mark_default: Node.t option; cycle_path_column: string; location: int; cycle_mark_type: int; cycle_mark_typmod: int; cycle_mark_collation: int; cycle_mark_neop: int }
    let make =
      fun ?cycle_col_list ?cycle_mark_column ?cycle_mark_value ?cycle_mark_default ?cycle_path_column ?location ?cycle_mark_type ?cycle_mark_typmod ?cycle_mark_collation ?cycle_mark_neop () -> 
      let cycle_col_list = match cycle_col_list with Some v -> v | None -> [] in
      let cycle_mark_column = match cycle_mark_column with Some v -> v | None -> {||} in
      let cycle_path_column = match cycle_path_column with Some v -> v | None -> {||} in
      let location = match location with Some v -> v | None -> 0 in
      let cycle_mark_type = match cycle_mark_type with Some v -> v | None -> 0 in
      let cycle_mark_typmod = match cycle_mark_typmod with Some v -> v | None -> 0 in
      let cycle_mark_collation = match cycle_mark_collation with Some v -> v | None -> 0 in
      let cycle_mark_neop = match cycle_mark_neop with Some v -> v | None -> 0 in
      { cycle_col_list; cycle_mark_column; cycle_mark_value; cycle_mark_default; cycle_path_column; location; cycle_mark_type; cycle_mark_typmod; cycle_mark_collation; cycle_mark_neop }
    
    let to_proto =
      let apply = fun ~f:f' { cycle_col_list; cycle_mark_column; cycle_mark_value; cycle_mark_default; cycle_path_column; location; cycle_mark_type; cycle_mark_typmod; cycle_mark_collation; cycle_mark_neop } -> f' [] cycle_col_list cycle_mark_column cycle_mark_value cycle_mark_default cycle_path_column location cycle_mark_type cycle_mark_typmod cycle_mark_collation cycle_mark_neop in
      let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (2, string, proto3) ^:: basic_opt (3, (message (fun t -> Node.to_proto t))) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: basic (5, string, proto3) ^:: basic (6, int32_int, proto3) ^:: basic (7, uint32_int, proto3) ^:: basic (8, int32_int, proto3) ^:: basic (9, uint32_int, proto3) ^:: basic (10, uint32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions cycle_col_list cycle_mark_column cycle_mark_value cycle_mark_default cycle_path_column location cycle_mark_type cycle_mark_typmod cycle_mark_collation cycle_mark_neop -> { cycle_col_list; cycle_mark_column; cycle_mark_value; cycle_mark_default; cycle_path_column; location; cycle_mark_type; cycle_mark_typmod; cycle_mark_collation; cycle_mark_neop } in
      let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (2, string, proto3) ^:: basic_opt (3, (message (fun t -> Node.from_proto t))) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: basic (5, string, proto3) ^:: basic (6, int32_int, proto3) ^:: basic (7, uint32_int, proto3) ^:: basic (8, int32_int, proto3) ^:: basic (9, uint32_int, proto3) ^:: basic (10, uint32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CommonTableExpr : sig
    val name': unit -> string
    type t = { ctename: string; aliascolnames: Node.t list; ctematerialized: CTEMaterialize.t; ctequery: Node.t option; search_clause: CTESearchClause.t option; cycle_clause: CTECycleClause.t option; location: int; cterecursive: bool; cterefcount: int; ctecolnames: Node.t list; ctecoltypes: Node.t list; ctecoltypmods: Node.t list; ctecolcollations: Node.t list } 
    val make : ?ctename:string -> ?aliascolnames:Node.t list -> ?ctematerialized:CTEMaterialize.t -> ?ctequery:Node.t -> ?search_clause:CTESearchClause.t -> ?cycle_clause:CTECycleClause.t -> ?location:int -> ?cterecursive:bool -> ?cterefcount:int -> ?ctecolnames:Node.t list -> ?ctecoltypes:Node.t list -> ?ctecoltypmods:Node.t list -> ?ctecolcollations:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CommonTableExpr"
    type t = { ctename: string; aliascolnames: Node.t list; ctematerialized: CTEMaterialize.t; ctequery: Node.t option; search_clause: CTESearchClause.t option; cycle_clause: CTECycleClause.t option; location: int; cterecursive: bool; cterefcount: int; ctecolnames: Node.t list; ctecoltypes: Node.t list; ctecoltypmods: Node.t list; ctecolcollations: Node.t list }
    let make =
      fun ?ctename ?aliascolnames ?ctematerialized ?ctequery ?search_clause ?cycle_clause ?location ?cterecursive ?cterefcount ?ctecolnames ?ctecoltypes ?ctecoltypmods ?ctecolcollations () -> 
      let ctename = match ctename with Some v -> v | None -> {||} in
      let aliascolnames = match aliascolnames with Some v -> v | None -> [] in
      let ctematerialized = match ctematerialized with Some v -> v | None -> (CTEMaterialize.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let location = match location with Some v -> v | None -> 0 in
      let cterecursive = match cterecursive with Some v -> v | None -> false in
      let cterefcount = match cterefcount with Some v -> v | None -> 0 in
      let ctecolnames = match ctecolnames with Some v -> v | None -> [] in
      let ctecoltypes = match ctecoltypes with Some v -> v | None -> [] in
      let ctecoltypmods = match ctecoltypmods with Some v -> v | None -> [] in
      let ctecolcollations = match ctecolcollations with Some v -> v | None -> [] in
      { ctename; aliascolnames; ctematerialized; ctequery; search_clause; cycle_clause; location; cterecursive; cterefcount; ctecolnames; ctecoltypes; ctecoltypmods; ctecolcollations }
    
    let to_proto =
      let apply = fun ~f:f' { ctename; aliascolnames; ctematerialized; ctequery; search_clause; cycle_clause; location; cterecursive; cterefcount; ctecolnames; ctecoltypes; ctecoltypmods; ctecolcollations } -> f' [] ctename aliascolnames ctematerialized ctequery search_clause cycle_clause location cterecursive cterefcount ctecolnames ctecoltypes ctecoltypmods ctecolcollations in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, (enum CTEMaterialize.to_int), proto3) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: basic_opt (5, (message (fun t -> CTESearchClause.to_proto t))) ^:: basic_opt (6, (message (fun t -> CTECycleClause.to_proto t))) ^:: basic (7, int32_int, proto3) ^:: basic (8, bool, proto3) ^:: basic (9, int32_int, proto3) ^:: repeated (10, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (11, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (12, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (13, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions ctename aliascolnames ctematerialized ctequery search_clause cycle_clause location cterecursive cterefcount ctecolnames ctecoltypes ctecoltypmods ctecolcollations -> { ctename; aliascolnames; ctematerialized; ctequery; search_clause; cycle_clause; location; cterecursive; cterefcount; ctecolnames; ctecoltypes; ctecoltypmods; ctecolcollations } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, (enum CTEMaterialize.from_int), proto3) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: basic_opt (5, (message (fun t -> CTESearchClause.from_proto t))) ^:: basic_opt (6, (message (fun t -> CTECycleClause.from_proto t))) ^:: basic (7, int32_int, proto3) ^:: basic (8, bool, proto3) ^:: basic (9, int32_int, proto3) ^:: repeated (10, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (11, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (12, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (13, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and MergeWhenClause : sig
    val name': unit -> string
    type t = { matched: bool; command_type: CmdType.t; override: OverridingKind.t; condition: Node.t option; target_list: Node.t list; values: Node.t list } 
    val make : ?matched:bool -> ?command_type:CmdType.t -> ?override:OverridingKind.t -> ?condition:Node.t -> ?target_list:Node.t list -> ?values:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.MergeWhenClause"
    type t = { matched: bool; command_type: CmdType.t; override: OverridingKind.t; condition: Node.t option; target_list: Node.t list; values: Node.t list }
    let make =
      fun ?matched ?command_type ?override ?condition ?target_list ?values () -> 
      let matched = match matched with Some v -> v | None -> false in
      let command_type = match command_type with Some v -> v | None -> (CmdType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let override = match override with Some v -> v | None -> (OverridingKind.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let target_list = match target_list with Some v -> v | None -> [] in
      let values = match values with Some v -> v | None -> [] in
      { matched; command_type; override; condition; target_list; values }
    
    let to_proto =
      let apply = fun ~f:f' { matched; command_type; override; condition; target_list; values } -> f' [] matched command_type override condition target_list values in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic (2, (enum CmdType.to_int), proto3) ^:: basic (3, (enum OverridingKind.to_int), proto3) ^:: basic_opt (4, (message (fun t -> Node.to_proto t))) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions matched command_type override condition target_list values -> { matched; command_type; override; condition; target_list; values } in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic (2, (enum CmdType.from_int), proto3) ^:: basic (3, (enum OverridingKind.from_int), proto3) ^:: basic_opt (4, (message (fun t -> Node.from_proto t))) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and RoleSpec : sig
    val name': unit -> string
    type t = { roletype: RoleSpecType.t; rolename: string; location: int } 
    val make : ?roletype:RoleSpecType.t -> ?rolename:string -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.RoleSpec"
    type t = { roletype: RoleSpecType.t; rolename: string; location: int }
    let make =
      fun ?roletype ?rolename ?location () -> 
      let roletype = match roletype with Some v -> v | None -> (RoleSpecType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let rolename = match rolename with Some v -> v | None -> {||} in
      let location = match location with Some v -> v | None -> 0 in
      { roletype; rolename; location }
    
    let to_proto =
      let apply = fun ~f:f' { roletype; rolename; location } -> f' [] roletype rolename location in
      let spec = Runtime'.Serialize.C.( basic (1, (enum RoleSpecType.to_int), proto3) ^:: basic (2, string, proto3) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions roletype rolename location -> { roletype; rolename; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum RoleSpecType.from_int), proto3) ^:: basic (2, string, proto3) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and TriggerTransition : sig
    val name': unit -> string
    type t = { name: string; is_new: bool; is_table: bool } 
    val make : ?name:string -> ?is_new:bool -> ?is_table:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.TriggerTransition"
    type t = { name: string; is_new: bool; is_table: bool }
    let make =
      fun ?name ?is_new ?is_table () -> 
      let name = match name with Some v -> v | None -> {||} in
      let is_new = match is_new with Some v -> v | None -> false in
      let is_table = match is_table with Some v -> v | None -> false in
      { name; is_new; is_table }
    
    let to_proto =
      let apply = fun ~f:f' { name; is_new; is_table } -> f' [] name is_new is_table in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name is_new is_table -> { name; is_new; is_table } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PartitionElem : sig
    val name': unit -> string
    type t = { name: string; expr: Node.t option; collation: Node.t list; opclass: Node.t list; location: int } 
    val make : ?name:string -> ?expr:Node.t -> ?collation:Node.t list -> ?opclass:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.PartitionElem"
    type t = { name: string; expr: Node.t option; collation: Node.t list; opclass: Node.t list; location: int }
    let make =
      fun ?name ?expr ?collation ?opclass ?location () -> 
      let name = match name with Some v -> v | None -> {||} in
      let collation = match collation with Some v -> v | None -> [] in
      let opclass = match opclass with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { name; expr; collation; opclass; location }
    
    let to_proto =
      let apply = fun ~f:f' { name; expr; collation; opclass; location } -> f' [] name expr collation opclass location in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name expr collation opclass location -> { name; expr; collation; opclass; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (4, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (5, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PartitionSpec : sig
    val name': unit -> string
    type t = { strategy: string; part_params: Node.t list; location: int } 
    val make : ?strategy:string -> ?part_params:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.PartitionSpec"
    type t = { strategy: string; part_params: Node.t list; location: int }
    let make =
      fun ?strategy ?part_params ?location () -> 
      let strategy = match strategy with Some v -> v | None -> {||} in
      let part_params = match part_params with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { strategy; part_params; location }
    
    let to_proto =
      let apply = fun ~f:f' { strategy; part_params; location } -> f' [] strategy part_params location in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions strategy part_params location -> { strategy; part_params; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: repeated (2, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PartitionBoundSpec : sig
    val name': unit -> string
    type t = { strategy: string; is_default: bool; modulus: int; remainder: int; listdatums: Node.t list; lowerdatums: Node.t list; upperdatums: Node.t list; location: int } 
    val make : ?strategy:string -> ?is_default:bool -> ?modulus:int -> ?remainder:int -> ?listdatums:Node.t list -> ?lowerdatums:Node.t list -> ?upperdatums:Node.t list -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.PartitionBoundSpec"
    type t = { strategy: string; is_default: bool; modulus: int; remainder: int; listdatums: Node.t list; lowerdatums: Node.t list; upperdatums: Node.t list; location: int }
    let make =
      fun ?strategy ?is_default ?modulus ?remainder ?listdatums ?lowerdatums ?upperdatums ?location () -> 
      let strategy = match strategy with Some v -> v | None -> {||} in
      let is_default = match is_default with Some v -> v | None -> false in
      let modulus = match modulus with Some v -> v | None -> 0 in
      let remainder = match remainder with Some v -> v | None -> 0 in
      let listdatums = match listdatums with Some v -> v | None -> [] in
      let lowerdatums = match lowerdatums with Some v -> v | None -> [] in
      let upperdatums = match upperdatums with Some v -> v | None -> [] in
      let location = match location with Some v -> v | None -> 0 in
      { strategy; is_default; modulus; remainder; listdatums; lowerdatums; upperdatums; location }
    
    let to_proto =
      let apply = fun ~f:f' { strategy; is_default; modulus; remainder; listdatums; lowerdatums; upperdatums; location } -> f' [] strategy is_default modulus remainder listdatums lowerdatums upperdatums location in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, int32_int, proto3) ^:: repeated (5, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.to_proto t)), not_packed) ^:: repeated (7, (message (fun t -> Node.to_proto t)), not_packed) ^:: basic (8, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions strategy is_default modulus remainder listdatums lowerdatums upperdatums location -> { strategy; is_default; modulus; remainder; listdatums; lowerdatums; upperdatums; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, int32_int, proto3) ^:: basic (4, int32_int, proto3) ^:: repeated (5, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (6, (message (fun t -> Node.from_proto t)), not_packed) ^:: repeated (7, (message (fun t -> Node.from_proto t)), not_packed) ^:: basic (8, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PartitionRangeDatum : sig
    val name': unit -> string
    type t = { kind: PartitionRangeDatumKind.t; value: Node.t option; location: int } 
    val make : ?kind:PartitionRangeDatumKind.t -> ?value:Node.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.PartitionRangeDatum"
    type t = { kind: PartitionRangeDatumKind.t; value: Node.t option; location: int }
    let make =
      fun ?kind ?value ?location () -> 
      let kind = match kind with Some v -> v | None -> (PartitionRangeDatumKind.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let location = match location with Some v -> v | None -> 0 in
      { kind; value; location }
    
    let to_proto =
      let apply = fun ~f:f' { kind; value; location } -> f' [] kind value location in
      let spec = Runtime'.Serialize.C.( basic (1, (enum PartitionRangeDatumKind.to_int), proto3) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions kind value location -> { kind; value; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum PartitionRangeDatumKind.from_int), proto3) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: basic (3, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PartitionCmd : sig
    val name': unit -> string
    type t = { name: RangeVar.t option; bound: PartitionBoundSpec.t option; concurrent: bool } 
    val make : ?name:RangeVar.t -> ?bound:PartitionBoundSpec.t -> ?concurrent:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.PartitionCmd"
    type t = { name: RangeVar.t option; bound: PartitionBoundSpec.t option; concurrent: bool }
    let make =
      fun ?name ?bound ?concurrent () -> 
      let concurrent = match concurrent with Some v -> v | None -> false in
      { name; bound; concurrent }
    
    let to_proto =
      let apply = fun ~f:f' { name; bound; concurrent } -> f' [] name bound concurrent in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: basic_opt (2, (message (fun t -> PartitionBoundSpec.to_proto t))) ^:: basic (3, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions name bound concurrent -> { name; bound; concurrent } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: basic_opt (2, (message (fun t -> PartitionBoundSpec.from_proto t))) ^:: basic (3, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and VacuumRelation : sig
    val name': unit -> string
    type t = { relation: RangeVar.t option; oid: int; va_cols: Node.t list } 
    val make : ?relation:RangeVar.t -> ?oid:int -> ?va_cols:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.VacuumRelation"
    type t = { relation: RangeVar.t option; oid: int; va_cols: Node.t list }
    let make =
      fun ?relation ?oid ?va_cols () -> 
      let oid = match oid with Some v -> v | None -> 0 in
      let va_cols = match va_cols with Some v -> v | None -> [] in
      { relation; oid; va_cols }
    
    let to_proto =
      let apply = fun ~f:f' { relation; oid; va_cols } -> f' [] relation oid va_cols in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: basic (2, uint32_int, proto3) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions relation oid va_cols -> { relation; oid; va_cols } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: basic (2, uint32_int, proto3) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PublicationObjSpec : sig
    val name': unit -> string
    type t = { pubobjtype: PublicationObjSpecType.t; name: string; pubtable: PublicationTable.t option; location: int } 
    val make : ?pubobjtype:PublicationObjSpecType.t -> ?name:string -> ?pubtable:PublicationTable.t -> ?location:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.PublicationObjSpec"
    type t = { pubobjtype: PublicationObjSpecType.t; name: string; pubtable: PublicationTable.t option; location: int }
    let make =
      fun ?pubobjtype ?name ?pubtable ?location () -> 
      let pubobjtype = match pubobjtype with Some v -> v | None -> (PublicationObjSpecType.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let name = match name with Some v -> v | None -> {||} in
      let location = match location with Some v -> v | None -> 0 in
      { pubobjtype; name; pubtable; location }
    
    let to_proto =
      let apply = fun ~f:f' { pubobjtype; name; pubtable; location } -> f' [] pubobjtype name pubtable location in
      let spec = Runtime'.Serialize.C.( basic (1, (enum PublicationObjSpecType.to_int), proto3) ^:: basic (2, string, proto3) ^:: basic_opt (3, (message (fun t -> PublicationTable.to_proto t))) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions pubobjtype name pubtable location -> { pubobjtype; name; pubtable; location } in
      let spec = Runtime'.Deserialize.C.( basic (1, (enum PublicationObjSpecType.from_int), proto3) ^:: basic (2, string, proto3) ^:: basic_opt (3, (message (fun t -> PublicationTable.from_proto t))) ^:: basic (4, int32_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and PublicationTable : sig
    val name': unit -> string
    type t = { relation: RangeVar.t option; where_clause: Node.t option; columns: Node.t list } 
    val make : ?relation:RangeVar.t -> ?where_clause:Node.t -> ?columns:Node.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.PublicationTable"
    type t = { relation: RangeVar.t option; where_clause: Node.t option; columns: Node.t list }
    let make =
      fun ?relation ?where_clause ?columns () -> 
      let columns = match columns with Some v -> v | None -> [] in
      { relation; where_clause; columns }
    
    let to_proto =
      let apply = fun ~f:f' { relation; where_clause; columns } -> f' [] relation where_clause columns in
      let spec = Runtime'.Serialize.C.( basic_opt (1, (message (fun t -> RangeVar.to_proto t))) ^:: basic_opt (2, (message (fun t -> Node.to_proto t))) ^:: repeated (3, (message (fun t -> Node.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions relation where_clause columns -> { relation; where_clause; columns } in
      let spec = Runtime'.Deserialize.C.( basic_opt (1, (message (fun t -> RangeVar.from_proto t))) ^:: basic_opt (2, (message (fun t -> Node.from_proto t))) ^:: repeated (3, (message (fun t -> Node.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and InlineCodeBlock : sig
    val name': unit -> string
    type t = { source_text: string; lang_oid: int; lang_is_trusted: bool; atomic: bool } 
    val make : ?source_text:string -> ?lang_oid:int -> ?lang_is_trusted:bool -> ?atomic:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.InlineCodeBlock"
    type t = { source_text: string; lang_oid: int; lang_is_trusted: bool; atomic: bool }
    let make =
      fun ?source_text ?lang_oid ?lang_is_trusted ?atomic () -> 
      let source_text = match source_text with Some v -> v | None -> {||} in
      let lang_oid = match lang_oid with Some v -> v | None -> 0 in
      let lang_is_trusted = match lang_is_trusted with Some v -> v | None -> false in
      let atomic = match atomic with Some v -> v | None -> false in
      { source_text; lang_oid; lang_is_trusted; atomic }
    
    let to_proto =
      let apply = fun ~f:f' { source_text; lang_oid; lang_is_trusted; atomic } -> f' [] source_text lang_oid lang_is_trusted atomic in
      let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, uint32_int, proto3) ^:: basic (3, bool, proto3) ^:: basic (4, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions source_text lang_oid lang_is_trusted atomic -> { source_text; lang_oid; lang_is_trusted; atomic } in
      let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, uint32_int, proto3) ^:: basic (3, bool, proto3) ^:: basic (4, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and CallContext : sig
    val name': unit -> string
    type t = bool 
    val make : ?atomic:bool -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.CallContext"
    type t = bool
    let make =
      fun ?atomic () -> 
      let atomic = match atomic with Some v -> v | None -> false in
      atomic
    
    let to_proto =
      let apply = fun ~f:f' atomic -> f' [] atomic in
      let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions atomic -> atomic in
      let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
  and ScanToken : sig
    val name': unit -> string
    type t = { start: int; end': int; token: Token.t; keyword_kind: KeywordKind.t } 
    val make : ?start:int -> ?end':int -> ?token:Token.t -> ?keyword_kind:KeywordKind.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct 
    let name' () = "pg_query.pg_query.ScanToken"
    type t = { start: int; end': int; token: Token.t; keyword_kind: KeywordKind.t }
    let make =
      fun ?start ?end' ?token ?keyword_kind () -> 
      let start = match start with Some v -> v | None -> 0 in
      let end' = match end' with Some v -> v | None -> 0 in
      let token = match token with Some v -> v | None -> (Token.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      let keyword_kind = match keyword_kind with Some v -> v | None -> (KeywordKind.from_int 0 |> Runtime'.Result.get ~msg:"Code gen error") in
      { start; end'; token; keyword_kind }
    
    let to_proto =
      let apply = fun ~f:f' { start; end'; token; keyword_kind } -> f' [] start end' token keyword_kind in
      let spec = Runtime'.Serialize.C.( basic (1, int32_int, proto3) ^:: basic (2, int32_int, proto3) ^:: basic (4, (enum Token.to_int), proto3) ^:: basic (5, (enum KeywordKind.to_int), proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t
    
    let from_proto =
      let constructor = fun _extensions start end' token keyword_kind -> { start; end'; token; keyword_kind } in
      let spec = Runtime'.Deserialize.C.( basic (1, int32_int, proto3) ^:: basic (2, int32_int, proto3) ^:: basic (4, (enum Token.from_int), proto3) ^:: basic (5, (enum KeywordKind.from_int), proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error
    
  end
end